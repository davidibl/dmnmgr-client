/*!
 * dmn-js - dmn-modeler v5.2.0
 *
 * Copyright (c) 2014-present, camunda Services GmbH
 *
 * Released under the bpmn.io license
 * http://bpmn.io/license
 *
 * Source Code: https://github.com/bpmn-io/dmn-js
 *
 * Date: 2018-09-04
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.DmnJS = factory());
}(this, (function () { 'use strict';

  /**
   * Flatten array, one level deep.
   *
   * @param {Array<?>} arr
   *
   * @return {Array<?>}
   */
  function flatten(arr) {
    return Array.prototype.concat.apply([], arr);
  }

  var nativeToString = Object.prototype.toString;
  var nativeHasOwnProperty = Object.prototype.hasOwnProperty;

  function isUndefined(obj) {
    return obj === null || obj === undefined;
  }

  function isDefined(obj) {
    return obj !== null || obj !== undefined;
  }

  function isArray(obj) {
    return nativeToString.call(obj) === '[object Array]';
  }

  function isObject(obj) {
    return nativeToString.call(obj) === '[object Object]';
  }

  function isNumber(obj) {
    return nativeToString.call(obj) === '[object Number]';
  }

  function isFunction(obj) {
    return nativeToString.call(obj) === '[object Function]';
  }

  function isString(obj) {
    return nativeToString.call(obj) === '[object String]';
  }

  /**
   * Return true, if target owns a property with the given key.
   *
   * @param {Object} target
   * @param {String} key
   *
   * @return {Boolean}
   */
  function has(target, key) {
    return nativeHasOwnProperty.call(target, key);
  }

  /**
   * Find element in collection.
   *
   * @param  {Array|Object} collection
   * @param  {Function|Object} matcher
   *
   * @return {Object}
   */
  function find(collection, matcher) {

    matcher = toMatcher(matcher);

    var match;

    forEach(collection, function (val, key) {
      if (matcher(val, key)) {
        match = val;

        return false;
      }
    });

    return match;
  }

  /**
   * Find element index in collection.
   *
   * @param  {Array|Object} collection
   * @param  {Function} matcher
   *
   * @return {Object}
   */
  function findIndex(collection, matcher) {

    matcher = toMatcher(matcher);

    var idx = isArray(collection) ? -1 : undefined;

    forEach(collection, function (val, key) {
      if (matcher(val, key)) {
        idx = key;

        return false;
      }
    });

    return idx;
  }

  /**
   * Find element in collection.
   *
   * @param  {Array|Object} collection
   * @param  {Function} matcher
   *
   * @return {Array} result
   */
  function filter(collection, matcher) {

    var result = [];

    forEach(collection, function (val, key) {
      if (matcher(val, key)) {
        result.push(val);
      }
    });

    return result;
  }

  /**
   * Iterate over collection; returning something
   * (non-undefined) will stop iteration.
   *
   * @param  {Array|Object} collection
   * @param  {Function} iterator
   *
   * @return {Object} return result that stopped the iteration
   */
  function forEach(collection, iterator) {

    if (isUndefined(collection)) {
      return;
    }

    var convertKey = isArray(collection) ? toNum : identity;

    for (var key in collection) {

      if (has(collection, key)) {
        var val = collection[key];

        var result = iterator(val, convertKey(key));

        if (result === false) {
          return;
        }
      }
    }
  }

  /**
   * Reduce collection, returning a single result.
   *
   * @param  {Object|Array} collection
   * @param  {Function} iterator
   * @param  {Any} result
   *
   * @return {Any} result returned from last iterator
   */
  function reduce(collection, iterator, result) {

    forEach(collection, function (value, idx) {
      result = iterator(result, value, idx);
    });

    return result;
  }

  /**
   * Return true if every element in the collection
   * matches the criteria.
   *
   * @param  {Object|Array} collection
   * @param  {Function} matcher
   *
   * @return {Boolean}
   */
  function every(collection, matcher) {

    return reduce(collection, function (matches, val, key) {
      return matches && matcher(val, key);
    }, true);
  }

  /**
   * Return true if some elements in the collection
   * match the criteria.
   *
   * @param  {Object|Array} collection
   * @param  {Function} matcher
   *
   * @return {Boolean}
   */
  function some(collection, matcher) {

    return !!find(collection, matcher);
  }

  /**
   * Transform a collection into another collection
   * by piping each member through the given fn.
   *
   * @param  {Object|Array}   collection
   * @param  {Function} fn
   *
   * @return {Array} transformed collection
   */
  function map(collection, fn) {

    var result = [];

    forEach(collection, function (val, key) {
      result.push(fn(val, key));
    });

    return result;
  }

  /**
   * Get the collections keys.
   *
   * @param  {Object|Array} collection
   *
   * @return {Array}
   */
  function keys(collection) {
    return collection && Object.keys(collection) || [];
  }

  /**
   * Shorthand for `keys(o).length`.
   *
   * @param  {Object|Array} collection
   *
   * @return {Number}
   */
  function size(collection) {
    return keys(collection).length;
  }

  /**
   * Get the values in the collection.
   *
   * @param  {Object|Array} collection
   *
   * @return {Array}
   */
  function values(collection) {
    return map(collection, function (val) {
      return val;
    });
  }

  /**
   * Group collection members by attribute.
   *
   * @param  {Object|Array} collection
   * @param  {Function} extractor
   *
   * @return {Object} map with { attrValue => [ a, b, c ] }
   */
  function groupBy(collection, extractor) {
    var grouped = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    extractor = toExtractor(extractor);

    forEach(collection, function (val) {
      var discriminator = extractor(val) || '_';

      var group = grouped[discriminator];

      if (!group) {
        group = grouped[discriminator] = [];
      }

      group.push(val);
    });

    return grouped;
  }

  function uniqueBy(extractor) {

    extractor = toExtractor(extractor);

    var grouped = {};

    for (var _len = arguments.length, collections = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      collections[_key - 1] = arguments[_key];
    }

    forEach(collections, function (c) {
      return groupBy(c, extractor, grouped);
    });

    var result = map(grouped, function (val, key) {
      return val[0];
    });

    return result;
  }

  /**
   * Sort collection by criteria.
   *
   * @param  {Object|Array} collection
   * @param  {String|Function} extractor
   *
   * @return {Array}
   */
  function sortBy(collection, extractor) {

    extractor = toExtractor(extractor);

    var sorted = [];

    forEach(collection, function (value, key) {
      var disc = extractor(value, key);

      var entry = {
        d: disc,
        v: value
      };

      for (var idx = 0; idx < sorted.length; idx++) {
        var d = sorted[idx].d;

        if (disc < d) {
          sorted.splice(idx, 0, entry);
          return;
        }
      }

      // not inserted, append (!)
      sorted.push(entry);
    });

    return map(sorted, function (e) {
      return e.v;
    });
  }

  /**
   * Create an object pattern matcher.
   *
   * @example
   *
   * const matcher = matchPattern({ id: 1 });
   *
   * var element = find(elements, matcher);
   *
   * @param  {Object} pattern
   *
   * @return {Function} matcherFn
   */
  function matchPattern(pattern) {

    return function (el) {

      return every(pattern, function (val, key) {
        return el[key] === val;
      });
    };
  }

  function toExtractor(extractor) {
    return isFunction(extractor) ? extractor : function (e) {
      return e[extractor];
    };
  }

  function toMatcher(matcher) {
    return isFunction(matcher) ? matcher : function (e) {
      return e === matcher;
    };
  }

  function identity(arg) {
    return arg;
  }

  function toNum(arg) {
    return Number(arg);
  }

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  var slice = Array.prototype.slice;

  /**
   * Debounce fn, calling it only once if
   * the given time elapsed between calls.
   *
   * @param  {Function} fn
   * @param  {Number} timeout
   *
   * @return {Function} debounced function
   */
  function debounce(fn, timeout) {

    var timer;

    return function () {

      var args = slice.call(arguments);

      if (timer) {
        clearTimeout(timer);
      }

      timer = setTimeout(function () {
        fn.apply(undefined, _toConsumableArray(args));
      }, timeout);
    };
  }

  /**
   * Bind function against target <this>.
   *
   * @param  {Function} fn
   * @param  {Object}   target
   *
   * @return {Function} bound function
   */
  function bind(fn, target) {
    return fn.bind(target);
  }

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  /**
   * Convenience wrapper for `Object.assign`.
   *
   * @param {Object} target
   * @param {...Object} others
   *
   * @return {Object} the target
   */
  function assign(target) {
    for (var _len = arguments.length, others = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      others[_key - 1] = arguments[_key];
    }

    return _extends.apply(undefined, [target].concat(others));
  }

  /**
   * Pick given properties from the target object.
   *
   * @param {Object} target
   * @param {Array} properties
   *
   * @return {Object} target
   */
  function pick(target, properties) {

    var result = {};

    var obj = Object(target);

    forEach(properties, function (prop) {

      if (prop in obj) {
        result[prop] = target[prop];
      }
    });

    return result;
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var FN_REF = '__fn';

  var DEFAULT_PRIORITY = 1000;

  var slice$1 = Array.prototype.slice;

  /**
   * A general purpose event bus.
   *
   * This component is used to communicate across a diagram instance.
   * Other parts of a diagram can use it to listen to and broadcast events.
   *
   *
   * ## Registering for Events
   *
   * The event bus provides the {@link EventBus#on} and {@link EventBus#once}
   * methods to register for events. {@link EventBus#off} can be used to
   * remove event registrations. Listeners receive an instance of {@link Event}
   * as the first argument. It allows them to hook into the event execution.
   *
   * ```javascript
   *
   * // listen for event
   * eventBus.on('foo', function(event) {
   *
   *   // access event type
   *   event.type; // 'foo'
   *
   *   // stop propagation to other listeners
   *   event.stopPropagation();
   *
   *   // prevent event default
   *   event.preventDefault();
   * });
   *
   * // listen for event with custom payload
   * eventBus.on('bar', function(event, payload) {
   *   console.log(payload);
   * });
   *
   * // listen for event returning value
   * eventBus.on('foobar', function(event) {
   *
   *   // stop event propagation + prevent default
   *   return false;
   *
   *   // stop event propagation + return custom result
   *   return {
   *     complex: 'listening result'
   *   };
   * });
   *
   *
   * // listen with custom priority (default=1000, higher is better)
   * eventBus.on('priorityfoo', 1500, function(event) {
   *   console.log('invoked first!');
   * });
   *
   *
   * // listen for event and pass the context (`this`)
   * eventBus.on('foobar', function(event) {
   *   this.foo();
   * }, this);
   * ```
   *
   *
   * ## Emitting Events
   *
   * Events can be emitted via the event bus using {@link EventBus#fire}.
   *
   * ```javascript
   *
   * // false indicates that the default action
   * // was prevented by listeners
   * if (eventBus.fire('foo') === false) {
   *   console.log('default has been prevented!');
   * };
   *
   *
   * // custom args + return value listener
   * eventBus.on('sum', function(event, a, b) {
   *   return a + b;
   * });
   *
   * // you can pass custom arguments + retrieve result values.
   * var sum = eventBus.fire('sum', 1, 2);
   * console.log(sum); // 3
   * ```
   */
  function EventBus() {
    this._listeners = {};

    // cleanup on destroy on lowest priority to allow
    // message passing until the bitter end
    this.on('diagram.destroy', 1, this._destroy, this);
  }

  /**
   * Register an event listener for events with the given name.
   *
   * The callback will be invoked with `event, ...additionalArguments`
   * that have been passed to {@link EventBus#fire}.
   *
   * Returning false from a listener will prevent the events default action
   * (if any is specified). To stop an event from being processed further in
   * other listeners execute {@link Event#stopPropagation}.
   *
   * Returning anything but `undefined` from a listener will stop the listener propagation.
   *
   * @param {String|Array<String>} events
   * @param {Number} [priority=1000] the priority in which this listener is called, larger is higher
   * @param {Function} callback
   * @param {Object} [that] Pass context (`this`) to the callback
   */
  EventBus.prototype.on = function (events, priority, callback, that) {

    events = isArray(events) ? events : [events];

    if (isFunction(priority)) {
      that = callback;
      callback = priority;
      priority = DEFAULT_PRIORITY;
    }

    if (!isNumber(priority)) {
      throw new Error('priority must be a number');
    }

    var actualCallback = callback;

    if (that) {
      actualCallback = bind(callback, that);

      // make sure we remember and are able to remove
      // bound callbacks via {@link #off} using the original
      // callback
      actualCallback[FN_REF] = callback[FN_REF] || callback;
    }

    var self = this,
        listener = { priority: priority, callback: actualCallback };

    events.forEach(function (e) {
      self._addListener(e, listener);
    });
  };

  /**
   * Register an event listener that is executed only once.
   *
   * @param {String} event the event name to register for
   * @param {Function} callback the callback to execute
   * @param {Object} [that] Pass context (`this`) to the callback
   */
  EventBus.prototype.once = function (event, priority, callback, that) {
    var self = this;

    if (isFunction(priority)) {
      that = callback;
      callback = priority;
      priority = DEFAULT_PRIORITY;
    }

    if (!isNumber(priority)) {
      throw new Error('priority must be a number');
    }

    function wrappedCallback() {
      self.off(event, wrappedCallback);
      return callback.apply(that, arguments);
    }

    // make sure we remember and are able to remove
    // bound callbacks via {@link #off} using the original
    // callback
    wrappedCallback[FN_REF] = callback;

    this.on(event, priority, wrappedCallback);
  };

  /**
   * Removes event listeners by event and callback.
   *
   * If no callback is given, all listeners for a given event name are being removed.
   *
   * @param {String|Array<String>} events
   * @param {Function} [callback]
   */
  EventBus.prototype.off = function (events, callback) {

    events = isArray(events) ? events : [events];

    var self = this;

    events.forEach(function (event) {
      self._removeListener(event, callback);
    });
  };

  /**
   * Create an EventBus event.
   *
   * @param {Object} data
   *
   * @return {Object} event, recognized by the eventBus
   */
  EventBus.prototype.createEvent = function (data) {
    var event = new InternalEvent();

    event.init(data);

    return event;
  };

  /**
   * Fires a named event.
   *
   * @example
   *
   * // fire event by name
   * events.fire('foo');
   *
   * // fire event object with nested type
   * var event = { type: 'foo' };
   * events.fire(event);
   *
   * // fire event with explicit type
   * var event = { x: 10, y: 20 };
   * events.fire('element.moved', event);
   *
   * // pass additional arguments to the event
   * events.on('foo', function(event, bar) {
   *   alert(bar);
   * });
   *
   * events.fire({ type: 'foo' }, 'I am bar!');
   *
   * @param {String} [name] the optional event name
   * @param {Object} [event] the event object
   * @param {...Object} additional arguments to be passed to the callback functions
   *
   * @return {Boolean} the events return value, if specified or false if the
   *                   default action was prevented by listeners
   */
  EventBus.prototype.fire = function (type, data) {

    var event, listeners, returnValue, args;

    args = slice$1.call(arguments);

    if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {
      event = type;
      type = event.type;
    }

    if (!type) {
      throw new Error('no event type specified');
    }

    listeners = this._listeners[type];

    if (!listeners) {
      return;
    }

    // we make sure we fire instances of our home made
    // events here. We wrap them only once, though
    if (data instanceof InternalEvent) {
      // we are fine, we alread have an event
      event = data;
    } else {
      event = this.createEvent(data);
    }

    // ensure we pass the event as the first parameter
    args[0] = event;

    // original event type (in case we delegate)
    var originalType = event.type;

    // update event type before delegation
    if (type !== originalType) {
      event.type = type;
    }

    try {
      returnValue = this._invokeListeners(event, args, listeners);
    } finally {
      // reset event type after delegation
      if (type !== originalType) {
        event.type = originalType;
      }
    }

    // set the return value to false if the event default
    // got prevented and no other return value exists
    if (returnValue === undefined && event.defaultPrevented) {
      returnValue = false;
    }

    return returnValue;
  };

  EventBus.prototype.handleError = function (error) {
    return this.fire('error', { error: error }) === false;
  };

  EventBus.prototype._destroy = function () {
    this._listeners = {};
  };

  EventBus.prototype._invokeListeners = function (event, args, listeners) {

    var idx, listener, returnValue;

    for (idx = 0; listener = listeners[idx]; idx++) {

      // handle stopped propagation
      if (event.cancelBubble) {
        break;
      }

      returnValue = this._invokeListener(event, args, listener);
    }

    return returnValue;
  };

  EventBus.prototype._invokeListener = function (event, args, listener) {

    var returnValue;

    try {
      // returning false prevents the default action
      returnValue = invokeFunction(listener.callback, args);

      // stop propagation on return value
      if (returnValue !== undefined) {
        event.returnValue = returnValue;
        event.stopPropagation();
      }

      // prevent default on return false
      if (returnValue === false) {
        event.preventDefault();
      }
    } catch (e) {
      if (!this.handleError(e)) {
        console.error('unhandled error in event listener');
        console.error(e.stack);

        throw e;
      }
    }

    return returnValue;
  };

  /*
   * Add new listener with a certain priority to the list
   * of listeners (for the given event).
   *
   * The semantics of listener registration / listener execution are
   * first register, first serve: New listeners will always be inserted
   * after existing listeners with the same priority.
   *
   * Example: Inserting two listeners with priority 1000 and 1300
   *
   *    * before: [ 1500, 1500, 1000, 1000 ]
   *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]
   *
   * @param {String} event
   * @param {Object} listener { priority, callback }
   */
  EventBus.prototype._addListener = function (event, newListener) {

    var listeners = this._getListeners(event),
        existingListener,
        idx;

    // ensure we order listeners by priority from
    // 0 (high) to n > 0 (low)
    for (idx = 0; existingListener = listeners[idx]; idx++) {
      if (existingListener.priority < newListener.priority) {

        // prepend newListener at before existingListener
        listeners.splice(idx, 0, newListener);
        return;
      }
    }

    listeners.push(newListener);
  };

  EventBus.prototype._getListeners = function (name) {
    var listeners = this._listeners[name];

    if (!listeners) {
      this._listeners[name] = listeners = [];
    }

    return listeners;
  };

  EventBus.prototype._removeListener = function (event, callback) {

    var listeners = this._getListeners(event),
        listener,
        listenerCallback,
        idx;

    if (callback) {

      // move through listeners from back to front
      // and remove matching listeners
      for (idx = listeners.length - 1; listener = listeners[idx]; idx--) {
        listenerCallback = listener.callback;

        if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {
          listeners.splice(idx, 1);
        }
      }
    } else {
      // clear listeners
      listeners.length = 0;
    }
  };

  /**
   * A event that is emitted via the event bus.
   */
  function InternalEvent() {}

  InternalEvent.prototype.stopPropagation = function () {
    this.cancelBubble = true;
  };

  InternalEvent.prototype.preventDefault = function () {
    this.defaultPrevented = true;
  };

  InternalEvent.prototype.init = function (data) {
    assign(this, data || {});
  };

  /**
   * Invoke function. Be fast...
   *
   * @param {Function} fn
   * @param {Array<Object>} args
   *
   * @return {Any}
   */
  function invokeFunction(fn, args) {
    return fn.apply(null, args);
  }

  /**
   * Moddle base element.
   */
  function Base() {}

  Base.prototype.get = function (name) {
    return this.$model.properties.get(this, name);
  };

  Base.prototype.set = function (name, value) {
    this.$model.properties.set(this, name, value);
  };

  /**
   * A model element factory.
   *
   * @param {Moddle} model
   * @param {Properties} properties
   */
  function Factory(model, properties) {
    this.model = model;
    this.properties = properties;
  }

  Factory.prototype.createType = function (descriptor) {

    var model = this.model;

    var props = this.properties,
        prototype = Object.create(Base.prototype);

    // initialize default values
    forEach(descriptor.properties, function (p) {
      if (!p.isMany && p.default !== undefined) {
        prototype[p.name] = p.default;
      }
    });

    props.defineModel(prototype, model);
    props.defineDescriptor(prototype, descriptor);

    var name = descriptor.ns.name;

    /**
     * The new type constructor
     */
    function ModdleElement(attrs) {
      props.define(this, '$type', { value: name, enumerable: true });
      props.define(this, '$attrs', { value: {} });
      props.define(this, '$parent', { writable: true });

      forEach(attrs, bind(function (val, key) {
        this.set(key, val);
      }, this));
    }

    ModdleElement.prototype = prototype;

    ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;

    // static links
    props.defineModel(ModdleElement, model);
    props.defineDescriptor(ModdleElement, descriptor);

    return ModdleElement;
  };

  /**
   * Built-in moddle types
   */
  var BUILTINS = {
    String: true,
    Boolean: true,
    Integer: true,
    Real: true,
    Element: true
  };

  /**
   * Converters for built in types from string representations
   */
  var TYPE_CONVERTERS = {
    String: function String(s) {
      return s;
    },
    Boolean: function Boolean(s) {
      return s === 'true';
    },
    Integer: function Integer(s) {
      return parseInt(s, 10);
    },
    Real: function Real(s) {
      return parseFloat(s, 10);
    }
  };

  /**
   * Convert a type to its real representation
   */
  function coerceType(type, value) {

    var converter = TYPE_CONVERTERS[type];

    if (converter) {
      return converter(value);
    } else {
      return value;
    }
  }

  /**
   * Return whether the given type is built-in
   */
  function isBuiltIn(type) {
    return !!BUILTINS[type];
  }

  /**
   * Return whether the given type is simple
   */
  function isSimple(type) {
    return !!TYPE_CONVERTERS[type];
  }

  /**
   * Parses a namespaced attribute name of the form (ns:)localName to an object,
   * given a default prefix to assume in case no explicit namespace is given.
   *
   * @param {String} name
   * @param {String} [defaultPrefix] the default prefix to take, if none is present.
   *
   * @return {Object} the parsed name
   */
  function parseName(name, defaultPrefix) {
    var parts = name.split(/:/),
        localName,
        prefix;

    // no prefix (i.e. only local name)
    if (parts.length === 1) {
      localName = name;
      prefix = defaultPrefix;
    } else
      // prefix + local name
      if (parts.length === 2) {
        localName = parts[1];
        prefix = parts[0];
      } else {
        throw new Error('expected <prefix:localName> or <localName>, got ' + name);
      }

    name = (prefix ? prefix + ':' : '') + localName;

    return {
      name: name,
      prefix: prefix,
      localName: localName
    };
  }

  /**
   * A utility to build element descriptors.
   */
  function DescriptorBuilder(nameNs) {
    this.ns = nameNs;
    this.name = nameNs.name;
    this.allTypes = [];
    this.allTypesByName = {};
    this.properties = [];
    this.propertiesByName = {};
  }

  DescriptorBuilder.prototype.build = function () {
    return pick(this, ['ns', 'name', 'allTypes', 'allTypesByName', 'properties', 'propertiesByName', 'bodyProperty', 'idProperty']);
  };

  /**
   * Add property at given index.
   *
   * @param {Object} p
   * @param {Number} [idx]
   * @param {Boolean} [validate=true]
   */
  DescriptorBuilder.prototype.addProperty = function (p, idx, validate) {

    if (typeof idx === 'boolean') {
      validate = idx;
      idx = undefined;
    }

    this.addNamedProperty(p, validate !== false);

    var properties = this.properties;

    if (idx !== undefined) {
      properties.splice(idx, 0, p);
    } else {
      properties.push(p);
    }
  };

  DescriptorBuilder.prototype.replaceProperty = function (oldProperty, newProperty, replace) {
    var oldNameNs = oldProperty.ns;

    var props = this.properties,
        propertiesByName = this.propertiesByName,
        rename = oldProperty.name !== newProperty.name;

    if (oldProperty.isId) {
      if (!newProperty.isId) {
        throw new Error('property <' + newProperty.ns.name + '> must be id property ' + 'to refine <' + oldProperty.ns.name + '>');
      }

      this.setIdProperty(newProperty, false);
    }

    if (oldProperty.isBody) {

      if (!newProperty.isBody) {
        throw new Error('property <' + newProperty.ns.name + '> must be body property ' + 'to refine <' + oldProperty.ns.name + '>');
      }

      // TODO: Check compatibility
      this.setBodyProperty(newProperty, false);
    }

    // validate existence and get location of old property
    var idx = props.indexOf(oldProperty);
    if (idx === -1) {
      throw new Error('property <' + oldNameNs.name + '> not found in property list');
    }

    // remove old property
    props.splice(idx, 1);

    // replacing the named property is intentional
    //
    //  * validate only if this is a "rename" operation
    //  * add at specific index unless we "replace"
    //
    this.addProperty(newProperty, replace ? undefined : idx, rename);

    // make new property available under old name
    propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;
  };

  DescriptorBuilder.prototype.redefineProperty = function (p, targetPropertyName, replace) {

    var nsPrefix = p.ns.prefix;
    var parts = targetPropertyName.split('#');

    var name = parseName(parts[0], nsPrefix);
    var attrName = parseName(parts[1], name.prefix).name;

    var redefinedProperty = this.propertiesByName[attrName];
    if (!redefinedProperty) {
      throw new Error('refined property <' + attrName + '> not found');
    } else {
      this.replaceProperty(redefinedProperty, p, replace);
    }

    delete p.redefines;
  };

  DescriptorBuilder.prototype.addNamedProperty = function (p, validate) {
    var ns = p.ns,
        propsByName = this.propertiesByName;

    if (validate) {
      this.assertNotDefined(p, ns.name);
      this.assertNotDefined(p, ns.localName);
    }

    propsByName[ns.name] = propsByName[ns.localName] = p;
  };

  DescriptorBuilder.prototype.removeNamedProperty = function (p) {
    var ns = p.ns,
        propsByName = this.propertiesByName;

    delete propsByName[ns.name];
    delete propsByName[ns.localName];
  };

  DescriptorBuilder.prototype.setBodyProperty = function (p, validate) {

    if (validate && this.bodyProperty) {
      throw new Error('body property defined multiple times ' + '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');
    }

    this.bodyProperty = p;
  };

  DescriptorBuilder.prototype.setIdProperty = function (p, validate) {

    if (validate && this.idProperty) {
      throw new Error('id property defined multiple times ' + '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');
    }

    this.idProperty = p;
  };

  DescriptorBuilder.prototype.assertNotDefined = function (p, name) {
    var propertyName = p.name,
        definedProperty = this.propertiesByName[propertyName];

    if (definedProperty) {
      throw new Error('property <' + propertyName + '> already defined; ' + 'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' + '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');
    }
  };

  DescriptorBuilder.prototype.hasProperty = function (name) {
    return this.propertiesByName[name];
  };

  DescriptorBuilder.prototype.addTrait = function (t, inherited) {

    var typesByName = this.allTypesByName,
        types = this.allTypes;

    var typeName = t.name;

    if (typeName in typesByName) {
      return;
    }

    forEach(t.properties, bind(function (p) {

      // clone property to allow extensions
      p = assign({}, p, {
        name: p.ns.localName,
        inherited: inherited
      });

      Object.defineProperty(p, 'definedBy', {
        value: t
      });

      var replaces = p.replaces,
          redefines = p.redefines;

      // add replace/redefine support
      if (replaces || redefines) {
        this.redefineProperty(p, replaces || redefines, replaces);
      } else {
        if (p.isBody) {
          this.setBodyProperty(p);
        }
        if (p.isId) {
          this.setIdProperty(p);
        }
        this.addProperty(p);
      }
    }, this));

    types.push(t);
    typesByName[typeName] = t;
  };

  /**
   * A registry of Moddle packages.
   *
   * @param {Array<Package>} packages
   * @param {Properties} properties
   */
  function Registry(packages, properties) {
    this.packageMap = {};
    this.typeMap = {};

    this.packages = [];

    this.properties = properties;

    forEach(packages, bind(this.registerPackage, this));
  }

  Registry.prototype.getPackage = function (uriOrPrefix) {
    return this.packageMap[uriOrPrefix];
  };

  Registry.prototype.getPackages = function () {
    return this.packages;
  };

  Registry.prototype.registerPackage = function (pkg) {

    // copy package
    pkg = assign({}, pkg);

    var pkgMap = this.packageMap;

    ensureAvailable(pkgMap, pkg, 'prefix');
    ensureAvailable(pkgMap, pkg, 'uri');

    // register types
    forEach(pkg.types, bind(function (descriptor) {
      this.registerType(descriptor, pkg);
    }, this));

    pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;
    this.packages.push(pkg);
  };

  /**
   * Register a type from a specific package with us
   */
  Registry.prototype.registerType = function (type, pkg) {

    type = assign({}, type, {
      superClass: (type.superClass || []).slice(),
      extends: (type.extends || []).slice(),
      properties: (type.properties || []).slice(),
      meta: assign((type.meta || {}))
    });

    var ns = parseName(type.name, pkg.prefix),
        name = ns.name,
        propertiesByName = {};

    // parse properties
    forEach(type.properties, bind(function (p) {

      // namespace property names
      var propertyNs = parseName(p.name, ns.prefix),
          propertyName = propertyNs.name;

      // namespace property types
      if (!isBuiltIn(p.type)) {
        p.type = parseName(p.type, propertyNs.prefix).name;
      }

      assign(p, {
        ns: propertyNs,
        name: propertyName
      });

      propertiesByName[propertyName] = p;
    }, this));

    // update ns + name
    assign(type, {
      ns: ns,
      name: name,
      propertiesByName: propertiesByName
    });

    forEach(type.extends, bind(function (extendsName) {
      var extended = this.typeMap[extendsName];

      extended.traits = extended.traits || [];
      extended.traits.push(name);
    }, this));

    // link to package
    this.definePackage(type, pkg);

    // register
    this.typeMap[name] = type;
  };

  /**
   * Traverse the type hierarchy from bottom to top,
   * calling iterator with (type, inherited) for all elements in
   * the inheritance chain.
   *
   * @param {Object} nsName
   * @param {Function} iterator
   * @param {Boolean} [trait=false]
   */
  Registry.prototype.mapTypes = function (nsName, iterator, trait) {

    var type = isBuiltIn(nsName.name) ? { name: nsName.name } : this.typeMap[nsName.name];

    var self = this;

    /**
     * Traverse the selected trait.
     *
     * @param {String} cls
     */
    function traverseTrait(cls) {
      return traverseSuper(cls, true);
    }

    /**
     * Traverse the selected super type or trait
     *
     * @param {String} cls
     * @param {Boolean} [trait=false]
     */
    function traverseSuper(cls, trait) {
      var parentNs = parseName(cls, isBuiltIn(cls) ? '' : nsName.prefix);
      self.mapTypes(parentNs, iterator, trait);
    }

    if (!type) {
      throw new Error('unknown type <' + nsName.name + '>');
    }

    forEach(type.superClass, trait ? traverseTrait : traverseSuper);

    // call iterator with (type, inherited=!trait)
    iterator(type, !trait);

    forEach(type.traits, traverseTrait);
  };

  /**
   * Returns the effective descriptor for a type.
   *
   * @param  {String} type the namespaced name (ns:localName) of the type
   *
   * @return {Descriptor} the resulting effective descriptor
   */
  Registry.prototype.getEffectiveDescriptor = function (name) {

    var nsName = parseName(name);

    var builder = new DescriptorBuilder(nsName);

    this.mapTypes(nsName, function (type, inherited) {
      builder.addTrait(type, inherited);
    });

    var descriptor = builder.build();

    // define package link
    this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);

    return descriptor;
  };

  Registry.prototype.definePackage = function (target, pkg) {
    this.properties.define(target, '$pkg', { value: pkg });
  };

  ///////// helpers ////////////////////////////

  function ensureAvailable(packageMap, pkg, identifierKey) {

    var value = pkg[identifierKey];

    if (value in packageMap) {
      throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');
    }
  }

  /**
   * A utility that gets and sets properties of model elements.
   *
   * @param {Model} model
   */
  function Properties(model) {
    this.model = model;
  }

  /**
   * Sets a named property on the target element.
   * If the value is undefined, the property gets deleted.
   *
   * @param {Object} target
   * @param {String} name
   * @param {Object} value
   */
  Properties.prototype.set = function (target, name, value) {

    var property = this.model.getPropertyDescriptor(target, name);

    var propertyName = property && property.name;

    if (isUndefined$1(value)) {
      // unset the property, if the specified value is undefined;
      // delete from $attrs (for extensions) or the target itself
      if (property) {
        delete target[propertyName];
      } else {
        delete target.$attrs[name];
      }
    } else {
      // set the property, defining well defined properties on the fly
      // or simply updating them in target.$attrs (for extensions)
      if (property) {
        if (propertyName in target) {
          target[propertyName] = value;
        } else {
          defineProperty(target, property, value);
        }
      } else {
        target.$attrs[name] = value;
      }
    }
  };

  /**
   * Returns the named property of the given element
   *
   * @param  {Object} target
   * @param  {String} name
   *
   * @return {Object}
   */
  Properties.prototype.get = function (target, name) {

    var property = this.model.getPropertyDescriptor(target, name);

    if (!property) {
      return target.$attrs[name];
    }

    var propertyName = property.name;

    // check if access to collection property and lazily initialize it
    if (!target[propertyName] && property.isMany) {
      defineProperty(target, property, []);
    }

    return target[propertyName];
  };

  /**
   * Define a property on the target element
   *
   * @param  {Object} target
   * @param  {String} name
   * @param  {Object} options
   */
  Properties.prototype.define = function (target, name, options) {
    Object.defineProperty(target, name, options);
  };

  /**
   * Define the descriptor for an element
   */
  Properties.prototype.defineDescriptor = function (target, descriptor) {
    this.define(target, '$descriptor', { value: descriptor });
  };

  /**
   * Define the model for an element
   */
  Properties.prototype.defineModel = function (target, model) {
    this.define(target, '$model', { value: model });
  };

  function isUndefined$1(val) {
    return typeof val === 'undefined';
  }

  function defineProperty(target, property, value) {
    Object.defineProperty(target, property.name, {
      enumerable: !property.isReference,
      writable: true,
      value: value,
      configurable: true
    });
  }

  //// Moddle implementation /////////////////////////////////////////////////

  /**
   * @class Moddle
   *
   * A model that can be used to create elements of a specific type.
   *
   * @example
   *
   * var Moddle = require('moddle');
   *
   * var pkg = {
   *   name: 'mypackage',
   *   prefix: 'my',
   *   types: [
   *     { name: 'Root' }
   *   ]
   * };
   *
   * var moddle = new Moddle([pkg]);
   *
   * @param {Array<Package>} packages the packages to contain
   */
  function Moddle(packages) {

    this.properties = new Properties(this);

    this.factory = new Factory(this, this.properties);
    this.registry = new Registry(packages, this.properties);

    this.typeCache = {};
  }

  /**
   * Create an instance of the specified type.
   *
   * @method Moddle#create
   *
   * @example
   *
   * var foo = moddle.create('my:Foo');
   * var bar = moddle.create('my:Bar', { id: 'BAR_1' });
   *
   * @param  {String|Object} descriptor the type descriptor or name know to the model
   * @param  {Object} attrs   a number of attributes to initialize the model instance with
   * @return {Object}         model instance
   */
  Moddle.prototype.create = function (descriptor, attrs) {
    var Type = this.getType(descriptor);

    if (!Type) {
      throw new Error('unknown type <' + descriptor + '>');
    }

    return new Type(attrs);
  };

  /**
   * Returns the type representing a given descriptor
   *
   * @method Moddle#getType
   *
   * @example
   *
   * var Foo = moddle.getType('my:Foo');
   * var foo = new Foo({ 'id' : 'FOO_1' });
   *
   * @param  {String|Object} descriptor the type descriptor or name know to the model
   * @return {Object}         the type representing the descriptor
   */
  Moddle.prototype.getType = function (descriptor) {

    var cache = this.typeCache;

    var name = isString(descriptor) ? descriptor : descriptor.ns.name;

    var type = cache[name];

    if (!type) {
      descriptor = this.registry.getEffectiveDescriptor(name);
      type = cache[name] = this.factory.createType(descriptor);
    }

    return type;
  };

  /**
   * Creates an any-element type to be used within model instances.
   *
   * This can be used to create custom elements that lie outside the meta-model.
   * The created element contains all the meta-data required to serialize it
   * as part of meta-model elements.
   *
   * @method Moddle#createAny
   *
   * @example
   *
   * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {
   *   value: 'bar'
   * });
   *
   * var container = moddle.create('my:Container', 'http://my', {
   *   any: [ foo ]
   * });
   *
   * // go ahead and serialize the stuff
   *
   *
   * @param  {String} name  the name of the element
   * @param  {String} nsUri the namespace uri of the element
   * @param  {Object} [properties] a map of properties to initialize the instance with
   * @return {Object} the any type instance
   */
  Moddle.prototype.createAny = function (name, nsUri, properties) {

    var nameNs = parseName(name);

    var element = {
      $type: name,
      $instanceOf: function $instanceOf(type) {
        return type === this.$type;
      }
    };

    var descriptor = {
      name: name,
      isGeneric: true,
      ns: {
        prefix: nameNs.prefix,
        localName: nameNs.localName,
        uri: nsUri
      }
    };

    this.properties.defineDescriptor(element, descriptor);
    this.properties.defineModel(element, this);
    this.properties.define(element, '$parent', { enumerable: false, writable: true });

    forEach(properties, function (a, key) {
      if (isObject(a) && a.value !== undefined) {
        element[a.name] = a.value;
      } else {
        element[key] = a;
      }
    });

    return element;
  };

  /**
   * Returns a registered package by uri or prefix
   *
   * @return {Object} the package
   */
  Moddle.prototype.getPackage = function (uriOrPrefix) {
    return this.registry.getPackage(uriOrPrefix);
  };

  /**
   * Returns a snapshot of all known packages
   *
   * @return {Object} the package
   */
  Moddle.prototype.getPackages = function () {
    return this.registry.getPackages();
  };

  /**
   * Returns the descriptor for an element
   */
  Moddle.prototype.getElementDescriptor = function (element) {
    return element.$descriptor;
  };

  /**
   * Returns true if the given descriptor or instance
   * represents the given type.
   *
   * May be applied to this, if element is omitted.
   */
  Moddle.prototype.hasType = function (element, type) {
    if (type === undefined) {
      type = element;
      element = this;
    }

    var descriptor = element.$model.getElementDescriptor(element);

    return type in descriptor.allTypesByName;
  };

  /**
   * Returns the descriptor of an elements named property
   */
  Moddle.prototype.getPropertyDescriptor = function (element, property) {
    return this.getElementDescriptor(element).propertiesByName[property];
  };

  /**
   * Returns a mapped type's descriptor
   */
  Moddle.prototype.getTypeDescriptor = function (type) {
    return this.registry.typeMap[type];
  };

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var tinyStack = createCommonjsModule(function (module, exports) {

  var _createClass = function () {
  	function defineProperties(target, props) {
  		for (var i = 0; i < props.length; i++) {
  			var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
  		}
  	}return function (Constructor, protoProps, staticProps) {
  		if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  	};
  }();

  function _classCallCheck(instance, Constructor) {
  	if (!(instance instanceof Constructor)) {
  		throw new TypeError("Cannot call a class as a function");
  	}
  }

  /**
   * Tiny stack for browser or server
   *
   * @author Jason Mulligan <jason.mulligan@avoidwork.com>
   * @copyright 2018
   * @license BSD-3-Clause
   * @link http://avoidwork.github.io/tiny-stack
   * @version 1.1.0
   */
  (function (global) {

  	var TinyStack = function () {
  		function TinyStack() {
  			_classCallCheck(this, TinyStack);

  			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
  				args[_key] = arguments[_key];
  			}

  			this.data = [null].concat(args);
  			this.top = this.data.length - 1;
  		}

  		_createClass(TinyStack, [{
  			key: "clear",
  			value: function clear() {
  				this.data.length = 1;
  				this.top = 0;

  				return this;
  			}
  		}, {
  			key: "empty",
  			value: function empty() {
  				return this.top === 0;
  			}
  		}, {
  			key: "length",
  			value: function length() {
  				return this.top;
  			}
  		}, {
  			key: "peek",
  			value: function peek() {
  				return this.data[this.top];
  			}
  		}, {
  			key: "pop",
  			value: function pop() {
  				var result = void 0;

  				if (this.top > 0) {
  					result = this.data.pop();
  					this.top--;
  				}

  				return result;
  			}
  		}, {
  			key: "push",
  			value: function push(arg) {
  				this.data[++this.top] = arg;

  				return this;
  			}
  		}, {
  			key: "search",
  			value: function search(arg) {
  				var index = this.data.indexOf(arg);

  				return index === -1 ? -1 : this.data.length - index;
  			}
  		}]);

  		return TinyStack;
  	}();

  	function factory() {
  		for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
  			args[_key2] = arguments[_key2];
  		}

  		return new (Function.prototype.bind.apply(TinyStack, [null].concat(args)))();
  	}

  	// Node, AMD & window supported
  	{
  		module.exports = factory;
  	}
  })(typeof window !== "undefined" ? window : commonjsGlobal);
  });

  var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var fromCharCode = String.fromCharCode;

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  var ENTITY_PATTERN = /&#(\d+);|&#x([0-9a-f]+);|&(\w+);/ig;

  var ENTITY_MAPPING = {
    'amp': '&',
    'apos': '\'',
    'gt': '>',
    'lt': '<',
    'quot': '"'
  };

  // map UPPERCASE variants of supported special chars
  Object.keys(ENTITY_MAPPING).forEach(function (k) {
    ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];
  });

  function replaceEntities(_, d, x, z) {

    // reserved names, i.e. &nbsp;
    if (z) {
      if (hasOwnProperty.call(ENTITY_MAPPING, z)) {
        return ENTITY_MAPPING[z];
      } else {
        // fall back to original value
        return '&' + z + ';';
      }
    }

    // decimal encoded char
    if (d) {
      return fromCharCode(d);
    }

    // hex encoded char
    return fromCharCode(parseInt(x, 16));
  }

  /**
   * A basic entity decoder that can decode a minimal
   * sub-set of reserved names (&amp;) as well as
   * hex (&#xaaf;) and decimal (&#1231;) encoded characters.
   *
   * @param {string} str
   *
   * @return {string} decoded string
   */
  function decodeEntities(s) {
    if (s.length > 3 && s.indexOf('&') !== -1) {
      return s.replace(ENTITY_PATTERN, replaceEntities);
    }

    return s;
  }

  var XSI_URI = 'http://www.w3.org/2001/XMLSchema-instance';
  var XSI_PREFIX = 'xsi';
  var XSI_TYPE = 'xsi:type';

  function error(msg) {
    return new Error(msg);
  }

  function missingNamespaceForPrefix(prefix) {
    return 'missing namespace for prefix <' + prefix + '>';
  }

  function getter(getFn) {
    return {
      'get': getFn,
      'enumerable': true
    };
  }

  function cloneNsMatrix(nsMatrix) {
    var clone = {},
        key;
    for (key in nsMatrix) {
      clone[key] = nsMatrix[key];
    }
    return clone;
  }

  function uriPrefix(prefix) {
    return prefix + '$uri';
  }

  function buildNsMatrix(nsUriToPrefix) {
    var nsMatrix = {},
        uri,
        prefix;

    for (uri in nsUriToPrefix) {
      prefix = nsUriToPrefix[uri];
      nsMatrix[prefix] = prefix;
      nsMatrix[uriPrefix(prefix)] = uri;
    }

    return nsMatrix;
  }

  function noopGetContext() {
    return { 'line': 0, 'column': 0 };
  }

  function throwFunc(err) {
    throw err;
  }

  /**
   * Creates a new parser with the given options.
   *
   * @constructor
   *
   * @param  {!Object<string, ?>=} options
   */
  function Parser(options) {

    if (!this) {
      return new Parser(options);
    }

    var proxy = options && options['proxy'];

    var onText,
        onOpenTag,
        onCloseTag,
        onCDATA,
        onError = throwFunc,
        onWarning,
        onComment,
        onQuestion,
        onAttention;

    var getContext = noopGetContext;

    /**
     * Do we need to parse the current elements attributes for namespaces?
     *
     * @type {boolean}
     */
    var maybeNS = false;

    /**
     * Do we process namespaces at all?
     *
     * @type {boolean}
     */
    var isNamespace = false;

    /**
     * The caught error returned on parse end
     *
     * @type {Error}
     */
    var returnError = null;

    /**
     * Should we stop parsing?
     *
     * @type {boolean}
     */
    var parseStop = false;

    /**
     * A map of { uri: prefix } used by the parser.
     *
     * This map will ensure we can normalize prefixes during processing;
     * for each uri, only one prefix will be exposed to the handlers.
     *
     * @type {!Object<string, string>}}
     */
    var nsUriToPrefix;

    /**
     * Handle parse error.
     *
     * @param  {string|Error} err
     */
    function handleError(err) {
      if (!(err instanceof Error)) {
        err = error(err);
      }

      returnError = err;

      onError(err, getContext);
    }

    /**
     * Handle parse error.
     *
     * @param  {string|Error} err
     */
    function handleWarning(err) {

      if (!onWarning) {
        return;
      }

      if (!(err instanceof Error)) {
        err = error(err);
      }

      onWarning(err, getContext);
    }

    /**
     * Register parse listener.
     *
     * @param  {string}   name
     * @param  {Function} cb
     *
     * @return {Parser}
     */
    this['on'] = function (name, cb) {

      if (typeof cb !== 'function') {
        throw error('required args <name, cb>');
      }

      switch (name) {
        case 'openTag':
          onOpenTag = cb;break;
        case 'text':
          onText = cb;break;
        case 'closeTag':
          onCloseTag = cb;break;
        case 'error':
          onError = cb;break;
        case 'warn':
          onWarning = cb;break;
        case 'cdata':
          onCDATA = cb;break;
        case 'attention':
          onAttention = cb;break; // <!XXXXX zzzz="eeee">
        case 'question':
          onQuestion = cb;break; // <? ....  ?>
        case 'comment':
          onComment = cb;break;
        default:
          throw error('unsupported event: ' + name);
      }

      return this;
    };

    /**
     * Set the namespace to prefix mapping.
     *
     * @example
     *
     * parser.ns({
     *   'http://foo': 'foo',
     *   'http://bar': 'bar'
     * });
     *
     * @param  {!Object<string, string>} nsMap
     *
     * @return {Parser}
     */
    this['ns'] = function (nsMap) {

      if (typeof nsMap === 'undefined') {
        nsMap = {};
      }

      if ((typeof nsMap === 'undefined' ? 'undefined' : _typeof$1(nsMap)) !== 'object') {
        throw error('required args <nsMap={}>');
      }

      var _nsUriToPrefix = {},
          k;

      for (k in nsMap) {
        _nsUriToPrefix[k] = nsMap[k];
      }

      // FORCE default mapping for schema instance
      _nsUriToPrefix[XSI_URI] = XSI_PREFIX;

      isNamespace = true;
      nsUriToPrefix = _nsUriToPrefix;

      return this;
    };

    /**
     * Parse xml string.
     *
     * @param  {string} xml
     *
     * @return {Error} returnError, if not thrown
     */
    this['parse'] = function (xml) {
      if (typeof xml !== 'string') {
        throw error('required args <xml=string>');
      }

      returnError = null;

      parse(xml);

      getContext = noopGetContext;
      parseStop = false;

      return returnError;
    };

    /**
     * Stop parsing.
     */
    this['stop'] = function () {
      parseStop = true;
    };

    /**
     * Parse string, invoking configured listeners on element.
     *
     * @param  {string} xml
     */
    function parse(xml) {
      var nsMatrixStack = isNamespace ? [] : null,
          nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,
          _nsMatrix,
          nodeStack = [],
          anonymousNsCount = 0,
          tagStart = false,
          tagEnd = false,
          i = 0,
          j = 0,
          x,
          y,
          q,
          w,
          xmlns,
          elementName,
          _elementName,
          elementProxy;

      var attrsString = '',
          attrsStart = 0,
          cachedAttrs // false = parsed with errors, null = needs parsing
      ;

      /**
       * Parse attributes on demand and returns the parsed attributes.
       *
       * Return semantics: (1) `false` on attribute parse error,
       * (2) object hash on extracted attrs.
       *
       * @return {boolean|Object}
       */
      function getAttrs() {
        if (cachedAttrs !== null) {
          return cachedAttrs;
        }

        var nsUri,
            nsUriPrefix,
            nsName,
            defaultAlias = isNamespace && nsMatrix['xmlns'],
            attrList = isNamespace && maybeNS ? [] : null,
            i = attrsStart,
            s = attrsString,
            l = s.length,
            hasNewMatrix,
            newalias,
            value,
            alias,
            name,
            attrs = {},
            seenAttrs = {},
            skipAttr,
            w,
            j;

        parseAttr: for (; i < l; i++) {
          skipAttr = false;
          w = s.charCodeAt(i);

          if (w === 32 || w < 14 && w > 8) {
            // WHITESPACE={ \f\n\r\t\v}
            continue;
          }

          // wait for non whitespace character
          if (w < 65 || w > 122 || w > 90 && w < 97) {
            if (w !== 95 && w !== 58) {
              // char 95"_" 58":"
              handleWarning('illegal first char attribute name');
              skipAttr = true;
            }
          }

          // parse attribute name
          for (j = i + 1; j < l; j++) {
            w = s.charCodeAt(j);

            if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 46 || // '.'
            w === 45 || // '-'
            w === 95 // '_'
            ) {
                continue;
              }

            // unexpected whitespace
            if (w === 32 || w < 14 && w > 8) {
              // WHITESPACE
              handleWarning('missing attribute value');
              i = j;

              continue parseAttr;
            }

            // expected "="
            if (w === 61) {
              // "=" == 61
              break;
            }

            handleWarning('illegal attribute name char');
            skipAttr = true;
          }

          name = s.substring(i, j);

          if (name === 'xmlns:xmlns') {
            handleWarning('illegal declaration of xmlns');
            skipAttr = true;
          }

          w = s.charCodeAt(j + 1);

          if (w === 34) {
            // '"'
            j = s.indexOf('"', i = j + 2);

            if (j === -1) {
              j = s.indexOf('\'', i);

              if (j !== -1) {
                handleWarning('attribute value quote missmatch');
                skipAttr = true;
              }
            }
          } else if (w === 39) {
            // "'"
            j = s.indexOf('\'', i = j + 2);

            if (j === -1) {
              j = s.indexOf('"', i);

              if (j !== -1) {
                handleWarning('attribute value quote missmatch');
                skipAttr = true;
              }
            }
          } else {
            handleWarning('missing attribute value quotes');
            skipAttr = true;

            // skip to next space
            for (j = j + 1; j < l; j++) {
              w = s.charCodeAt(j + 1);

              if (w === 32 || w < 14 && w > 8) {
                // WHITESPACE
                break;
              }
            }
          }

          if (j === -1) {
            handleWarning('missing closing quotes');

            j = l;
            skipAttr = true;
          }

          if (!skipAttr) {
            value = s.substring(i, j);
          }

          i = j;

          // ensure SPACE follows attribute
          // skip illegal content otherwise
          // example a="b"c
          for (; j + 1 < l; j++) {
            w = s.charCodeAt(j + 1);

            if (w === 32 || w < 14 && w > 8) {
              // WHITESPACE
              break;
            }

            // FIRST ILLEGAL CHAR
            if (i === j) {
              handleWarning('illegal character after attribute end');
              skipAttr = true;
            }
          }

          // advance cursor to next attribute
          i = j + 1;

          if (skipAttr) {
            continue parseAttr;
          }

          // check attribute re-declaration
          if (name in seenAttrs) {
            handleWarning('attribute <' + name + '> already defined');
            continue;
          }

          seenAttrs[name] = true;

          if (!isNamespace) {
            attrs[name] = value;
            continue;
          }

          // try to extract namespace information
          if (maybeNS) {
            newalias = name === 'xmlns' ? 'xmlns' : name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:' ? name.substr(6) : null;

            // handle xmlns(:alias) assignment
            if (newalias !== null) {
              nsUri = decodeEntities(value);
              nsUriPrefix = uriPrefix(newalias);

              alias = nsUriToPrefix[nsUri];

              if (!alias) {
                // no prefix defined or prefix collision
                if (newalias === 'xmlns' || nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri) {
                  // alocate free ns prefix
                  do {
                    alias = 'ns' + anonymousNsCount++;
                  } while (typeof nsMatrix[alias] !== 'undefined');
                } else {
                  alias = newalias;
                }

                nsUriToPrefix[nsUri] = alias;
              }

              if (nsMatrix[newalias] !== alias) {
                if (!hasNewMatrix) {
                  nsMatrix = cloneNsMatrix(nsMatrix);
                  hasNewMatrix = true;
                }

                nsMatrix[newalias] = alias;
                if (newalias === 'xmlns') {
                  nsMatrix[uriPrefix(alias)] = nsUri;
                  defaultAlias = alias;
                }

                nsMatrix[nsUriPrefix] = nsUri;
              }

              // expose xmlns(:asd)="..." in attributes
              attrs[name] = value;
              continue;
            }

            // collect attributes until all namespace
            // declarations are processed
            attrList.push(name, value);
            continue;
          } /** end if (maybeNs) */

          // handle attributes on element without
          // namespace declarations
          w = name.indexOf(':');
          if (w === -1) {
            attrs[name] = value;
            continue;
          }

          // normalize ns attribute name
          if (!(nsName = nsMatrix[name.substring(0, w)])) {
            handleWarning(missingNamespaceForPrefix(name.substring(0, w)));
            continue;
          }

          name = defaultAlias === nsName ? name.substr(w + 1) : nsName + name.substr(w);
          // end: normalize ns attribute name

          // normalize xsi:type ns attribute value
          if (name === XSI_TYPE) {
            w = value.indexOf(':');

            if (w !== -1) {
              nsName = value.substring(0, w);
              // handle default prefixes, i.e. xs:String gracefully
              nsName = nsMatrix[nsName] || nsName;
              value = nsName + value.substring(w);
            } else {
              value = defaultAlias + ':' + value;
            }
          }
          // end: normalize xsi:type ns attribute value

          attrs[name] = value;
        }

        // handle deferred, possibly namespaced attributes
        if (maybeNS) {

          // normalize captured attributes
          for (i = 0, l = attrList.length; i < l; i++) {

            name = attrList[i++];
            value = attrList[i];

            w = name.indexOf(':');

            if (w !== -1) {
              // normalize ns attribute name
              if (!(nsName = nsMatrix[name.substring(0, w)])) {
                handleWarning(missingNamespaceForPrefix(name.substring(0, w)));
                continue;
              }

              name = defaultAlias === nsName ? name.substr(w + 1) : nsName + name.substr(w);
              // end: normalize ns attribute name

              // normalize xsi:type ns attribute value
              if (name === XSI_TYPE) {
                w = value.indexOf(':');

                if (w !== -1) {
                  nsName = value.substring(0, w);
                  // handle default prefixes, i.e. xs:String gracefully
                  nsName = nsMatrix[nsName] || nsName;
                  value = nsName + value.substring(w);
                } else {
                  value = defaultAlias + ':' + value;
                }
              }
              // end: normalize xsi:type ns attribute value
            }

            attrs[name] = value;
          }
          // end: normalize captured attributes
        }

        return cachedAttrs = attrs;
      }

      /**
       * Extract the parse context { line, column, part }
       * from the current parser position.
       *
       * @return {Object} parse context
       */
      function getParseContext() {
        var splitsRe = /(\r\n|\r|\n)/g;

        var line = 0;
        var column = 0;
        var startOfLine = 0;
        var endOfLine = j;
        var match;
        var data;

        while (i >= startOfLine) {

          match = splitsRe.exec(xml);

          if (!match) {
            break;
          }

          // end of line = (break idx + break chars)
          endOfLine = match[0].length + match.index;

          if (endOfLine > i) {
            break;
          }

          // advance to next line
          line += 1;

          startOfLine = endOfLine;
        }

        // EOF errors
        if (i == -1) {
          column = endOfLine;
          data = '';
        } else {
          column = i - startOfLine;
          data = j == -1 ? xml.substring(i) : xml.substring(i, j + 1);
        }

        return {
          'data': data,
          'line': line,
          'column': column
        };
      }

      getContext = getParseContext;

      if (proxy) {
        elementProxy = Object.create({}, {
          'name': getter(function () {
            return elementName;
          }),
          'originalName': getter(function () {
            return _elementName;
          }),
          'attrs': getter(getAttrs),
          'ns': getter(function () {
            return nsMatrix;
          })
        });
      }

      // actual parse logic
      while (j !== -1) {

        if (xml.charCodeAt(j) === 60) {
          // "<"
          i = j;
        } else {
          i = xml.indexOf('<', j);
        }

        // parse end
        if (i === -1) {
          if (nodeStack.length) {
            return handleError('unexpected end of file');
          }

          if (j === 0) {
            return handleError('missing start tag');
          }

          return;
        }

        if (j !== i) {
          if (onText) {
            onText(xml.substring(j, i), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }
        }

        w = xml.charCodeAt(i + 1);

        // parse comments + CDATA
        if (w === 33) {
          // "!"
          w = xml.charCodeAt(i + 2);
          if (w === 91 && xml.substr(i + 3, 6) === 'CDATA[') {
            // 91 == "["
            j = xml.indexOf(']]>', i);
            if (j === -1) {
              return handleError('unclosed cdata');
            }

            if (onCDATA) {
              onCDATA(xml.substring(i + 9, j), getContext);
              if (parseStop) {
                return;
              }
            }

            j += 3;
            continue;
          }

          if (w === 45 && xml.charCodeAt(i + 3) === 45) {
            // 45 == "-"
            j = xml.indexOf('-->', i);
            if (j === -1) {
              return handleError('unclosed comment');
            }

            if (onComment) {
              onComment(xml.substring(i + 4, j), decodeEntities, getContext);
              if (parseStop) {
                return;
              }
            }

            j += 3;
            continue;
          }

          j = xml.indexOf('>', i + 1);
          if (j === -1) {
            return handleError('unclosed tag');
          }

          if (onAttention) {
            onAttention(xml.substring(i, j + 1), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }

          j += 1;
          continue;
        }

        if (w === 63) {
          // "?"
          j = xml.indexOf('?>', i);
          if (j === -1) {
            return handleError('unclosed question');
          }

          if (onQuestion) {
            onQuestion(xml.substring(i, j + 2), getContext);
            if (parseStop) {
              return;
            }
          }

          j += 2;
          continue;
        }

        j = xml.indexOf('>', i + 1);

        if (j == -1) {
          return handleError('unclosed tag');
        }

        // don't process attributes;
        // there are none
        cachedAttrs = {};

        // if (xml.charCodeAt(i+1) === 47) { // </...
        if (w === 47) {
          // </...
          tagStart = false;
          tagEnd = true;

          if (!nodeStack.length) {
            return handleError('missing open tag');
          }

          // verify open <-> close tag match
          x = elementName = nodeStack.pop();
          q = i + 2 + x.length;

          if (xml.substring(i + 2, q) !== x) {
            return handleError('closing tag mismatch');
          }

          // verify chars in close tag
          for (; q < j; q++) {
            w = xml.charCodeAt(q);

            if (w === 32 || w > 8 && w < 14) {
              // \f\n\r\t\v space
              continue;
            }

            return handleError('close tag');
          }
        } else {
          if (xml.charCodeAt(j - 1) === 47) {
            // .../>
            x = elementName = xml.substring(i + 1, j - 1);

            tagStart = true;
            tagEnd = true;
          } else {
            x = elementName = xml.substring(i + 1, j);

            tagStart = true;
            tagEnd = false;
          }

          if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) {
            // char 95"_" 58":"
            return handleError('illegal first char nodeName');
          }

          for (q = 1, y = x.length; q < y; q++) {
            w = x.charCodeAt(q);

            if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95) {
              continue;
            }

            if (w === 32 || w < 14 && w > 8) {
              // \f\n\r\t\v space
              elementName = x.substring(0, q);
              // maybe there are attributes
              cachedAttrs = null;
              break;
            }

            return handleError('invalid nodeName');
          }

          if (!tagEnd) {
            nodeStack.push(elementName);
          }
        }

        if (isNamespace) {

          _nsMatrix = nsMatrix;

          if (tagStart) {
            // remember old namespace
            // unless we're self-closing
            if (!tagEnd) {
              nsMatrixStack.push(_nsMatrix);
            }

            if (cachedAttrs === null) {
              // quick check, whether there may be namespace
              // declarations on the node; if that is the case
              // we need to eagerly parse the node attributes
              if (maybeNS = x.indexOf('xmlns', q) !== -1) {
                attrsStart = q;
                attrsString = x;

                getAttrs();

                maybeNS = false;
              }
            }
          }

          _elementName = elementName;

          w = elementName.indexOf(':');
          if (w !== -1) {
            xmlns = nsMatrix[elementName.substring(0, w)];

            // prefix given; namespace must exist
            if (!xmlns) {
              return handleError('missing namespace on <' + _elementName + '>');
            }

            elementName = elementName.substr(w + 1);
          } else {
            xmlns = nsMatrix['xmlns'];

            // if no default namespace is defined,
            // we'll import the element as anonymous.
            //
            // it is up to users to correct that to the document defined
            // targetNamespace, or whatever their undersanding of the
            // XML spec mandates.
          }

          // adjust namespace prefixs as configured
          if (xmlns) {
            elementName = xmlns + ':' + elementName;
          }
        }

        if (tagStart) {
          attrsStart = q;
          attrsString = x;

          if (onOpenTag) {
            if (proxy) {
              onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);
            } else {
              onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);
            }

            if (parseStop) {
              return;
            }
          }
        }

        if (tagEnd) {

          if (onCloseTag) {
            onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);

            if (parseStop) {
              return;
            }
          }

          // restore old namespace
          if (isNamespace) {
            if (!tagStart) {
              nsMatrix = nsMatrixStack.pop();
            } else {
              nsMatrix = _nsMatrix;
            }
          }
        }

        j += 1;
      }
    } /** end parse */
  }

  function hasLowerCaseAlias(pkg) {
    return pkg.xml && pkg.xml.tagAlias === 'lowerCase';
  }

  var DEFAULT_NS_MAP = {
    'xsi': 'http://www.w3.org/2001/XMLSchema-instance'
  };

  var XSI_TYPE$1 = 'xsi:type';

  function serializeFormat(element) {
    return element.xml && element.xml.serialize;
  }

  function serializeAsType(element) {
    return serializeFormat(element) === XSI_TYPE$1;
  }

  function serializeAsProperty(element) {
    return serializeFormat(element) === 'property';
  }

  function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  function aliasToName(aliasNs, pkg) {

    if (!hasLowerCaseAlias(pkg)) {
      return aliasNs.name;
    }

    return aliasNs.prefix + ':' + capitalize(aliasNs.localName);
  }

  function prefixedToName(nameNs, pkg) {

    var name = nameNs.name,
        localName = nameNs.localName;

    var typePrefix = pkg.xml && pkg.xml.typePrefix;

    if (typePrefix && localName.indexOf(typePrefix) === 0) {
      return nameNs.prefix + ':' + localName.slice(typePrefix.length);
    } else {
      return name;
    }
  }

  function normalizeXsiTypeName(name, model) {

    var nameNs = parseName(name);
    var pkg = model.getPackage(nameNs.prefix);

    return prefixedToName(nameNs, pkg);
  }

  function error$1(message) {
    return new Error(message);
  }

  /**
   * Get the moddle descriptor for a given instance or type.
   *
   * @param  {ModdleElement|Function} element
   *
   * @return {Object} the moddle descriptor
   */
  function getModdleDescriptor(element) {
    return element.$descriptor;
  }

  function defer(fn) {
    setTimeout(fn, 0);
  }

  /**
   * A parse context.
   *
   * @class
   *
   * @param {Object} options
   * @param {ElementHandler} options.rootHandler the root handler for parsing a document
   * @param {boolean} [options.lax=false] whether or not to ignore invalid elements
   */
  function Context(options) {

    /**
     * @property {ElementHandler} rootHandler
     */

    /**
     * @property {Boolean} lax
     */

    assign(this, options);

    this.elementsById = {};
    this.references = [];
    this.warnings = [];

    /**
     * Add an unresolved reference.
     *
     * @param {Object} reference
     */
    this.addReference = function (reference) {
      this.references.push(reference);
    };

    /**
     * Add a processed element.
     *
     * @param {ModdleElement} element
     */
    this.addElement = function (element) {

      if (!element) {
        throw error$1('expected element');
      }

      var elementsById = this.elementsById;

      var descriptor = getModdleDescriptor(element);

      var idProperty = descriptor.idProperty,
          id;

      if (idProperty) {
        id = element.get(idProperty.name);

        if (id) {

          if (elementsById[id]) {
            throw error$1('duplicate ID <' + id + '>');
          }

          elementsById[id] = element;
        }
      }
    };

    /**
     * Add an import warning.
     *
     * @param {Object} warning
     * @param {String} warning.message
     * @param {Error} [warning.error]
     */
    this.addWarning = function (warning) {
      this.warnings.push(warning);
    };
  }

  function BaseHandler() {}

  BaseHandler.prototype.handleEnd = function () {};
  BaseHandler.prototype.handleText = function () {};
  BaseHandler.prototype.handleNode = function () {};

  /**
   * A simple pass through handler that does nothing except for
   * ignoring all input it receives.
   *
   * This is used to ignore unknown elements and
   * attributes.
   */
  function NoopHandler() {}

  NoopHandler.prototype = Object.create(BaseHandler.prototype);

  NoopHandler.prototype.handleNode = function () {
    return this;
  };

  function BodyHandler() {}

  BodyHandler.prototype = Object.create(BaseHandler.prototype);

  BodyHandler.prototype.handleText = function (text) {
    this.body = (this.body || '') + text;
  };

  function ReferenceHandler(property, context) {
    this.property = property;
    this.context = context;
  }

  ReferenceHandler.prototype = Object.create(BodyHandler.prototype);

  ReferenceHandler.prototype.handleNode = function (node) {

    if (this.element) {
      throw error$1('expected no sub nodes');
    } else {
      this.element = this.createReference(node);
    }

    return this;
  };

  ReferenceHandler.prototype.handleEnd = function () {
    this.element.id = this.body;
  };

  ReferenceHandler.prototype.createReference = function (node) {
    return {
      property: this.property.ns.name,
      id: ''
    };
  };

  function ValueHandler(propertyDesc, element) {
    this.element = element;
    this.propertyDesc = propertyDesc;
  }

  ValueHandler.prototype = Object.create(BodyHandler.prototype);

  ValueHandler.prototype.handleEnd = function () {

    var value = this.body || '',
        element = this.element,
        propertyDesc = this.propertyDesc;

    value = coerceType(propertyDesc.type, value);

    if (propertyDesc.isMany) {
      element.get(propertyDesc.name).push(value);
    } else {
      element.set(propertyDesc.name, value);
    }
  };

  function BaseElementHandler() {}

  BaseElementHandler.prototype = Object.create(BodyHandler.prototype);

  BaseElementHandler.prototype.handleNode = function (node) {
    var parser = this,
        element = this.element;

    if (!element) {
      element = this.element = this.createElement(node);

      this.context.addElement(element);
    } else {
      parser = this.handleChild(node);
    }

    return parser;
  };

  /**
   * @class Reader.ElementHandler
   *
   */
  function ElementHandler(model, typeName, context) {
    this.model = model;
    this.type = model.getType(typeName);
    this.context = context;
  }

  ElementHandler.prototype = Object.create(BaseElementHandler.prototype);

  ElementHandler.prototype.addReference = function (reference) {
    this.context.addReference(reference);
  };

  ElementHandler.prototype.handleEnd = function () {

    var value = this.body,
        element = this.element,
        descriptor = getModdleDescriptor(element),
        bodyProperty = descriptor.bodyProperty;

    if (bodyProperty && value !== undefined) {
      value = coerceType(bodyProperty.type, value);
      element.set(bodyProperty.name, value);
    }
  };

  /**
   * Create an instance of the model from the given node.
   *
   * @param  {Element} node the xml node
   */
  ElementHandler.prototype.createElement = function (node) {
    var attributes = node.attributes,
        Type = this.type,
        descriptor = getModdleDescriptor(Type),
        context = this.context,
        instance = new Type({}),
        model = this.model,
        propNameNs;

    forEach(attributes, function (value, name) {

      var prop = descriptor.propertiesByName[name],
          values$$1;

      if (prop && prop.isReference) {

        if (!prop.isMany) {
          context.addReference({
            element: instance,
            property: prop.ns.name,
            id: value
          });
        } else {
          // IDREFS: parse references as whitespace-separated list
          values$$1 = value.split(' ');

          forEach(values$$1, function (v) {
            context.addReference({
              element: instance,
              property: prop.ns.name,
              id: v
            });
          });
        }
      } else {
        if (prop) {
          value = coerceType(prop.type, value);
        } else if (name !== 'xmlns') {
          propNameNs = parseName(name, descriptor.ns.prefix);

          // check whether attribute is defined in a well-known namespace
          // if that is the case we emit a warning to indicate potential misuse
          if (model.getPackage(propNameNs.prefix)) {

            context.addWarning({
              message: 'unknown attribute <' + name + '>',
              element: instance,
              property: name,
              value: value
            });
          }
        }

        instance.set(name, value);
      }
    });

    return instance;
  };

  ElementHandler.prototype.getPropertyForNode = function (node) {

    var name = node.name;
    var nameNs = parseName(name);

    var type = this.type,
        model = this.model,
        descriptor = getModdleDescriptor(type);

    var propertyName = nameNs.name,
        property = descriptor.propertiesByName[propertyName],
        elementTypeName,
        elementType;

    // search for properties by name first

    if (property) {

      if (serializeAsType(property)) {
        elementTypeName = node.attributes[XSI_TYPE$1];

        // xsi type is optional, if it does not exists the
        // default type is assumed
        if (elementTypeName) {

          // take possible type prefixes from XML
          // into account, i.e.: xsi:type="t{ActualType}"
          elementTypeName = normalizeXsiTypeName(elementTypeName, model);

          elementType = model.getType(elementTypeName);

          return assign({}, property, {
            effectiveType: getModdleDescriptor(elementType).name
          });
        }
      }

      // search for properties by name first
      return property;
    }

    var pkg = model.getPackage(nameNs.prefix);

    if (pkg) {
      elementTypeName = aliasToName(nameNs, pkg);
      elementType = model.getType(elementTypeName);

      // search for collection members later
      property = find(descriptor.properties, function (p) {
        return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);
      });

      if (property) {
        return assign({}, property, {
          effectiveType: getModdleDescriptor(elementType).name
        });
      }
    } else {
      // parse unknown element (maybe extension)
      property = find(descriptor.properties, function (p) {
        return !p.isReference && !p.isAttribute && p.type === 'Element';
      });

      if (property) {
        return property;
      }
    }

    throw error$1('unrecognized element <' + nameNs.name + '>');
  };

  ElementHandler.prototype.toString = function () {
    return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';
  };

  ElementHandler.prototype.valueHandler = function (propertyDesc, element) {
    return new ValueHandler(propertyDesc, element);
  };

  ElementHandler.prototype.referenceHandler = function (propertyDesc) {
    return new ReferenceHandler(propertyDesc, this.context);
  };

  ElementHandler.prototype.handler = function (type) {
    if (type === 'Element') {
      return new GenericElementHandler(this.model, type, this.context);
    } else {
      return new ElementHandler(this.model, type, this.context);
    }
  };

  /**
   * Handle the child element parsing
   *
   * @param  {Element} node the xml node
   */
  ElementHandler.prototype.handleChild = function (node) {
    var propertyDesc, type, element, childHandler;

    propertyDesc = this.getPropertyForNode(node);
    element = this.element;

    type = propertyDesc.effectiveType || propertyDesc.type;

    if (isSimple(type)) {
      return this.valueHandler(propertyDesc, element);
    }

    if (propertyDesc.isReference) {
      childHandler = this.referenceHandler(propertyDesc).handleNode(node);
    } else {
      childHandler = this.handler(type).handleNode(node);
    }

    var newElement = childHandler.element;

    // child handles may decide to skip elements
    // by not returning anything
    if (newElement !== undefined) {

      if (propertyDesc.isMany) {
        element.get(propertyDesc.name).push(newElement);
      } else {
        element.set(propertyDesc.name, newElement);
      }

      if (propertyDesc.isReference) {
        assign(newElement, {
          element: element
        });

        this.context.addReference(newElement);
      } else {
        // establish child -> parent relationship
        newElement.$parent = element;
      }
    }

    return childHandler;
  };

  /**
   * An element handler that performs special validation
   * to ensure the node it gets initialized with matches
   * the handlers type (namespace wise).
   *
   * @param {Moddle} model
   * @param {String} typeName
   * @param {Context} context
   */
  function RootElementHandler(model, typeName, context) {
    ElementHandler.call(this, model, typeName, context);
  }

  RootElementHandler.prototype = Object.create(ElementHandler.prototype);

  RootElementHandler.prototype.createElement = function (node) {

    var name = node.name,
        nameNs = parseName(name),
        model = this.model,
        type = this.type,
        pkg = model.getPackage(nameNs.prefix),
        typeName = pkg && aliasToName(nameNs, pkg) || name;

    // verify the correct namespace if we parse
    // the first element in the handler tree
    //
    // this ensures we don't mistakenly import wrong namespace elements
    if (!type.hasType(typeName)) {
      throw error$1('unexpected element <' + node.originalName + '>');
    }

    return ElementHandler.prototype.createElement.call(this, node);
  };

  function GenericElementHandler(model, typeName, context) {
    this.model = model;
    this.context = context;
  }

  GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);

  GenericElementHandler.prototype.createElement = function (node) {

    var name = node.name,
        ns = parseName(name),
        prefix = ns.prefix,
        uri = node.ns[prefix + '$uri'],
        attributes = node.attributes;

    return this.model.createAny(name, uri, attributes);
  };

  GenericElementHandler.prototype.handleChild = function (node) {

    var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),
        element = this.element;

    var newElement = handler.element,
        children;

    if (newElement !== undefined) {
      children = element.$children = element.$children || [];
      children.push(newElement);

      // establish child -> parent relationship
      newElement.$parent = element;
    }

    return handler;
  };

  GenericElementHandler.prototype.handleText = function (text) {
    this.body = this.body || '' + text;
  };

  GenericElementHandler.prototype.handleEnd = function () {
    if (this.body) {
      this.element.$body = this.body;
    }
  };

  /**
   * A reader for a meta-model
   *
   * @param {Object} options
   * @param {Model} options.model used to read xml files
   * @param {Boolean} options.lax whether to make parse errors warnings
   */
  function Reader(options) {

    if (options instanceof Moddle) {
      options = {
        model: options
      };
    }

    assign(this, { lax: false }, options);
  }

  /**
   * Parse the given XML into a moddle document tree.
   *
   * @param {String} xml
   * @param {ElementHandler|Object} options or rootHandler
   * @param  {Function} done
   */
  Reader.prototype.fromXML = function (xml, options, done) {

    var rootHandler = options.rootHandler;

    if (options instanceof ElementHandler) {
      // root handler passed via (xml, { rootHandler: ElementHandler }, ...)
      rootHandler = options;
      options = {};
    } else {
      if (typeof options === 'string') {
        // rootHandler passed via (xml, 'someString', ...)
        rootHandler = this.handler(options);
        options = {};
      } else if (typeof rootHandler === 'string') {
        // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)
        rootHandler = this.handler(rootHandler);
      }
    }

    var model = this.model,
        lax = this.lax;

    var context = new Context(assign({}, options, { rootHandler: rootHandler })),
        parser = new Parser({ proxy: true }),
        stack = new tinyStack();

    rootHandler.context = context;

    // push root handler
    stack.push(rootHandler);

    /**
     * Handle error.
     *
     * @param  {Error} err
     * @param  {Function} getContext
     * @param  {boolean} lax
     *
     * @return {boolean} true if handled
     */
    function handleError(err, getContext, lax) {

      var ctx = getContext();

      var line = ctx.line,
          column = ctx.column,
          data = ctx.data;

      // we receive the full context data here,
      // for elements trim down the information
      // to the tag name, only
      if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {
        data = data.slice(0, data.indexOf(' ')) + '>';
      }

      var message = 'unparsable content ' + (data ? data + ' ' : '') + 'detected\n\t' + 'line: ' + line + '\n\t' + 'column: ' + column + '\n\t' + 'nested error: ' + err.message;

      if (lax) {
        context.addWarning({
          message: message,
          error: err
        });

        console.warn('could not parse node');
        console.warn(err);

        return true;
      } else {
        console.error('could not parse document');
        console.error(err);

        throw error$1(message);
      }
    }

    function handleWarning(err, getContext) {
      // just like handling errors in <lax=true> mode
      return handleError(err, getContext, true);
    }

    /**
     * Resolve collected references on parse end.
     */
    function resolveReferences() {

      var elementsById = context.elementsById;
      var references = context.references;

      var i, r;

      for (i = 0; r = references[i]; i++) {
        var element = r.element;
        var reference = elementsById[r.id];
        var property = getModdleDescriptor(element).propertiesByName[r.property];

        if (!reference) {
          context.addWarning({
            message: 'unresolved reference <' + r.id + '>',
            element: r.element,
            property: r.property,
            value: r.id
          });
        }

        if (property.isMany) {
          var collection = element.get(property.name),
              idx = collection.indexOf(r);

          // we replace an existing place holder (idx != -1) or
          // append to the collection instead
          if (idx === -1) {
            idx = collection.length;
          }

          if (!reference) {
            // remove unresolvable reference
            collection.splice(idx, 1);
          } else {
            // add or update reference in collection
            collection[idx] = reference;
          }
        } else {
          element.set(property.name, reference);
        }
      }
    }

    function handleClose() {
      stack.pop().handleEnd();
    }

    var PREAMBLE_START_PATTERN = /^<\?xml /i;

    var ENCODING_PATTERN = / encoding="([^"]+)"/i;

    var UTF_8_PATTERN = /^utf-8$/i;

    function handleQuestion(question) {

      if (!PREAMBLE_START_PATTERN.test(question)) {
        return;
      }

      var match = ENCODING_PATTERN.exec(question);
      var encoding = match && match[1];

      if (!encoding || UTF_8_PATTERN.test(encoding)) {
        return;
      }

      context.addWarning({
        message: 'unsupported document encoding <' + encoding + '>, ' + 'falling back to UTF-8'
      });
    }

    function handleOpen(node, getContext) {
      var handler = stack.peek();

      try {
        stack.push(handler.handleNode(node));
      } catch (err) {

        if (handleError(err, getContext, lax)) {
          stack.push(new NoopHandler());
        }
      }
    }

    function handleCData(text) {
      stack.peek().handleText(text);
    }

    function handleText(text) {
      // strip whitespace only nodes, i.e. before
      // <!CDATA[ ... ]> sections and in between tags
      text = text.trim();

      if (!text) {
        return;
      }

      stack.peek().handleText(text);
    }

    var uriMap = model.getPackages().reduce(function (uriMap, p) {
      uriMap[p.uri] = p.prefix;

      return uriMap;
    }, {});

    parser.ns(uriMap).on('openTag', function (obj, decodeStr, selfClosing, getContext) {

      // gracefully handle unparsable attributes (attrs=false)
      var attrs = obj.attrs || {};

      var decodedAttrs = Object.keys(attrs).reduce(function (d, key) {
        var value = decodeStr(attrs[key]);

        d[key] = value;

        return d;
      }, {});

      var node = {
        name: obj.name,
        originalName: obj.originalName,
        attributes: decodedAttrs,
        ns: obj.ns
      };

      handleOpen(node, getContext);
    }).on('question', handleQuestion).on('closeTag', handleClose).on('cdata', handleCData).on('text', function (text, decodeEntities$$1) {
      handleText(decodeEntities$$1(text));
    }).on('error', handleError).on('warn', handleWarning);

    // deferred parse XML to make loading really ascnchronous
    // this ensures the execution environment (node or browser)
    // is kept responsive and that certain optimization strategies
    // can kick in
    defer(function () {
      var err;

      try {
        parser.parse(xml);

        resolveReferences();
      } catch (e) {
        err = e;
      }

      var element = rootHandler.element;

      // handle the situation that we could not extract
      // the desired root element from the document
      if (!err && !element) {
        err = error$1('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');
      }

      done(err, err ? undefined : element, context);
    });
  };

  Reader.prototype.handler = function (name) {
    return new RootElementHandler(this.model, name);
  };

  var XML_PREAMBLE = '<?xml version="1.0" encoding="UTF-8"?>\n';

  var ESCAPE_ATTR_CHARS = /<|>|'|"|&|\n\r|\n/g;
  var ESCAPE_CHARS = /<|>|&/g;

  function Namespaces(parent) {

    var prefixMap = {};
    var uriMap = {};
    var used = {};

    var wellknown = [];
    var custom = [];

    // API

    this.byUri = function (uri) {
      return uriMap[uri] || parent && parent.byUri(uri);
    };

    this.add = function (ns, isWellknown) {

      uriMap[ns.uri] = ns;

      if (isWellknown) {
        wellknown.push(ns);
      } else {
        custom.push(ns);
      }

      this.mapPrefix(ns.prefix, ns.uri);
    };

    this.uriByPrefix = function (prefix) {
      return prefixMap[prefix || 'xmlns'];
    };

    this.mapPrefix = function (prefix, uri) {
      prefixMap[prefix || 'xmlns'] = uri;
    };

    this.logUsed = function (ns) {
      var uri = ns.uri;

      used[uri] = this.byUri(uri);
    };

    this.getUsed = function (ns) {

      function isUsed(ns) {
        return used[ns.uri];
      }

      var allNs = [].concat(wellknown, custom);

      return allNs.filter(isUsed);
    };
  }

  function lower(string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
  }

  function nameToAlias(name, pkg) {
    if (hasLowerCaseAlias(pkg)) {
      return lower(name);
    } else {
      return name;
    }
  }

  function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  }

  function nsName(ns) {
    if (isString(ns)) {
      return ns;
    } else {
      return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;
    }
  }

  function getNsAttrs(namespaces) {

    return map(namespaces.getUsed(), function (ns) {
      var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');
      return { name: name, value: ns.uri };
    });
  }

  function getElementNs(ns, descriptor) {
    if (descriptor.isGeneric) {
      return assign({ localName: descriptor.ns.localName }, ns);
    } else {
      return assign({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);
    }
  }

  function getPropertyNs(ns, descriptor) {
    return assign({ localName: descriptor.ns.localName }, ns);
  }

  function getSerializableProperties(element) {
    var descriptor = element.$descriptor;

    return filter(descriptor.properties, function (p) {
      var name = p.name;

      if (p.isVirtual) {
        return false;
      }

      // do not serialize defaults
      if (!element.hasOwnProperty(name)) {
        return false;
      }

      var value = element[name];

      // do not serialize default equals
      if (value === p.default) {
        return false;
      }

      // do not serialize null properties
      if (value === null) {
        return false;
      }

      return p.isMany ? value.length : true;
    });
  }

  var ESCAPE_ATTR_MAP = {
    '\n': '#10',
    '\n\r': '#10',
    '"': '#34',
    '\'': '#39',
    '<': '#60',
    '>': '#62',
    '&': '#38'
  };

  var ESCAPE_MAP = {
    '<': 'lt',
    '>': 'gt',
    '&': 'amp'
  };

  function escape(str, charPattern, replaceMap) {

    // ensure we are handling strings here
    str = isString(str) ? str : '' + str;

    return str.replace(charPattern, function (s) {
      return '&' + replaceMap[s] + ';';
    });
  }

  /**
   * Escape a string attribute to not contain any bad values (line breaks, '"', ...)
   *
   * @param {String} str the string to escape
   * @return {String} the escaped string
   */
  function escapeAttr(str) {
    return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);
  }

  function escapeBody(str) {
    return escape(str, ESCAPE_CHARS, ESCAPE_MAP);
  }

  function filterAttributes(props) {
    return filter(props, function (p) {
      return p.isAttr;
    });
  }

  function filterContained(props) {
    return filter(props, function (p) {
      return !p.isAttr;
    });
  }

  function ReferenceSerializer(tagName) {
    this.tagName = tagName;
  }

  ReferenceSerializer.prototype.build = function (element) {
    this.element = element;
    return this;
  };

  ReferenceSerializer.prototype.serializeTo = function (writer) {
    writer.appendIndent().append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>').appendNewLine();
  };

  function BodySerializer() {}

  BodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function (writer) {
    writer.append(this.escape ? escapeBody(this.value) : this.value);
  };

  BodySerializer.prototype.build = function (prop, value) {
    this.value = value;

    if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {
      this.escape = true;
    }

    return this;
  };

  function ValueSerializer(tagName) {
    this.tagName = tagName;
  }

  inherits(ValueSerializer, BodySerializer);

  ValueSerializer.prototype.serializeTo = function (writer) {

    writer.appendIndent().append('<' + this.tagName + '>');

    this.serializeValue(writer);

    writer.append('</' + this.tagName + '>').appendNewLine();
  };

  function ElementSerializer(parent, propertyDescriptor) {
    this.body = [];
    this.attrs = [];

    this.parent = parent;
    this.propertyDescriptor = propertyDescriptor;
  }

  ElementSerializer.prototype.build = function (element) {
    this.element = element;

    var elementDescriptor = element.$descriptor,
        propertyDescriptor = this.propertyDescriptor;

    var otherAttrs, properties;

    var isGeneric = elementDescriptor.isGeneric;

    if (isGeneric) {
      otherAttrs = this.parseGeneric(element);
    } else {
      otherAttrs = this.parseNsAttributes(element);
    }

    if (propertyDescriptor) {
      this.ns = this.nsPropertyTagName(propertyDescriptor);
    } else {
      this.ns = this.nsTagName(elementDescriptor);
    }

    // compute tag name
    this.tagName = this.addTagName(this.ns);

    if (!isGeneric) {
      properties = getSerializableProperties(element);

      this.parseAttributes(filterAttributes(properties));
      this.parseContainments(filterContained(properties));
    }

    this.parseGenericAttributes(element, otherAttrs);

    return this;
  };

  ElementSerializer.prototype.nsTagName = function (descriptor) {
    var effectiveNs = this.logNamespaceUsed(descriptor.ns);
    return getElementNs(effectiveNs, descriptor);
  };

  ElementSerializer.prototype.nsPropertyTagName = function (descriptor) {
    var effectiveNs = this.logNamespaceUsed(descriptor.ns);
    return getPropertyNs(effectiveNs, descriptor);
  };

  ElementSerializer.prototype.isLocalNs = function (ns) {
    return ns.uri === this.ns.uri;
  };

  /**
   * Get the actual ns attribute name for the given element.
   *
   * @param {Object} element
   * @param {Boolean} [element.inherited=false]
   *
   * @return {Object} nsName
   */
  ElementSerializer.prototype.nsAttributeName = function (element) {

    var ns;

    if (isString(element)) {
      ns = parseName(element);
    } else {
      ns = element.ns;
    }

    // return just local name for inherited attributes
    if (element.inherited) {
      return { localName: ns.localName };
    }

    // parse + log effective ns
    var effectiveNs = this.logNamespaceUsed(ns);

    // LOG ACTUAL namespace use
    this.getNamespaces().logUsed(effectiveNs);

    // strip prefix if same namespace like parent
    if (this.isLocalNs(effectiveNs)) {
      return { localName: ns.localName };
    } else {
      return assign({ localName: ns.localName }, effectiveNs);
    }
  };

  ElementSerializer.prototype.parseGeneric = function (element) {

    var self = this,
        body = this.body;

    var attributes = [];

    forEach(element, function (val, key) {

      var nonNsAttr;

      if (key === '$body') {
        body.push(new BodySerializer().build({ type: 'String' }, val));
      } else if (key === '$children') {
        forEach(val, function (child) {
          body.push(new ElementSerializer(self).build(child));
        });
      } else if (key.indexOf('$') !== 0) {
        nonNsAttr = self.parseNsAttribute(element, key, val);

        if (nonNsAttr) {
          attributes.push({ name: key, value: val });
        }
      }
    });

    return attributes;
  };

  ElementSerializer.prototype.parseNsAttribute = function (element, name, value) {
    var model = element.$model;

    var nameNs = parseName(name);

    var ns;

    // parse xmlns:foo="http://foo.bar"
    if (nameNs.prefix === 'xmlns') {
      ns = { prefix: nameNs.localName, uri: value };
    }

    // parse xmlns="http://foo.bar"
    if (!nameNs.prefix && nameNs.localName === 'xmlns') {
      ns = { uri: value };
    }

    if (!ns) {
      return {
        name: name,
        value: value
      };
    }

    if (model && model.getPackage(value)) {
      // register well known namespace
      this.logNamespace(ns, true, true);
    } else {
      // log custom namespace directly as used
      var actualNs = this.logNamespaceUsed(ns, true);

      this.getNamespaces().logUsed(actualNs);
    }
  };

  /**
   * Parse namespaces and return a list of left over generic attributes
   *
   * @param  {Object} element
   * @return {Array<Object>}
   */
  ElementSerializer.prototype.parseNsAttributes = function (element, attrs) {
    var self = this;

    var genericAttrs = element.$attrs;

    var attributes = [];

    // parse namespace attributes first
    // and log them. push non namespace attributes to a list
    // and process them later
    forEach(genericAttrs, function (value, name) {

      var nonNsAttr = self.parseNsAttribute(element, name, value);

      if (nonNsAttr) {
        attributes.push(nonNsAttr);
      }
    });

    return attributes;
  };

  ElementSerializer.prototype.parseGenericAttributes = function (element, attributes) {

    var self = this;

    forEach(attributes, function (attr) {

      // do not serialize xsi:type attribute
      // it is set manually based on the actual implementation type
      if (attr.name === XSI_TYPE$1) {
        return;
      }

      try {
        self.addAttribute(self.nsAttributeName(attr.name), attr.value);
      } catch (e) {
        console.warn('missing namespace information for ', attr.name, '=', attr.value, 'on', element, e);
      }
    });
  };

  ElementSerializer.prototype.parseContainments = function (properties) {

    var self = this,
        body = this.body,
        element = this.element;

    forEach(properties, function (p) {
      var value = element.get(p.name),
          isReference = p.isReference,
          isMany = p.isMany;

      if (!isMany) {
        value = [value];
      }

      if (p.isBody) {
        body.push(new BodySerializer().build(p, value[0]));
      } else if (isSimple(p.type)) {
        forEach(value, function (v) {
          body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));
        });
      } else if (isReference) {
        forEach(value, function (v) {
          body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));
        });
      } else {
        // allow serialization via type
        // rather than element name
        var asType = serializeAsType(p),
            asProperty = serializeAsProperty(p);

        forEach(value, function (v) {
          var serializer;

          if (asType) {
            serializer = new TypeSerializer(self, p);
          } else if (asProperty) {
            serializer = new ElementSerializer(self, p);
          } else {
            serializer = new ElementSerializer(self);
          }

          body.push(serializer.build(v));
        });
      }
    });
  };

  ElementSerializer.prototype.getNamespaces = function (local) {

    var namespaces = this.namespaces,
        parent = this.parent,
        parentNamespaces;

    if (!namespaces) {
      parentNamespaces = parent && parent.getNamespaces();

      if (local || !parentNamespaces) {
        this.namespaces = namespaces = new Namespaces(parentNamespaces);
      } else {
        namespaces = parentNamespaces;
      }
    }

    return namespaces;
  };

  ElementSerializer.prototype.logNamespace = function (ns, wellknown, local) {
    var namespaces = this.getNamespaces(local);

    var nsUri = ns.uri,
        nsPrefix = ns.prefix;

    var existing = namespaces.byUri(nsUri);

    if (!existing) {
      namespaces.add(ns, wellknown);
    }

    namespaces.mapPrefix(nsPrefix, nsUri);

    return ns;
  };

  ElementSerializer.prototype.logNamespaceUsed = function (ns, local) {
    var element = this.element,
        model = element.$model,
        namespaces = this.getNamespaces(local);

    // ns may be
    //
    //   * prefix only
    //   * prefix:uri
    //   * localName only

    var prefix = ns.prefix,
        uri = ns.uri,
        newPrefix,
        idx,
        wellknownUri;

    // handle anonymous namespaces (elementForm=unqualified), cf. #23
    if (!prefix && !uri) {
      return { localName: ns.localName };
    }

    wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;

    uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);

    if (!uri) {
      throw new Error('no namespace uri given for prefix <' + prefix + '>');
    }

    ns = namespaces.byUri(uri);

    if (!ns) {
      newPrefix = prefix;
      idx = 1;

      // find a prefix that is not mapped yet
      while (namespaces.uriByPrefix(newPrefix)) {
        newPrefix = prefix + '_' + idx++;
      }

      ns = this.logNamespace({ prefix: newPrefix, uri: uri }, wellknownUri === uri);
    }

    if (prefix) {
      namespaces.mapPrefix(prefix, uri);
    }

    return ns;
  };

  ElementSerializer.prototype.parseAttributes = function (properties) {
    var self = this,
        element = this.element;

    forEach(properties, function (p) {

      var value = element.get(p.name);

      if (p.isReference) {

        if (!p.isMany) {
          value = value.id;
        } else {
          var values$$1 = [];
          forEach(value, function (v) {
            values$$1.push(v.id);
          });
          // IDREFS is a whitespace-separated list of references.
          value = values$$1.join(' ');
        }
      }

      self.addAttribute(self.nsAttributeName(p), value);
    });
  };

  ElementSerializer.prototype.addTagName = function (nsTagName) {
    var actualNs = this.logNamespaceUsed(nsTagName);

    this.getNamespaces().logUsed(actualNs);

    return nsName(nsTagName);
  };

  ElementSerializer.prototype.addAttribute = function (name, value) {
    var attrs = this.attrs;

    if (isString(value)) {
      value = escapeAttr(value);
    }

    attrs.push({ name: name, value: value });
  };

  ElementSerializer.prototype.serializeAttributes = function (writer) {
    var attrs = this.attrs,
        namespaces = this.namespaces;

    if (namespaces) {
      attrs = getNsAttrs(namespaces).concat(attrs);
    }

    forEach(attrs, function (a) {
      writer.append(' ').append(nsName(a.name)).append('="').append(a.value).append('"');
    });
  };

  ElementSerializer.prototype.serializeTo = function (writer) {
    var firstBody = this.body[0],
        indent = firstBody && firstBody.constructor !== BodySerializer;

    writer.appendIndent().append('<' + this.tagName);

    this.serializeAttributes(writer);

    writer.append(firstBody ? '>' : ' />');

    if (firstBody) {

      if (indent) {
        writer.appendNewLine().indent();
      }

      forEach(this.body, function (b) {
        b.serializeTo(writer);
      });

      if (indent) {
        writer.unindent().appendIndent();
      }

      writer.append('</' + this.tagName + '>');
    }

    writer.appendNewLine();
  };

  /**
   * A serializer for types that handles serialization of data types
   */
  function TypeSerializer(parent, propertyDescriptor) {
    ElementSerializer.call(this, parent, propertyDescriptor);
  }

  inherits(TypeSerializer, ElementSerializer);

  TypeSerializer.prototype.parseNsAttributes = function (element) {

    // extracted attributes
    var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);

    var descriptor = element.$descriptor;

    // only serialize xsi:type if necessary
    if (descriptor.name === this.propertyDescriptor.type) {
      return attributes;
    }

    var typeNs = this.typeNs = this.nsTagName(descriptor);
    this.getNamespaces().logUsed(this.typeNs);

    // add xsi:type attribute to represent the elements
    // actual type

    var pkg = element.$model.getPackage(typeNs.uri),
        typePrefix = pkg.xml && pkg.xml.typePrefix || '';

    this.addAttribute(this.nsAttributeName(XSI_TYPE$1), (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName);

    return attributes;
  };

  TypeSerializer.prototype.isLocalNs = function (ns) {
    return ns.uri === (this.typeNs || this.ns).uri;
  };

  function SavingWriter() {
    this.value = '';

    this.write = function (str) {
      this.value += str;
    };
  }

  function FormatingWriter(out, format) {

    var indent = [''];

    this.append = function (str) {
      out.write(str);

      return this;
    };

    this.appendNewLine = function () {
      if (format) {
        out.write('\n');
      }

      return this;
    };

    this.appendIndent = function () {
      if (format) {
        out.write(indent.join('  '));
      }

      return this;
    };

    this.indent = function () {
      indent.push('');
      return this;
    };

    this.unindent = function () {
      indent.pop();
      return this;
    };
  }

  /**
   * A writer for meta-model backed document trees
   *
   * @param {Object} options output options to pass into the writer
   */
  function Writer(options) {

    options = assign({ format: false, preamble: true }, options || {});

    function toXML(tree, writer) {
      var internalWriter = writer || new SavingWriter();
      var formatingWriter = new FormatingWriter(internalWriter, options.format);

      if (options.preamble) {
        formatingWriter.append(XML_PREAMBLE);
      }

      new ElementSerializer().build(tree).serializeTo(formatingWriter);

      if (!writer) {
        return internalWriter.value;
      }
    }

    return {
      toXML: toXML
    };
  }

  /**
   * A sub class of {@link Moddle} with support for import and export of DMN xml files.
   *
   * @class DmnModdle
   * @extends Moddle
   *
   * @param {Object|Array} packages to use for instantiating the model
   * @param {Object} [options] additional options to pass over
   */
  function DmnModdle(packages, options) {
    Moddle.call(this, packages, options);
  }

  DmnModdle.prototype = Object.create(Moddle.prototype);

  /**
   * Instantiates a DMN model tree from a given xml string.
   *
   * @param {String}   xmlStr
   * @param {String}   [typeName='dmn:Definitions'] name of the root element
   * @param {Object}   [options]  options to pass to the underlying reader
   * @param {Function} done       callback that is invoked with (err, result, parseContext)
   *                              once the import completes
   */
  DmnModdle.prototype.fromXML = function (xmlStr, typeName, options, done) {

    if (!isString(typeName)) {
      done = options;
      options = typeName;
      typeName = 'dmn:Definitions';
    }

    if (isFunction(options)) {
      done = options;
      options = {};
    }

    var reader = new Reader(assign({ model: this, lax: true }, options));
    var rootHandler = reader.handler(typeName);

    reader.fromXML(xmlStr, rootHandler, done);
  };

  /**
   * Serializes a DMN object tree to XML.
   *
   * @param {String}   element    the root element, typically an instance of `Definitions`
   * @param {Object}   [options]  to pass to the underlying writer
   * @param {Function} done       callback invoked with (err, xmlStr) once the import completes
   */
  DmnModdle.prototype.toXML = function (element, options, done) {

    if (isFunction(options)) {
      done = options;
      options = {};
    }

    var writer = new Writer(options);

    var result;
    var err;

    try {
      result = writer.toXML(element);
    } catch (e) {
      err = e;
    }

    return done(err, result);
  };

  var name = "DMN";
  var uri = "http://www.omg.org/spec/DMN/20151101/dmn.xsd";
  var xml = { "tagAlias": "lowerCase" };
  var prefix = "dmn";
  var types = [{ "name": "DMNElement", "isAbstract": true, "properties": [{ "name": "description", "type": "String" }, { "name": "id", "type": "String", "isAttr": true, "isId": true }, { "name": "label", "type": "String", "isAttr": true }, { "name": "extensionElements", "type": "ExtensionElements" }] }, { "name": "NamedElement", "isAbstract": true, "superClass": ["DMNElement"], "properties": [{ "name": "name", "type": "String", "isAttr": true }] }, { "name": "DMNElementReference", "properties": [{ "name": "href", "type": "String", "isAttr": true }] }, { "name": "ExtensionElements", "properties": [{ "name": "values", "type": "Element", "isMany": true }] }, { "name": "Definitions", "superClass": ["NamedElement"], "properties": [{ "name": "namespace", "type": "String", "isAttr": true }, { "name": "typeLanguage", "type": "String", "isAttr": true, "default": "http://www.omg.org/spec/FEEL/20140401" }, { "name": "expressionLanguage", "type": "String", "isAttr": true, "default": "http://www.omg.org/spec/FEEL/20140401" }, { "name": "exporter", "type": "String", "isAttr": true }, { "name": "exporterVersion", "type": "String", "isAttr": true }, { "name": "itemDefinition", "type": "ItemDefinition", "isMany": true, "xml": { "serialize": "property" } }, { "name": "drgElements", "type": "DRGElement", "isMany": true }, { "name": "artifacts", "type": "Artifact", "isMany": true }] }, { "name": "Import", "properties": [{ "name": "namespace", "type": "String", "isAttr": true }, { "name": "locationURI", "type": "String", "isAttr": true }, { "name": "importType", "type": "String", "isAttr": true }] }, { "name": "DRGElement", "isAbstract": true, "superClass": ["NamedElement"] }, { "name": "Decision", "superClass": ["DRGElement"], "properties": [{ "name": "question", "type": "String" }, { "name": "allowedAnswers", "type": "String" }, { "name": "variable", "type": "InformationItem", "xml": { "serialize": "property" } }, { "name": "informationRequirement", "type": "InformationRequirement", "isMany": true, "xml": { "serialize": "property" } }, { "name": "knowledgeRequirement", "type": "KnowledgeRequirement", "isMany": true, "xml": { "serialize": "property" } }, { "name": "authorityRequirement", "type": "AuthorityRequirement", "isMany": true, "xml": { "serialize": "property" } }, { "name": "decisionTable", "type": "DecisionTable", "xml": { "serialize": "property" } }, { "name": "literalExpression", "type": "LiteralExpression", "xml": { "serialize": "property" } }] }, { "name": "BusinessKnowledgeModel", "superClass": ["DRGElement"], "properties": [{ "name": "encapsulatedLogic", "type": "FunctionDefinition" }, { "name": "variable", "type": "InformationItem", "xml": { "serialize": "property" } }, { "name": "knowledgeRequirement", "type": "KnowledgeRequirement", "isMany": true, "xml": { "serialize": "property" } }, { "name": "authorityRequirement", "type": "AuthorityRequirement", "isMany": true, "xml": { "serialize": "property" } }] }, { "name": "InputData", "superClass": ["DRGElement"], "properties": [{ "name": "variable", "type": "InformationItem", "xml": { "serialize": "property" } }] }, { "name": "KnowledgeSource", "superClass": ["DRGElement"], "properties": [{ "name": "authorityRequirement", "type": "AuthorityRequirement", "isMany": true, "xml": { "serialize": "property" } }, { "name": "type", "type": "String", "isAttr": true }, { "name": "owner", "type": "DMNElementReference", "isAttr": true }, { "name": "locationURI", "type": "String", "isAttr": true }] }, { "name": "InformationRequirement", "properties": [{ "name": "requiredDecision", "type": "DMNElementReference", "xml": { "serialize": "property" } }, { "name": "requiredInput", "type": "DMNElementReference", "xml": { "serialize": "property" } }] }, { "name": "KnowledgeRequirement", "properties": [{ "name": "requiredKnowledge", "type": "DMNElementReference", "isUnique": true, "xml": { "serialize": "property" } }] }, { "name": "AuthorityRequirement", "properties": [{ "name": "requiredDecision", "type": "DMNElementReference", "xml": { "serialize": "property" } }, { "name": "requiredInput", "type": "DMNElementReference", "xml": { "serialize": "property" } }, { "name": "requiredAuthority", "type": "DMNElementReference", "xml": { "serialize": "property" } }] }, { "name": "Expression", "isAbstract": true, "superClass": ["DMNElement"], "properties": [{ "name": "typeRef", "type": "String", "isAttr": true }] }, { "name": "ItemDefinition", "superClass": ["NamedElement"], "properties": [{ "name": "typeLanguage", "type": "String", "isAttr": true }, { "name": "isCollection", "type": "Boolean", "isAttr": true, "default": false }, { "name": "typeRef", "type": "String" }, { "name": "allowedValues", "type": "UnaryTests", "isMany": true, "xml": { "serialize": "property" } }] }, { "name": "LiteralExpression", "superClass": ["Expression"], "properties": [{ "name": "expressionLanguage", "type": "String", "isAttr": true }, { "name": "importedValues", "type": "ImportedValues" }, { "name": "text", "type": "String" }] }, { "name": "InformationItem", "superClass": ["NamedElement"], "properties": [{ "name": "typeRef", "type": "String", "isAttr": true }] }, { "name": "DecisionTable", "superClass": ["Expression"], "properties": [{ "name": "input", "type": "InputClause", "isMany": true, "xml": { "serialize": "property" } }, { "name": "output", "type": "OutputClause", "isMany": true, "xml": { "serialize": "property" } }, { "name": "rule", "type": "DecisionRule", "isMany": true, "xml": { "serialize": "property" } }, { "name": "hitPolicy", "type": "HitPolicy", "isAttr": true, "default": "UNIQUE" }, { "name": "aggregation", "type": "BuiltinAggregator", "isAttr": true }, { "name": "preferredOrientation", "type": "DecisionTableOrientation", "isAttr": true, "default": "Rule-as-Row" }, { "name": "outputLabel", "type": "String", "isAttr": true }] }, { "name": "DecisionRule", "superClass": ["DMNElement"], "properties": [{ "name": "inputEntry", "type": "UnaryTests", "isMany": true, "xml": { "serialize": "property" } }, { "name": "outputEntry", "type": "LiteralExpression", "isMany": true, "xml": { "serialize": "property" } }] }, { "name": "ImportedValues", "superClass": ["Import"], "properties": [{ "name": "importedElement", "type": "String", "isMany": true, "xml": { "serialize": "property" } }, { "name": "expressionLanguage", "type": "String", "isAttr": true }] }, { "name": "Artifact", "isAbstract": true, "superClass": ["DMNElement"] }, { "name": "TextAnnotation", "superClass": ["Artifact"], "properties": [{ "name": "text", "type": "String", "xml": { "serialize": "property" } }, { "name": "textFormat", "type": "String", "isAttr": true }] }, { "name": "Association", "superClass": ["Artifact"], "properties": [{ "name": "sourceRef", "type": "DMNElementReference", "xml": { "serialize": "property" } }, { "name": "targetRef", "type": "DMNElementReference", "xml": { "serialize": "property" } }, { "name": "associationDirection", "type": "AssociationDirection", "isAttr": true, "default": "None" }] }, { "name": "InputClause", "superClass": ["DMNElement"], "properties": [{ "name": "inputExpression", "type": "LiteralExpression", "xml": { "serialize": "property" } }, { "name": "inputValues", "type": "UnaryTests", "xml": { "serialize": "property" } }] }, { "name": "OutputClause", "superClass": ["DMNElement"], "properties": [{ "name": "outputValues", "type": "UnaryTests", "xml": { "serialize": "property" } }, { "name": "defaultOutputEntry", "type": "LiteralExpression", "xml": { "serialize": "property" } }, { "name": "name", "type": "String", "isAttr": true }, { "name": "typeRef", "type": "String", "isAttr": true }] }, { "name": "UnaryTests", "superClass": ["DMNElement"], "properties": [{ "name": "text", "type": "String" }, { "name": "expressionLanguage", "type": "String", "isAttr": true }] }, { "name": "FunctionDefinition", "superClass": ["Expression"], "properties": [{ "name": "formalParameter", "type": "InformationItem", "isMany": true, "xml": { "serialize": "property" } }, { "name": "expression", "type": "String", "isReference": true, "xml": { "serialize": "property" } }] }];
  var emumerations = [{ "name": "AssociationDirection", "literalValues": [{ "name": "None" }, { "name": "One" }, { "name": "Both" }] }, { "name": "HitPolicy", "literalValues": [{ "name": "UNIQUE" }, { "name": "FIRST" }, { "name": "PRIORITY" }, { "name": "ANY" }, { "name": "COLLECT" }, { "name": "RULE ORDER" }, { "name": "OUTPUT ORDER" }] }, { "name": "BuiltinAggregator", "literalValues": [{ "name": "SUM" }, { "name": "COUNT" }, { "name": "MIN" }, { "name": "MAX" }] }, { "name": "DecisionTableOrientation", "literalValues": [{ "name": "Rule-as-Row" }, { "name": "Rule-as-Column" }, { "name": "CrossTable" }] }];
  var DmnPackage = {
  	name: name,
  	uri: uri,
  	xml: xml,
  	prefix: prefix,
  	types: types,
  	emumerations: emumerations
  };

  var name$1 = "Camunda";
  var uri$1 = "http://camunda.org/schema/1.0/dmn";
  var prefix$1 = "camunda";
  var xml$1 = { "tagAlias": "lowerCase" };
  var types$1 = [{ "name": "InputVariable", "extends": ["dmn:InputClause"], "properties": [{ "name": "inputVariable", "isAttr": true, "type": "String" }] }];
  var CamundaPackage = {
  	name: name$1,
  	uri: uri$1,
  	prefix: prefix$1,
  	xml: xml$1,
  	types: types$1
  };

  var name$2 = "DC";
  var uri$2 = "http://www.omg.org/spec/DD/20100524/DC";
  var types$2 = [{ "name": "Boolean" }, { "name": "Integer" }, { "name": "Real" }, { "name": "String" }, { "name": "Font", "properties": [{ "name": "name", "type": "String", "isAttr": true }, { "name": "size", "type": "Real", "isAttr": true }, { "name": "isBold", "type": "Boolean", "isAttr": true }, { "name": "isItalic", "type": "Boolean", "isAttr": true }, { "name": "isUnderline", "type": "Boolean", "isAttr": true }, { "name": "isStrikeThrough", "type": "Boolean", "isAttr": true }] }, { "name": "Point", "properties": [{ "name": "x", "type": "Real", "default": "0", "isAttr": true }, { "name": "y", "type": "Real", "default": "0", "isAttr": true }] }, { "name": "Bounds", "properties": [{ "name": "x", "type": "Real", "default": "0", "isAttr": true }, { "name": "y", "type": "Real", "default": "0", "isAttr": true }, { "name": "width", "type": "Real", "isAttr": true }, { "name": "height", "type": "Real", "isAttr": true }] }];
  var prefix$2 = "dc";
  var associations = [];
  var BiodcPackage = {
  	name: name$2,
  	uri: uri$2,
  	types: types$2,
  	prefix: prefix$2,
  	associations: associations
  };

  var name$3 = "bpmn.io DI for DMN";
  var uri$3 = "http://bpmn.io/schema/dmn/biodi/1.0";
  var prefix$3 = "biodi";
  var xml$2 = { "tagAlias": "lowerCase" };
  var types$3 = [{ "name": "Edge", "superClass": ["Element"], "properties": [{ "name": "source", "type": "String", "isAttr": true }, { "name": "waypoints", "type": "Waypoint", "isMany": true, "xml": { "serialize": "property" } }] }, { "name": "Bounds", "superClass": ["dc:Bounds", "Element"] }, { "name": "Waypoint", "superClass": ["dc:Point"] }];
  var BiodiPackage = {
  	name: name$3,
  	uri: uri$3,
  	prefix: prefix$3,
  	xml: xml$2,
  	types: types$3
  };

  var packages = {
    dmn: DmnPackage,
    camunda: CamundaPackage,
    dc: BiodcPackage,
    biodi: BiodiPackage
  };

  function DmnModdle$1 (additionalPackages, options) {
    var pks = assign({}, packages, additionalPackages);

    return new DmnModdle(pks, options);
  }

  /**
   * Set attribute `name` to `val`, or get attr `name`.
   *
   * @param {Element} el
   * @param {String} name
   * @param {String} [val]
   * @api public
   */
  function attr(el, name, val) {
    // get
    if (arguments.length == 2) {
      return el.getAttribute(name);
    }

    // remove
    if (val === null) {
      return el.removeAttribute(name);
    }

    // set
    el.setAttribute(name, val);

    return el;
  }

  var indexOf = [].indexOf;

  var indexof = function indexof(arr, obj) {
    if (indexOf) return arr.indexOf(obj);
    for (var i = 0; i < arr.length; ++i) {
      if (arr[i] === obj) return i;
    }
    return -1;
  };

  /**
   * Taken from https://github.com/component/classes
   *
   * Without the component bits.
   */

  /**
   * Whitespace regexp.
   */

  var re = /\s+/;

  /**
   * toString reference.
   */

  var toString = Object.prototype.toString;

  /**
   * Wrap `el` in a `ClassList`.
   *
   * @param {Element} el
   * @return {ClassList}
   * @api public
   */

  function classes(el) {
    return new ClassList(el);
  }

  /**
   * Initialize a new ClassList for `el`.
   *
   * @param {Element} el
   * @api private
   */

  function ClassList(el) {
    if (!el || !el.nodeType) {
      throw new Error('A DOM element reference is required');
    }
    this.el = el;
    this.list = el.classList;
  }

  /**
   * Add class `name` if not already present.
   *
   * @param {String} name
   * @return {ClassList}
   * @api public
   */

  ClassList.prototype.add = function (name) {
    // classList
    if (this.list) {
      this.list.add(name);
      return this;
    }

    // fallback
    var arr = this.array();
    var i = indexof(arr, name);
    if (!~i) arr.push(name);
    this.el.className = arr.join(' ');
    return this;
  };

  /**
   * Remove class `name` when present, or
   * pass a regular expression to remove
   * any which match.
   *
   * @param {String|RegExp} name
   * @return {ClassList}
   * @api public
   */

  ClassList.prototype.remove = function (name) {
    if ('[object RegExp]' == toString.call(name)) {
      return this.removeMatching(name);
    }

    // classList
    if (this.list) {
      this.list.remove(name);
      return this;
    }

    // fallback
    var arr = this.array();
    var i = indexof(arr, name);
    if (~i) arr.splice(i, 1);
    this.el.className = arr.join(' ');
    return this;
  };

  /**
   * Remove all classes matching `re`.
   *
   * @param {RegExp} re
   * @return {ClassList}
   * @api private
   */

  ClassList.prototype.removeMatching = function (re) {
    var arr = this.array();
    for (var i = 0; i < arr.length; i++) {
      if (re.test(arr[i])) {
        this.remove(arr[i]);
      }
    }
    return this;
  };

  /**
   * Toggle class `name`, can force state via `force`.
   *
   * For browsers that support classList, but do not support `force` yet,
   * the mistake will be detected and corrected.
   *
   * @param {String} name
   * @param {Boolean} force
   * @return {ClassList}
   * @api public
   */

  ClassList.prototype.toggle = function (name, force) {
    // classList
    if (this.list) {
      if ('undefined' !== typeof force) {
        if (force !== this.list.toggle(name, force)) {
          this.list.toggle(name); // toggle again to correct
        }
      } else {
        this.list.toggle(name);
      }
      return this;
    }

    // fallback
    if ('undefined' !== typeof force) {
      if (!force) {
        this.remove(name);
      } else {
        this.add(name);
      }
    } else {
      if (this.has(name)) {
        this.remove(name);
      } else {
        this.add(name);
      }
    }

    return this;
  };

  /**
   * Return an array of classes.
   *
   * @return {Array}
   * @api public
   */

  ClassList.prototype.array = function () {
    var className = this.el.getAttribute('class') || '';
    var str = className.replace(/^\s+|\s+$/g, '');
    var arr = str.split(re);
    if ('' === arr[0]) arr.shift();
    return arr;
  };

  /**
   * Check if class `name` is present.
   *
   * @param {String} name
   * @return {ClassList}
   * @api public
   */

  ClassList.prototype.has = ClassList.prototype.contains = function (name) {
    return this.list ? this.list.contains(name) : !!~indexof(this.array(), name);
  };

  /**
   * Remove all children from the given element.
   */
  function clear(el) {

    var c;

    while (el.childNodes.length) {
      c = el.childNodes[0];
      el.removeChild(c);
    }

    return el;
  }

  /**
   * Element prototype.
   */

  var proto = Element.prototype;

  /**
   * Vendor function.
   */

  var vendor = proto.matchesSelector || proto.webkitMatchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector;

  /**
   * Expose `match()`.
   */

  var matchesSelector = match;

  /**
   * Match `el` to `selector`.
   *
   * @param {Element} el
   * @param {String} selector
   * @return {Boolean}
   * @api public
   */

  function match(el, selector) {
    if (vendor) return vendor.call(el, selector);
    var nodes = el.parentNode.querySelectorAll(selector);
    for (var i = 0; i < nodes.length; ++i) {
      if (nodes[i] == el) return true;
    }
    return false;
  }

  var closest = function closest(element, selector, checkYoSelf) {
    var parent = checkYoSelf ? element : element.parentNode;

    while (parent && parent !== document) {
      if (matchesSelector(parent, selector)) return parent;
      parent = parent.parentNode;
    }
  };

  var bind$1 = window.addEventListener ? 'addEventListener' : 'attachEvent',
      unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
      prefix$4 = bind$1 !== 'addEventListener' ? 'on' : '';

  /**
   * Bind `el` event `type` to `fn`.
   *
   * @param {Element} el
   * @param {String} type
   * @param {Function} fn
   * @param {Boolean} capture
   * @return {Function}
   * @api public
   */

  var bind_1 = function bind_1(el, type, fn, capture) {
    el[bind$1](prefix$4 + type, fn, capture || false);
    return fn;
  };

  /**
   * Unbind `el` event `type`'s callback `fn`.
   *
   * @param {Element} el
   * @param {String} type
   * @param {Function} fn
   * @param {Boolean} capture
   * @return {Function}
   * @api public
   */

  var unbind_1 = function unbind_1(el, type, fn, capture) {
    el[unbind](prefix$4 + type, fn, capture || false);
    return fn;
  };

  var componentEvent = {
    bind: bind_1,
    unbind: unbind_1
  };

  /**
   * Module dependencies.
   */

  /**
   * Delegate event `type` to `selector`
   * and invoke `fn(e)`. A callback function
   * is returned which may be passed to `.unbind()`.
   *
   * @param {Element} el
   * @param {String} selector
   * @param {String} type
   * @param {Function} fn
   * @param {Boolean} capture
   * @return {Function}
   * @api public
   */

  // Some events don't bubble, so we want to bind to the capture phase instead
  // when delegating.
  var forceCaptureEvents = ['focus', 'blur'];

  var bind$1$1 = function bind$1(el, selector, type, fn, capture) {
    if (forceCaptureEvents.indexOf(type) !== -1) capture = true;

    return componentEvent.bind(el, type, function (e) {
      var target = e.target || e.srcElement;
      e.delegateTarget = closest(target, selector, true, el);
      if (e.delegateTarget) fn.call(el, e);
    }, capture);
  };

  /**
   * Unbind event `type`'s callback `fn`.
   *
   * @param {Element} el
   * @param {String} type
   * @param {Function} fn
   * @param {Boolean} capture
   * @api public
   */

  var unbind$1 = function unbind$1(el, type, fn, capture) {
    if (forceCaptureEvents.indexOf(type) !== -1) capture = true;

    componentEvent.unbind(el, type, fn, capture);
  };

  var delegateEvents = {
    bind: bind$1$1,
    unbind: unbind$1
  };

  /**
   * Expose `parse`.
   */

  var domify = parse;

  /**
   * Tests for browser support.
   */

  var innerHTMLBug = false;
  var bugTestDiv;
  if (typeof document !== 'undefined') {
    bugTestDiv = document.createElement('div');
    // Setup
    bugTestDiv.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
    // Make sure that link elements get serialized correctly by innerHTML
    // This requires a wrapper element in IE
    innerHTMLBug = !bugTestDiv.getElementsByTagName('link').length;
    bugTestDiv = undefined;
  }

  /**
   * Wrap map from jquery.
   */

  var map$1 = {
    legend: [1, '<fieldset>', '</fieldset>'],
    tr: [2, '<table><tbody>', '</tbody></table>'],
    col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
    // for script/link/style tags to work in IE6-8, you have to wrap
    // in a div with a non-whitespace character in front, ha!
    _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']
  };

  map$1.td = map$1.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

  map$1.option = map$1.optgroup = [1, '<select multiple="multiple">', '</select>'];

  map$1.thead = map$1.tbody = map$1.colgroup = map$1.caption = map$1.tfoot = [1, '<table>', '</table>'];

  map$1.polyline = map$1.ellipse = map$1.polygon = map$1.circle = map$1.text = map$1.line = map$1.path = map$1.rect = map$1.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', '</svg>'];

  /**
   * Parse `html` and return a DOM Node instance, which could be a TextNode,
   * HTML DOM Node of some kind (<div> for example), or a DocumentFragment
   * instance, depending on the contents of the `html` string.
   *
   * @param {String} html - HTML string to "domify"
   * @param {Document} doc - The `document` instance to create the Node for
   * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance
   * @api private
   */

  function parse(html, doc) {
    if ('string' != typeof html) throw new TypeError('String expected');

    // default to the global `document` object
    if (!doc) doc = document;

    // tag name
    var m = /<([\w:]+)/.exec(html);
    if (!m) return doc.createTextNode(html);

    html = html.replace(/^\s+|\s+$/g, ''); // Remove leading/trailing whitespace

    var tag = m[1];

    // body support
    if (tag == 'body') {
      var el = doc.createElement('html');
      el.innerHTML = html;
      return el.removeChild(el.lastChild);
    }

    // wrap map
    var wrap = map$1[tag] || map$1._default;
    var depth = wrap[0];
    var prefix = wrap[1];
    var suffix = wrap[2];
    var el = doc.createElement('div');
    el.innerHTML = prefix + html + suffix;
    while (depth--) {
      el = el.lastChild;
    } // one element
    if (el.firstChild == el.lastChild) {
      return el.removeChild(el.firstChild);
    }

    // several elements
    var fragment = doc.createDocumentFragment();
    while (el.firstChild) {
      fragment.appendChild(el.removeChild(el.firstChild));
    }

    return fragment;
  }

  var proto$1 = typeof Element !== 'undefined' ? Element.prototype : {};
  var vendor$1 = proto$1.matches || proto$1.matchesSelector || proto$1.webkitMatchesSelector || proto$1.mozMatchesSelector || proto$1.msMatchesSelector || proto$1.oMatchesSelector;

  var matchesSelector$1 = match$1;

  /**
   * Match `el` to `selector`.
   *
   * @param {Element} el
   * @param {String} selector
   * @return {Boolean}
   * @api public
   */

  function match$1(el, selector) {
    if (!el || el.nodeType !== 1) return false;
    if (vendor$1) return vendor$1.call(el, selector);
    var nodes = el.parentNode.querySelectorAll(selector);
    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i] == el) return true;
    }
    return false;
  }

  function query(selector, el) {
    el = el || document;

    return el.querySelector(selector);
  }

  function all(selector, el) {
    el = el || document;

    return el.querySelectorAll(selector);
  }

  function remove(el) {
    el.parentNode && el.parentNode.removeChild(el);
  }

  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _typeof$2 = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _toConsumableArray$1(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var DEFAULT_CONTAINER_OPTIONS = {
    width: '100%',
    height: '100%',
    position: 'relative'
  };

  /**
   * The base class for DMN viewers and editors.
   *
   * @abstract
   */

  var Manager = function () {

    /**
     * Create a new instance with the given options.
     *
     * @param  {Object} options
     *
     * @return {Manager}
     */
    function Manager() {
      var _this = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Manager);

      this._viewsChanged = function () {
        _this._emit('views.changed', {
          views: _this._views,
          activeView: _this._activeView
        });
      };

      this._eventBus = new EventBus();

      this._viewsChanged = debounce(this._viewsChanged, 0);

      this._views = [];
      this._viewers = {};

      this._init(options);
    }

    /**
     * Parse and render a DMN 1.1 diagram.
     *
     * Once finished the viewer reports back the result to the
     * provided callback function with (err, warnings).
     *
     * ## Life-Cycle Events
     *
     * During import the viewer will fire life-cycle events:
     *
     *   * import.parse.start (about to read model from xml)
     *   * import.parse.complete (model read; may have worked or not)
     *   * import.render.start (graphical import start)
     *   * import.render.complete (graphical import finished)
     *   * import.done (everything done)
     *
     * You can use these events to hook into the life-cycle.
     *
     * @param {String} xml the DMN 1.1 xml
     * @param {Object} [options]
     * @param {Boolean} [options.open=true]
     * @param {Function} [done] invoked with (err, warnings=[])
     */

    _createClass(Manager, [{
      key: 'importXML',
      value: function importXML(xml, options, done) {
        var _this2 = this;

        if ((typeof options === 'undefined' ? 'undefined' : _typeof$2(options)) !== 'object') {
          done = options;
          options = { open: true };
        }

        if (typeof done !== 'function') {
          done = noop;
        }

        // hook in pre-parse listeners +
        // allow xml manipulation
        xml = this._emit('import.parse.start', { xml: xml }) || xml;

        this._moddle.fromXML(xml, 'dmn:Definitions', function (err, definitions, context) {

          // hook in post parse listeners +
          // allow definitions manipulation
          definitions = _this2._emit('import.parse.complete', {
            error: err,
            definitions: definitions,
            context: context
          }) || definitions;

          var parseWarnings = context.warnings;

          _this2._setDefinitions(definitions);

          if (err) {
            err = checkValidationError(err);
          }

          if (err || !options.open) {
            _this2._emit('import.done', { error: err, warmings: parseWarnings });

            return done(err, parseWarnings);
          }

          var view = _this2._activeView || _this2._getInitialView(_this2._views);

          if (!view) {
            return done(new Error('no displayable contents'));
          }

          _this2.open(view, function (err, warnings) {

            var allWarnings = [].concat(parseWarnings, warnings || []);

            _this2._emit('import.done', { error: err, warnings: allWarnings });

            done(err, allWarnings);
          });
        });
      }
    }, {
      key: 'getDefinitions',
      value: function getDefinitions() {
        return this._definitions;
      }

      /**
       * Return active view.
       *
       * @return {View}
       */

    }, {
      key: 'getActiveView',
      value: function getActiveView() {
        return this._activeView;
      }

      /**
       * Get the currently active viewer instance.
       *
       * @return {View}
       */

    }, {
      key: 'getActiveViewer',
      value: function getActiveViewer() {
        var activeView = this.getActiveView();

        return activeView && this._getViewer(activeView);
      }
    }, {
      key: 'getView',
      value: function getView(element) {
        return this._views.filter(function (v) {
          return v.element === element;
        })[0];
      }
    }, {
      key: 'getViews',
      value: function getViews() {
        return this._views;
      }

      /**
       * Export the currently displayed DMN 1.1 diagram as
       * a DMN 1.1 XML document.
       *
       * ## Life-Cycle Events
       *
       * During XML saving the viewer will fire life-cycle events:
       *
       *   * saveXML.start (before serialization)
       *   * saveXML.serialized (after xml generation)
       *   * saveXML.done (everything done)
       *
       * You can use these events to hook into the life-cycle.
       *
       * @param {Object} [options] export options
       * @param {Boolean} [options.format=false] output formated XML
       * @param {Boolean} [options.preamble=true] output preamble
       * @param {Function} done invoked with (err, xml)
       */

    }, {
      key: 'saveXML',
      value: function saveXML(options, done) {
        var _this3 = this;

        if (typeof options === 'function') {
          done = options;
          options = {};
        }

        var definitions = this._definitions;

        if (!definitions) {
          return done(new Error('no definitions loaded'));
        }

        // allow to fiddle around with definitions
        definitions = this._emit('saveXML.start', {
          definitions: definitions
        }) || definitions;

        this._moddle.toXML(definitions, options, function (err, xml) {

          try {
            xml = _this3._emit('saveXML.serialized', {
              error: err,
              xml: xml
            }) || xml;

            _this3._emit('saveXML.done', {
              error: err,
              xml: xml
            });
          } catch (e) {
            console.error('error in saveXML life-cycle listener', e);
          }

          done(err, xml);
        });
      }

      /**
       * Register an event listener
       *
       * Remove a previously added listener via {@link #off(event, callback)}.
       *
       * @param {String} event
       * @param {Number} [priority]
       * @param {Function} callback
       * @param {Object} [that]
       */

    }, {
      key: 'on',
      value: function on() {
        var _eventBus;

        (_eventBus = this._eventBus).on.apply(_eventBus, arguments);
      }

      /**
       * De-register an event listener
       *
       * @param {String} event
       * @param {Function} callback
       */

    }, {
      key: 'off',
      value: function off() {
        var _eventBus2;

        (_eventBus2 = this._eventBus).off.apply(_eventBus2, arguments);
      }

      /**
       * Register a listener to be invoked once only.
       *
       * @param {String} event
       * @param {Number} [priority]
       * @param {Function} callback
       * @param {Object} [that]
       */

    }, {
      key: 'once',
      value: function once() {
        var _eventBus3;

        (_eventBus3 = this._eventBus).once.apply(_eventBus3, arguments);
      }
    }, {
      key: 'attachTo',
      value: function attachTo(parentNode) {

        // unwrap jQuery if provided
        if (parentNode.get && parentNode.constructor.prototype.jquery) {
          parentNode = parentNode.get(0);
        }

        if (typeof parentNode === 'string') {
          parentNode = query(parentNode);
        }

        parentNode.appendChild(this._container);
      }
    }, {
      key: 'detach',
      value: function detach() {
        remove(this._container);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this4 = this;

        Object.keys(this._viewers, function (viewerId) {
          var viewer = _this4._viewers[viewerId];

          safeExecute(viewer, 'destroy');
        });

        remove(this._container);
      }
    }, {
      key: '_init',
      value: function _init(options) {
        this._options = options;

        this._moddle = this._createModdle(options);

        this._viewers = {};
        this._views = [];

        var container = domify('<div class="dmn-js-parent"></div>');

        var containerOptions = assign({}, DEFAULT_CONTAINER_OPTIONS, options);

        assign(container.style, {
          width: ensureUnit(containerOptions.width),
          height: ensureUnit(containerOptions.height),
          position: containerOptions.position
        });

        this._container = container;

        if (options.container) {
          this.attachTo(options.container);
        }
      }

      /**
       * Open diagram element.
       *
       * @param  {ModdleElement}   element
       * @param  {Function} [done]
       */

    }, {
      key: 'open',
      value: function open(view) {
        var done = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

        this._switchView(view, done);
      }
    }, {
      key: '_setDefinitions',
      value: function _setDefinitions(definitions) {
        this._definitions = definitions;

        this._updateViews();
      }
    }, {
      key: '_updateViews',

      /**
       * Recompute changed views after elements in
       * the DMN diagram have changed.
       */
      value: function _updateViews() {

        var definitions = this._definitions;

        if (!definitions) {
          this._views = [];
          this._switchView(null);

          return;
        }

        var viewProviders = this._getViewProviders();

        var displayableElements = [definitions].concat(_toConsumableArray$1(definitions.drgElements || []));

        // compute list of available views
        this._views = displayableElements.reduce(function (views, element) {

          var provider = find$1(viewProviders, function (provider) {
            if (typeof provider.opens === 'string') {
              return provider.opens === element.$type;
            } else {
              return provider.opens(element);
            }
          });

          if (!provider) {
            return views;
          }

          var view = {
            element: element,
            type: provider.id
          };

          return [].concat(_toConsumableArray$1(views), [view]);
        }, []);

        var activeView = this._activeView,
            newActiveView;

        if (activeView) {
          // check the new active view
          newActiveView = find$1(this._views, function (v) {
            return viewsEqual(activeView, v);
          }) || this._getInitialView(this._views);

          if (viewsEqual(activeView, newActiveView)) {
            // active view changed
            this._activeView = newActiveView;
          } else {
            // active view got deleted
            return this._switchView(null);
          }
        }

        this._viewsChanged();
      }
    }, {
      key: '_getInitialView',
      value: function _getInitialView(views) {
        return views[0];
      }

      /**
       * Switch to another view.
       *
       * @param  {View} newView
       * @param  {Function} [done]
       */

    }, {
      key: '_switchView',
      value: function _switchView(newView) {
        var _this5 = this;

        var done = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

        var complete = function complete(err, warnings) {
          _this5._viewsChanged();

          done(err, warnings);
        };

        var activeView = this.getActiveView(),
            activeViewer;

        var newViewer = newView && this._getViewer(newView),
            element = newView && newView.element;

        if (activeView) {
          activeViewer = this._getViewer(activeView);

          if (activeViewer !== newViewer) {
            safeExecute(activeViewer, 'clear');

            activeViewer.detach();
          }
        }

        this._activeView = newView;

        if (newViewer) {

          if (activeViewer !== newViewer) {
            newViewer.attachTo(this._container);
          }

          this._emit('import.render.start', {
            view: newView,
            element: element
          });

          return newViewer.open(element, function (err, warnings) {

            _this5._emit('import.render.complete', {
              view: newView,
              error: err,
              warnings: warnings
            });

            complete(err, warnings);
          });
        }

        // no active view
        complete();
      }
    }, {
      key: '_getViewer',
      value: function _getViewer(view) {

        var type = view.type;

        var viewer = this._viewers[type];

        if (!viewer) {
          viewer = this._viewers[type] = this._createViewer(view.type);

          this._emit('viewer.created', {
            type: type,
            viewer: viewer
          });
        }

        return viewer;
      }
    }, {
      key: '_createViewer',
      value: function _createViewer(id) {

        var provider = find$1(this._getViewProviders(), function (provider) {
          return provider.id === id;
        });

        if (!provider) {
          throw new Error('no provider for view type <' + id + '>');
        }

        var Viewer = provider.constructor;

        var providerOptions = this._options[id] || {};
        var commonOptions = this._options.common || {};

        return new Viewer(_extends$1({}, commonOptions, providerOptions, {
          additionalModules: [].concat(_toConsumableArray$1(providerOptions.additionalModules || []), [{
            _parent: ['value', this],
            moddle: ['value', this._moddle]
          }])
        }));
      }

      /**
       * Emit an event.
       */

    }, {
      key: '_emit',
      value: function _emit() {
        var _eventBus4;

        (_eventBus4 = this._eventBus).fire.apply(_eventBus4, arguments);
      }
    }, {
      key: '_createModdle',
      value: function _createModdle(options) {
        return new DmnModdle$1(options.moddleExtensions || {});
      }

      /**
       * Return the list of available view providers.
       *
       * @abstract
       *
       * @return {Array<ViewProvider>}
       */

    }, {
      key: '_getViewProviders',
      value: function _getViewProviders() {
        return [];
      }
    }]);

    return Manager;
  }();
  function noop() {}

  /**
   * Ensure the passed argument is a proper unit (defaulting to px)
   */
  function ensureUnit(val) {
    return val + (isNumber(val) ? 'px' : '');
  }

  function checkValidationError(err) {

    // check if we can help the user by indicating wrong DMN 1.1 xml
    // (in case he or the exporting tool did not get that right)

    var pattern = /unparsable content <([^>]+)> detected([\s\S]*)$/,
        match = pattern.exec(err.message);

    if (match) {
      err.message = 'unparsable content <' + match[1] + '> detected; ' + 'this may indicate an invalid DMN 1.1 diagram file' + match[2];
    }

    return err;
  }

  function find$1(arr, fn) {
    return arr.filter(fn)[0];
  }

  function viewsEqual(a, b) {

    if (typeof a === 'undefined') {
      if (typeof b === 'undefined') {
        return true;
      } else {
        return false;
      }
    }

    if (typeof b === 'undefined') {
      return false;
    }

    // compare by element _or_ element ID equality
    return a.element === b.element || a.element.id === b.element.id;
  }

  function safeExecute(viewer, method) {
    if (typeof viewer[method] === 'function') {
      viewer[method]();
    }
  }

  var hat_1 = createCommonjsModule(function (module) {
  var hat = module.exports = function (bits, base) {
      if (!base) base = 16;
      if (bits === undefined) bits = 128;
      if (bits <= 0) return '0';

      var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
      for (var i = 2; digits === Infinity; i *= 2) {
          digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
      }

      var rem = digits - Math.floor(digits);

      var res = '';

      for (var i = 0; i < Math.floor(digits); i++) {
          var x = Math.floor(Math.random() * base).toString(base);
          res = x + res;
      }

      if (rem) {
          var b = Math.pow(base, rem);
          var x = Math.floor(Math.random() * b).toString(base);
          res = x + res;
      }

      var parsed = parseInt(res, base);
      if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
          return hat(bits, base);
      } else return res;
  };

  hat.rack = function (bits, base, expandBy) {
      var fn = function fn(data) {
          var iters = 0;
          do {
              if (iters++ > 10) {
                  if (expandBy) bits += expandBy;else throw new Error('too many ID collisions, use more bits');
              }

              var id = hat(bits, base);
          } while (Object.hasOwnProperty.call(hats, id));

          hats[id] = data;
          return id;
      };
      var hats = fn.hats = {};

      fn.get = function (id) {
          return fn.hats[id];
      };

      fn.set = function (id, value) {
          fn.hats[id] = value;
          return fn;
      };

      fn.bits = bits || 128;
      fn.base = base || 16;
      return fn;
  };
  });

  /**
   * Create a new id generator / cache instance.
   *
   * You may optionally provide a seed that is used internally.
   *
   * @param {Seed} seed
   */
  function Ids(seed) {

    if (!(this instanceof Ids)) {
      return new Ids(seed);
    }

    seed = seed || [128, 36, 1];
    this._seed = seed.length ? hat_1.rack(seed[0], seed[1], seed[2]) : seed;
  }

  var ids = Ids;

  /**
   * Generate a next id.
   *
   * @param {Object} [element] element to bind the id to
   *
   * @return {String} id
   */
  Ids.prototype.next = function (element) {
    return this._seed(element || true);
  };

  /**
   * Generate a next id with a given prefix.
   *
   * @param {Object} [element] element to bind the id to
   *
   * @return {String} id
   */
  Ids.prototype.nextPrefixed = function (prefix, element) {
    var id;

    do {
      id = prefix + this.next(true);
    } while (this.assigned(id));

    // claim {prefix}{random}
    this.claim(id, element);

    // return
    return id;
  };

  /**
   * Manually claim an existing id.
   *
   * @param {String} id
   * @param {String} [element] element the id is claimed by
   */
  Ids.prototype.claim = function (id, element) {
    this._seed.set(id, element || true);
  };

  /**
   * Returns true if the given id has already been assigned.
   *
   * @param  {String} id
   * @return {Boolean}
   */
  Ids.prototype.assigned = function (id) {
    return this._seed.get(id) || false;
  };

  /**
   * Unclaim an id.
   *
   * @param  {String} id the id to unclaim
   */
  Ids.prototype.unclaim = function (id) {
    delete this._seed.hats[id];
  };

  /**
   * Clear all claimed ids.
   */
  Ids.prototype.clear = function () {

    var hats = this._seed.hats,
        id;

    for (id in hats) {
      this.unclaim(id);
    }
  };

  /**
   * Is an element of the given DMN type?
   *
   * @param  {tjs.model.Base|ModdleElement} element
   * @param  {String} type
   *
   * @return {Boolean}
   */
  function is(element, type) {
    var bo = getBusinessObject(element);

    return bo && typeof bo.$instanceOf === 'function' && bo.$instanceOf(type);
  }

  function isInput(element) {
    return is(element, 'dmn:InputClause');
  }

  function isOutput(element) {
    return is(element, 'dmn:OutputClause');
  }

  /**
   * Return the business object for a given element.
   *
   * @param  {tjs.model.Base|ModdleElement} element
   *
   * @return {ModdleElement}
   */
  function getBusinessObject(element) {
    return element && element.businessObject || element;
  }

  function getName(element) {
    return getBusinessObject(element).name;
  }

  /**
   * Return true if element has any of the given types.
   *
   * @param {djs.model.Base} element
   * @param {Array<String>} types
   *
   * @return {Boolean}
   */
  function isAny(element, types) {
    return some(types, function (t) {
      return is(element, t);
    });
  }

  var _typeof$3 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$1 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;if (getter === undefined) {
        return undefined;
      }return getter.call(receiver);
    }
  };

  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$3(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$3(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var EditingManager = function (_Manager) {
    _inherits(EditingManager, _Manager);

    function EditingManager() {
      _classCallCheck$1(this, EditingManager);

      return _possibleConstructorReturn(this, (EditingManager.__proto__ || Object.getPrototypeOf(EditingManager)).apply(this, arguments));
    }

    _createClass$1(EditingManager, [{
      key: '_init',
      value: function _init(options) {
        var _this2 = this;

        _get(EditingManager.prototype.__proto__ || Object.getPrototypeOf(EditingManager.prototype), '_init', this).call(this, options);

        // hook ID collection into the modeler
        this.on('import.parse.complete', function (event) {
          if (!event.error) {
            _this2._collectIds(event.definitions, event.context);
          }
        });

        this.on('destroy', function () {
          _this2._moddle.ids.clear();
        });

        this.on('viewer.created', function (_ref) {
          var viewer = _ref.viewer;

          viewer.on('elements.changed', function (_ref2) {
            var elements = _ref2.elements;

            var viewsChanged = elements.some(function (e) {
              return isAny(e, ['dmn:Decision', 'dmn:Definitions']);
            });

            if (viewsChanged) {
              _this2._updateViews();
            }
          });
        });
      }

      /**
       * Collect ids processed during parsing of the
       * definitions object.
       *
       * @param {ModdleElement} definitions
       * @param {Context} context
       */

    }, {
      key: '_collectIds',
      value: function _collectIds(definitions, context) {

        var moddle = definitions.$model,
            ids$$1 = moddle.ids,
            id;

        // remove references from previous import
        ids$$1.clear();

        for (id in context.elementsById) {
          ids$$1.claim(id, context.elementsById[id]);
        }
      }
    }, {
      key: '_createModdle',
      value: function _createModdle(options) {
        var moddle = _get(EditingManager.prototype.__proto__ || Object.getPrototypeOf(EditingManager.prototype), '_createModdle', this).call(this, options);

        // attach ids to moddle to be able to track
        // and validated ids in the DMN 1.1 XML document
        // tree
        moddle.ids = new ids([32, 36, 1]);

        return moddle;
      }
    }]);

    return EditingManager;
  }(Manager);

  var inherits_browser = createCommonjsModule(function (module) {
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function TempCtor() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  });

  var _typeof2$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var CLASS_PATTERN = /^class /;

  function isClass(fn) {
    return CLASS_PATTERN.test(fn.toString());
  }

  function isArray$1(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  }

  function annotate() {
    var args = Array.prototype.slice.call(arguments);

    if (args.length === 1 && isArray$1(args[0])) {
      args = args[0];
    }

    var fn = args.pop();

    fn.$inject = args;

    return fn;
  }

  // Current limitations:
  // - can't put into "function arg" comments
  // function /* (no parenthesis like this) */ (){}
  // function abc( /* xx (no parenthesis like this) */ a, b) {}
  //
  // Just put the comment before function or inside:
  // /* (((this is fine))) */ function(a, b) {}
  // function abc(a) { /* (((this is fine))) */}
  //
  // - can't reliably auto-annotate constructor; we'll match the
  // first constructor(...) pattern found which may be the one
  // of a nested class, too.

  var CONSTRUCTOR_ARGS = /constructor\s*[^(]*\(\s*([^)]*)\)/m;
  var FN_ARGS = /^function\s*[^(]*\(\s*([^)]*)\)/m;
  var FN_ARG = /\/\*([^*]*)\*\//m;

  function parse$1(fn) {

    if (typeof fn !== 'function') {
      throw new Error('Cannot annotate "' + fn + '". Expected a function!');
    }

    var match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);

    // may parse class without constructor
    if (!match) {
      return [];
    }

    return match[1] && match[1].split(',').map(function (arg) {
      match = arg.match(FN_ARG);
      return match ? match[1].trim() : arg.trim();
    }) || [];
  }

  function Module() {
    var providers = [];

    this.factory = function (name, factory) {
      providers.push([name, 'factory', factory]);
      return this;
    };

    this.value = function (name, value) {
      providers.push([name, 'value', value]);
      return this;
    };

    this.type = function (name, type) {
      providers.push([name, 'type', type]);
      return this;
    };

    this.forEach = function (iterator) {
      providers.forEach(iterator);
    };
  }

  var _typeof$4 = typeof Symbol === "function" && _typeof2$1(Symbol.iterator) === "symbol" ? function (obj) {
    return typeof obj === 'undefined' ? 'undefined' : _typeof2$1(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2$1(obj);
  };

  function _toConsumableArray$2(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function Injector(modules, parent) {
    parent = parent || {
      get: function get(name, strict) {
        currentlyResolving.push(name);

        if (strict === false) {
          return null;
        } else {
          throw error('No provider for "' + name + '"!');
        }
      }
    };

    var currentlyResolving = [];
    var providers = this._providers = Object.create(parent._providers || null);
    var instances = this._instances = Object.create(null);

    var self = instances.injector = this;

    var error = function error(msg) {
      var stack = currentlyResolving.join(' -> ');
      currentlyResolving.length = 0;
      return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);
    };

    /**
     * Return a named service.
     *
     * @param {String} name
     * @param {Boolean} [strict=true] if false, resolve missing services to null
     *
     * @return {Object}
     */
    var get = function get(name, strict) {
      if (!providers[name] && name.indexOf('.') !== -1) {
        var parts = name.split('.');
        var pivot = get(parts.shift());

        while (parts.length) {
          pivot = pivot[parts.shift()];
        }

        return pivot;
      }

      if (hasProp(instances, name)) {
        return instances[name];
      }

      if (hasProp(providers, name)) {
        if (currentlyResolving.indexOf(name) !== -1) {
          currentlyResolving.push(name);
          throw error('Cannot resolve circular dependency!');
        }

        currentlyResolving.push(name);
        instances[name] = providers[name][0](providers[name][1]);
        currentlyResolving.pop();

        return instances[name];
      }

      return parent.get(name, strict);
    };

    var fnDef = function fnDef(fn) {
      var locals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (typeof fn !== 'function') {
        if (isArray$1(fn)) {
          fn = annotate(fn.slice());
        } else {
          throw new Error('Cannot invoke "' + fn + '". Expected a function!');
        }
      }

      var inject = fn.$inject || parse$1(fn);
      var dependencies = inject.map(function (dep) {
        if (hasProp(locals, dep)) {
          return locals[dep];
        } else {
          return get(dep);
        }
      });

      return {
        fn: fn,
        dependencies: dependencies
      };
    };

    var instantiate = function instantiate(Type) {
      var _fnDef = fnDef(Type),
          dependencies = _fnDef.dependencies,
          fn = _fnDef.fn;

      return new (Function.prototype.bind.apply(fn, [null].concat(_toConsumableArray$2(dependencies))))();
    };

    var invoke = function invoke(func, context, locals) {
      var _fnDef2 = fnDef(func, locals),
          dependencies = _fnDef2.dependencies,
          fn = _fnDef2.fn;

      return fn.call.apply(fn, [context].concat(_toConsumableArray$2(dependencies)));
    };

    var createPrivateInjectorFactory = function createPrivateInjectorFactory(privateChildInjector) {
      return annotate(function (key) {
        return privateChildInjector.get(key);
      });
    };

    var createChild = function createChild(modules, forceNewInstances) {
      if (forceNewInstances && forceNewInstances.length) {
        var fromParentModule = Object.create(null);
        var matchedScopes = Object.create(null);

        var privateInjectorsCache = [];
        var privateChildInjectors = [];
        var privateChildFactories = [];

        var provider;
        var cacheIdx;
        var privateChildInjector;
        var privateChildInjectorFactory;
        for (var name in providers) {
          provider = providers[name];

          if (forceNewInstances.indexOf(name) !== -1) {
            if (provider[2] === 'private') {
              cacheIdx = privateInjectorsCache.indexOf(provider[3]);
              if (cacheIdx === -1) {
                privateChildInjector = provider[3].createChild([], forceNewInstances);
                privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);
                privateInjectorsCache.push(provider[3]);
                privateChildInjectors.push(privateChildInjector);
                privateChildFactories.push(privateChildInjectorFactory);
                fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];
              } else {
                fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];
              }
            } else {
              fromParentModule[name] = [provider[2], provider[1]];
            }
            matchedScopes[name] = true;
          }

          if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {
            /* jshint -W083 */
            forceNewInstances.forEach(function (scope) {
              if (provider[1].$scope.indexOf(scope) !== -1) {
                fromParentModule[name] = [provider[2], provider[1]];
                matchedScopes[scope] = true;
              }
            });
          }
        }

        forceNewInstances.forEach(function (scope) {
          if (!matchedScopes[scope]) {
            throw new Error('No provider for "' + scope + '". Cannot use provider from the parent!');
          }
        });

        modules.unshift(fromParentModule);
      }

      return new Injector(modules, self);
    };

    var factoryMap = {
      factory: invoke,
      type: instantiate,
      value: function value(_value) {
        return _value;
      }
    };

    modules.forEach(function (module) {

      function arrayUnwrap(type, value) {
        if (type !== 'value' && isArray$1(value)) {
          value = annotate(value.slice());
        }

        return value;
      }

      // TODO(vojta): handle wrong inputs (modules)
      if (module instanceof Module) {
        module.forEach(function (provider) {
          var name = provider[0];
          var type = provider[1];
          var value = provider[2];

          providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];
        });
      } else if ((typeof module === 'undefined' ? 'undefined' : _typeof$4(module)) === 'object') {
        if (module.__exports__) {
          var clonedModule = Object.keys(module).reduce(function (m, key) {
            if (key.substring(0, 2) !== '__') {
              m[key] = module[key];
            }
            return m;
          }, Object.create(null));

          var privateInjector = new Injector((module.__modules__ || []).concat([clonedModule]), self);
          var getFromPrivateInjector = annotate(function (key) {
            return privateInjector.get(key);
          });
          module.__exports__.forEach(function (key) {
            providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];
          });
        } else {
          Object.keys(module).forEach(function (name) {
            if (module[name][2] === 'private') {
              providers[name] = module[name];
              return;
            }

            var type = module[name][0];
            var value = module[name][1];

            providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];
          });
        }
      }
    });

    // public API
    this.get = get;
    this.invoke = invoke;
    this.instantiate = instantiate;
    this.createChild = createChild;
  }

  // helpers /////////////////

  function hasProp(obj, prop) {
    return Object.hasOwnProperty.call(obj, prop);
  }

  var DEFAULT_RENDER_PRIORITY = 1000;

  /**
   * The base implementation of shape and connection renderers.
   *
   * @param {EventBus} eventBus
   * @param {Number} [renderPriority=1000]
   */
  function BaseRenderer(eventBus, renderPriority) {
    var self = this;

    renderPriority = renderPriority || DEFAULT_RENDER_PRIORITY;

    eventBus.on(['render.shape', 'render.connection'], renderPriority, function (evt, context) {
      var type = evt.type,
          element = context.element,
          visuals = context.gfx;

      if (self.canRender(element)) {
        if (type === 'render.shape') {
          return self.drawShape(visuals, element);
        } else {
          return self.drawConnection(visuals, element);
        }
      }
    });

    eventBus.on(['render.getShapePath', 'render.getConnectionPath'], renderPriority, function (evt, element) {
      if (self.canRender(element)) {
        if (evt.type === 'render.getShapePath') {
          return self.getShapePath(element);
        } else {
          return self.getConnectionPath(element);
        }
      }
    });
  }

  /**
   * Should check whether *this* renderer can render
   * the element/connection.
   *
   * @param {element} element
   *
   * @returns {Boolean}
   */
  BaseRenderer.prototype.canRender = function () {};

  /**
   * Provides the shape's snap svg element to be drawn on the `canvas`.
   *
   * @param {djs.Graphics} visuals
   * @param {Shape} shape
   *
   * @returns {Snap.svg} [returns a Snap.svg paper element ]
   */
  BaseRenderer.prototype.drawShape = function () {};

  /**
   * Provides the shape's snap svg element to be drawn on the `canvas`.
   *
   * @param {djs.Graphics} visuals
   * @param {Connection} connection
   *
   * @returns {Snap.svg} [returns a Snap.svg paper element ]
   */
  BaseRenderer.prototype.drawConnection = function () {};

  /**
   * Gets the SVG path of a shape that represents it's visual bounds.
   *
   * @param {Shape} shape
   *
   * @return {string} svg path
   */
  BaseRenderer.prototype.getShapePath = function () {};

  /**
   * Gets the SVG path of a connection that represents it's visual bounds.
   *
   * @param {Connection} connection
   *
   * @return {string} svg path
   */
  BaseRenderer.prototype.getConnectionPath = function () {};

  function ensureImported(element, target) {

    if (element.ownerDocument !== target.ownerDocument) {
      try {
        // may fail on webkit
        return target.ownerDocument.importNode(element, true);
      } catch (e) {
        // ignore
      }
    }

    return element;
  }

  /**
   * appendTo utility
   */

  /**
   * Append a node to a target element and return the appended node.
   *
   * @param  {SVGElement} element
   * @param  {SVGElement} node
   *
   * @return {SVGElement} the appended node
   */
  function appendTo(element, target) {
    target.appendChild(ensureImported(element, target));
    return element;
  }

  /**
   * append utility
   */

  /**
   * Append a node to an element
   *
   * @param  {SVGElement} element
   * @param  {SVGElement} node
   *
   * @return {SVGElement} the element
   */
  function append(element, node) {
    appendTo(node, element);
    return element;
  }

  /**
   * attribute accessor utility
   */

  var LENGTH_ATTR = 2;

  var CSS_PROPERTIES = {
    'alignment-baseline': 1,
    'baseline-shift': 1,
    'clip': 1,
    'clip-path': 1,
    'clip-rule': 1,
    'color': 1,
    'color-interpolation': 1,
    'color-interpolation-filters': 1,
    'color-profile': 1,
    'color-rendering': 1,
    'cursor': 1,
    'direction': 1,
    'display': 1,
    'dominant-baseline': 1,
    'enable-background': 1,
    'fill': 1,
    'fill-opacity': 1,
    'fill-rule': 1,
    'filter': 1,
    'flood-color': 1,
    'flood-opacity': 1,
    'font': 1,
    'font-family': 1,
    'font-size': LENGTH_ATTR,
    'font-size-adjust': 1,
    'font-stretch': 1,
    'font-style': 1,
    'font-variant': 1,
    'font-weight': 1,
    'glyph-orientation-horizontal': 1,
    'glyph-orientation-vertical': 1,
    'image-rendering': 1,
    'kerning': 1,
    'letter-spacing': 1,
    'lighting-color': 1,
    'marker': 1,
    'marker-end': 1,
    'marker-mid': 1,
    'marker-start': 1,
    'mask': 1,
    'opacity': 1,
    'overflow': 1,
    'pointer-events': 1,
    'shape-rendering': 1,
    'stop-color': 1,
    'stop-opacity': 1,
    'stroke': 1,
    'stroke-dasharray': 1,
    'stroke-dashoffset': 1,
    'stroke-linecap': 1,
    'stroke-linejoin': 1,
    'stroke-miterlimit': 1,
    'stroke-opacity': 1,
    'stroke-width': LENGTH_ATTR,
    'text-anchor': 1,
    'text-decoration': 1,
    'text-rendering': 1,
    'unicode-bidi': 1,
    'visibility': 1,
    'word-spacing': 1,
    'writing-mode': 1
  };

  function getAttribute(node, name) {
    if (CSS_PROPERTIES[name]) {
      return node.style[name];
    } else {
      return node.getAttributeNS(null, name);
    }
  }

  function setAttribute(node, name, value) {
    var hyphenated = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();

    var type = CSS_PROPERTIES[hyphenated];

    if (type) {
      // append pixel unit, unless present
      if (type === LENGTH_ATTR && typeof value === 'number') {
        value = String(value) + 'px';
      }

      node.style[hyphenated] = value;
    } else {
      node.setAttributeNS(null, name, value);
    }
  }

  function setAttributes(node, attrs) {

    var names = Object.keys(attrs),
        i,
        name;

    for (i = 0, name; name = names[i]; i++) {
      setAttribute(node, name, attrs[name]);
    }
  }

  /**
   * Gets or sets raw attributes on a node.
   *
   * @param  {SVGElement} node
   * @param  {Object} [attrs]
   * @param  {String} [name]
   * @param  {String} [value]
   *
   * @return {String}
   */
  function attr$1(node, name, value) {
    if (typeof name === 'string') {
      if (value !== undefined) {
        setAttribute(node, name, value);
      } else {
        return getAttribute(node, name);
      }
    } else {
      setAttributes(node, name);
    }

    return node;
  }

  /**
   * Clear utility
   */
  function index(arr, obj) {
    if (arr.indexOf) {
      return arr.indexOf(obj);
    }

    for (var i = 0; i < arr.length; ++i) {
      if (arr[i] === obj) {
        return i;
      }
    }

    return -1;
  }

  var re$1 = /\s+/;

  var toString$1 = Object.prototype.toString;

  function defined(o) {
    return typeof o !== 'undefined';
  }

  /**
   * Wrap `el` in a `ClassList`.
   *
   * @param {Element} el
   * @return {ClassList}
   * @api public
   */

  function classes$1(el) {
    return new ClassList$1(el);
  }

  function ClassList$1(el) {
    if (!el || !el.nodeType) {
      throw new Error('A DOM element reference is required');
    }
    this.el = el;
    this.list = el.classList;
  }

  /**
   * Add class `name` if not already present.
   *
   * @param {String} name
   * @return {ClassList}
   * @api public
   */

  ClassList$1.prototype.add = function (name) {

    // classList
    if (this.list) {
      this.list.add(name);
      return this;
    }

    // fallback
    var arr = this.array();
    var i = index(arr, name);
    if (!~i) {
      arr.push(name);
    }

    if (defined(this.el.className.baseVal)) {
      this.el.className.baseVal = arr.join(' ');
    } else {
      this.el.className = arr.join(' ');
    }

    return this;
  };

  /**
   * Remove class `name` when present, or
   * pass a regular expression to remove
   * any which match.
   *
   * @param {String|RegExp} name
   * @return {ClassList}
   * @api public
   */

  ClassList$1.prototype.remove = function (name) {
    if ('[object RegExp]' === toString$1.call(name)) {
      return this.removeMatching(name);
    }

    // classList
    if (this.list) {
      this.list.remove(name);
      return this;
    }

    // fallback
    var arr = this.array();
    var i = index(arr, name);
    if (~i) {
      arr.splice(i, 1);
    }
    this.el.className.baseVal = arr.join(' ');
    return this;
  };

  /**
   * Remove all classes matching `re`.
   *
   * @param {RegExp} re
   * @return {ClassList}
   * @api private
   */

  ClassList$1.prototype.removeMatching = function (re) {
    var arr = this.array();
    for (var i = 0; i < arr.length; i++) {
      if (re.test(arr[i])) {
        this.remove(arr[i]);
      }
    }
    return this;
  };

  /**
   * Toggle class `name`, can force state via `force`.
   *
   * For browsers that support classList, but do not support `force` yet,
   * the mistake will be detected and corrected.
   *
   * @param {String} name
   * @param {Boolean} force
   * @return {ClassList}
   * @api public
   */

  ClassList$1.prototype.toggle = function (name, force) {
    // classList
    if (this.list) {
      if (defined(force)) {
        if (force !== this.list.toggle(name, force)) {
          this.list.toggle(name); // toggle again to correct
        }
      } else {
        this.list.toggle(name);
      }
      return this;
    }

    // fallback
    if (defined(force)) {
      if (!force) {
        this.remove(name);
      } else {
        this.add(name);
      }
    } else {
      if (this.has(name)) {
        this.remove(name);
      } else {
        this.add(name);
      }
    }

    return this;
  };

  /**
   * Return an array of classes.
   *
   * @return {Array}
   * @api public
   */

  ClassList$1.prototype.array = function () {
    var className = this.el.getAttribute('class') || '';
    var str = className.replace(/^\s+|\s+$/g, '');
    var arr = str.split(re$1);
    if ('' === arr[0]) {
      arr.shift();
    }
    return arr;
  };

  /**
   * Check if class `name` is present.
   *
   * @param {String} name
   * @return {ClassList}
   * @api public
   */

  ClassList$1.prototype.has = ClassList$1.prototype.contains = function (name) {
    return this.list ? this.list.contains(name) : !!~index(this.array(), name);
  };

  function remove$1(element) {
    var parent = element.parentNode;

    if (parent) {
      parent.removeChild(element);
    }

    return element;
  }

  /**
   * Clear utility
   */

  /**
   * Removes all children from the given element
   *
   * @param  {DOMElement} element
   * @return {DOMElement} the element (for chaining)
   */
  function clear$1(element) {
    var child;

    while (child = element.firstChild) {
      remove$1(child);
    }

    return element;
  }

  function clone(element) {
    return element.cloneNode(true);
  }

  var ns = {
    svg: 'http://www.w3.org/2000/svg'
  };

  /**
   * DOM parsing utility
   */

  var SVG_START = '<svg xmlns="' + ns.svg + '"';

  function parse$2(svg) {

    // ensure we import a valid svg document
    if (svg.substring(0, 4) === '<svg') {
      if (svg.indexOf(ns.svg) === -1) {
        svg = SVG_START + svg.substring(4);
      }
    } else {
      // namespace svg
      svg = SVG_START + '>' + svg + '</svg>';
    }

    return parseDocument(svg);
  }

  function parseDocument(svg) {

    var parser;

    // parse
    parser = new DOMParser();
    parser.async = false;

    return parser.parseFromString(svg, 'text/xml');
  }

  /**
   * Create utility for SVG elements
   */

  /**
   * Create a specific type from name or SVG markup.
   *
   * @param {String} name the name or markup of the element
   * @param {Object} [attrs] attributes to set on the element
   *
   * @returns {SVGElement}
   */
  function create(name, attrs) {
    var element;

    if (name.charAt(0) === '<') {
      element = parse$2(name).firstChild;
      element = document.importNode(element, true);
    } else {
      element = document.createElementNS(ns.svg, name);
    }

    if (attrs) {
      attr$1(element, attrs);
    }

    return element;
  }

  /**
   * Geometry helpers
   */

  // fake node used to instantiate svg geometry elements
  var node = create('svg');

  function extend(object, props) {
    var i,
        k,
        keys = Object.keys(props);

    for (i = 0; k = keys[i]; i++) {
      object[k] = props[k];
    }

    return object;
  }

  function createMatrix(a, b, c, d, e, f) {
    var matrix = node.createSVGMatrix();

    switch (arguments.length) {
      case 0:
        return matrix;
      case 6:
        a = {
          a: a,
          b: b,
          c: c,
          d: d,
          e: e,
          f: f
        };
        break;
    }

    return extend(matrix, a);
  }

  function createTransform(matrix) {
    if (matrix) {
      return node.createSVGTransformFromMatrix(matrix);
    } else {
      return node.createSVGTransform();
    }
  }

  /**
   * Serialization util
   */

  var TEXT_ENTITIES = /([&<>]{1})/g;
  var ATTR_ENTITIES = /([\n\r"]{1})/g;

  var ENTITY_REPLACEMENT = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '\''
  };

  function escape$1(str, pattern) {

    function replaceFn(match, entity) {
      return ENTITY_REPLACEMENT[entity] || entity;
    }

    return str.replace(pattern, replaceFn);
  }

  function serialize(node, output) {

    var i, len, attrMap, attrNode, childNodes;

    switch (node.nodeType) {
      // TEXT
      case 3:
        // replace special XML characters
        output.push(escape$1(node.textContent, TEXT_ENTITIES));
        break;

      // ELEMENT
      case 1:
        output.push('<', node.tagName);

        if (node.hasAttributes()) {
          attrMap = node.attributes;
          for (i = 0, len = attrMap.length; i < len; ++i) {
            attrNode = attrMap.item(i);
            output.push(' ', attrNode.name, '="', escape$1(attrNode.value, ATTR_ENTITIES), '"');
          }
        }

        if (node.hasChildNodes()) {
          output.push('>');
          childNodes = node.childNodes;
          for (i = 0, len = childNodes.length; i < len; ++i) {
            serialize(childNodes.item(i), output);
          }
          output.push('</', node.tagName, '>');
        } else {
          output.push('/>');
        }
        break;

      // COMMENT
      case 8:
        output.push('<!--', escape$1(node.nodeValue, TEXT_ENTITIES), '-->');
        break;

      // CDATA
      case 4:
        output.push('<![CDATA[', node.nodeValue, ']]>');
        break;

      default:
        throw new Error('unable to handle node ' + node.nodeType);
    }

    return output;
  }

  /**
   * innerHTML like functionality for SVG elements.
   * based on innerSVG (https://code.google.com/p/innersvg)
   */

  function set(element, svg) {

    var node,
        documentElement = parse$2(svg).documentElement;

    // clear element contents
    clear$1(element);

    if (!svg) {
      return;
    }

    // import + append each node
    node = documentElement.firstChild;

    while (node) {
      appendTo(node, element);
      node = node.nextSibling;
    }
  }

  function get(element) {
    var child = element.firstChild,
        output = [];

    while (child) {
      serialize(child, output);
      child = child.nextSibling;
    }

    return output.join('');
  }

  function innerSVG(element, svg) {

    if (svg !== undefined) {

      try {
        set(element, svg);
      } catch (e) {
        throw new Error('error parsing SVG: ' + e.message);
      }

      return element;
    } else {
      return get(element);
    }
  }

  /**
   * transform accessor utility
   */

  function wrapMatrix(transformList, transform) {
    if (transform instanceof SVGMatrix) {
      return transformList.createSVGTransformFromMatrix(transform);
    } else {
      return transform;
    }
  }

  function setTransforms(transformList, transforms) {
    var i, t;

    transformList.clear();

    for (i = 0; t = transforms[i]; i++) {
      transformList.appendItem(wrapMatrix(transformList, t));
    }

    transformList.consolidate();
  }

  function transform(node, transforms) {
    var transformList = node.transform.baseVal;

    if (arguments.length === 1) {
      return transformList.consolidate();
    } else {
      if (transforms.length) {
        setTransforms(transformList, transforms);
      } else {
        transformList.initialize(wrapMatrix(transformList, transforms));
      }
    }
  }

  function componentsToPath(elements) {
    return elements.join(',').replace(/,?([A-z]),?/g, '$1');
  }

  function toSVGPoints(points) {
    var result = '';

    for (var i = 0, p; p = points[i]; i++) {
      result += p.x + ',' + p.y + ' ';
    }

    return result;
  }

  function createLine(points, attrs) {

    var line = create('polyline');
    attr$1(line, { points: toSVGPoints(points) });

    if (attrs) {
      attr$1(line, attrs);
    }

    return line;
  }

  function updateLine(gfx, points) {
    attr$1(gfx, { points: toSVGPoints(points) });

    return gfx;
  }

  // apply default renderer with lowest possible priority
  // so that it only kicks in if noone else could render
  var DEFAULT_RENDER_PRIORITY$1 = 1;

  /**
   * The default renderer used for shapes and connections.
   *
   * @param {EventBus} eventBus
   * @param {Styles} styles
   */
  function DefaultRenderer(eventBus, styles) {
    //
    BaseRenderer.call(this, eventBus, DEFAULT_RENDER_PRIORITY$1);

    this.CONNECTION_STYLE = styles.style(['no-fill'], { strokeWidth: 5, stroke: 'fuchsia' });
    this.SHAPE_STYLE = styles.style({ fill: 'white', stroke: 'fuchsia', strokeWidth: 2 });
  }

  inherits_browser(DefaultRenderer, BaseRenderer);

  DefaultRenderer.prototype.canRender = function () {
    return true;
  };

  DefaultRenderer.prototype.drawShape = function drawShape(visuals, element) {

    var rect = create('rect');
    attr$1(rect, {
      x: 0,
      y: 0,
      width: element.width || 0,
      height: element.height || 0
    });
    attr$1(rect, this.SHAPE_STYLE);

    append(visuals, rect);

    return rect;
  };

  DefaultRenderer.prototype.drawConnection = function drawConnection(visuals, connection) {

    var line = createLine(connection.waypoints, this.CONNECTION_STYLE);
    append(visuals, line);

    return line;
  };

  DefaultRenderer.prototype.getShapePath = function getShapePath(shape) {

    var x = shape.x,
        y = shape.y,
        width = shape.width,
        height = shape.height;

    var shapePath = [['M', x, y], ['l', width, 0], ['l', 0, height], ['l', -width, 0], ['z']];

    return componentsToPath(shapePath);
  };

  DefaultRenderer.prototype.getConnectionPath = function getConnectionPath(connection) {
    var waypoints = connection.waypoints;

    var idx,
        point,
        connectionPath = [];

    for (idx = 0; point = waypoints[idx]; idx++) {

      // take invisible docking into account
      // when creating the path
      point = point.original || point;

      connectionPath.push([idx === 0 ? 'M' : 'L', point.x, point.y]);
    }

    return componentsToPath(connectionPath);
  };

  DefaultRenderer.$inject = ['eventBus', 'styles'];

  /**
   * A component that manages shape styles
   */
  function Styles() {

    var defaultTraits = {

      'no-fill': {
        fill: 'none'
      },
      'no-border': {
        strokeOpacity: 0.0
      },
      'no-events': {
        pointerEvents: 'none'
      }
    };

    var self = this;

    /**
     * Builds a style definition from a className, a list of traits and an object of additional attributes.
     *
     * @param  {String} className
     * @param  {Array<String>} traits
     * @param  {Object} additionalAttrs
     *
     * @return {Object} the style defintion
     */
    this.cls = function (className, traits, additionalAttrs) {
      var attrs = this.style(traits, additionalAttrs);

      return assign(attrs, { 'class': className });
    };

    /**
     * Builds a style definition from a list of traits and an object of additional attributes.
     *
     * @param  {Array<String>} traits
     * @param  {Object} additionalAttrs
     *
     * @return {Object} the style defintion
     */
    this.style = function (traits, additionalAttrs) {

      if (!isArray(traits) && !additionalAttrs) {
        additionalAttrs = traits;
        traits = [];
      }

      var attrs = reduce(traits, function (attrs, t) {
        return assign(attrs, defaultTraits[t] || {});
      }, {});

      return additionalAttrs ? assign(attrs, additionalAttrs) : attrs;
    };

    this.computeStyle = function (custom, traits, defaultStyles) {
      if (!isArray(traits)) {
        defaultStyles = traits;
        traits = [];
      }

      return self.style(traits || [], assign({}, defaultStyles, custom || {}));
    };
  }

  var DrawModule = {
    __init__: ['defaultRenderer'],
    defaultRenderer: ['type', DefaultRenderer],
    styles: ['type', Styles]
  };

  /**
   * Failsafe remove an element from a collection
   *
   * @param  {Array<Object>} [collection]
   * @param  {Object} [element]
   *
   * @return {Number} the previous index of the element
   */
  function remove$2(collection, element) {

    if (!collection || !element) {
      return -1;
    }

    var idx = collection.indexOf(element);

    if (idx !== -1) {
      collection.splice(idx, 1);
    }

    return idx;
  }

  /**
   * Fail save add an element to the given connection, ensuring
   * it does not yet exist.
   *
   * @param {Array<Object>} collection
   * @param {Object} element
   * @param {Number} idx
   */
  function add(collection, element, idx) {

    if (!collection || !element) {
      return;
    }

    if (typeof idx !== 'number') {
      idx = -1;
    }

    var currentIdx = collection.indexOf(element);

    if (currentIdx !== -1) {

      if (currentIdx === idx) {
        // nothing to do, position has not changed
        return;
      } else {

        if (idx !== -1) {
          // remove from current position
          collection.splice(currentIdx, 1);
        } else {
          // already exists in collection
          return;
        }
      }
    }

    if (idx !== -1) {
      // insert at specified position
      collection.splice(idx, 0, element);
    } else {
      // push to end
      collection.push(element);
    }
  }

  /**
   * Fail save get the index of an element in a collection.
   *
   * @param {Array<Object>} collection
   * @param {Object} element
   *
   * @return {Number} the index or -1 if collection or element do
   *                  not exist or the element is not contained.
   */
  function indexOf$1(collection, element) {

    if (!collection || !element) {
      return -1;
    }

    return collection.indexOf(element);
  }

  /**
   * Adds an element to a collection and returns true if the
   * element was added.
   *
   * @param {Array<Object>} elements
   * @param {Object} e
   * @param {Boolean} unique
   */
  function add$1(elements, e, unique) {
    var canAdd = !unique || elements.indexOf(e) === -1;

    if (canAdd) {
      elements.push(e);
    }

    return canAdd;
  }

  /**
   * Iterate over each element in a collection, calling the iterator function `fn`
   * with (element, index, recursionDepth).
   *
   * Recurse into all elements that are returned by `fn`.
   *
   * @param  {Object|Array<Object>} elements
   * @param  {Function} fn iterator function called with (element, index, recursionDepth)
   * @param  {Number} [depth] maximum recursion depth
   */
  function eachElement(elements, fn, depth) {

    depth = depth || 0;

    if (!isArray(elements)) {
      elements = [elements];
    }

    forEach(elements, function (s, i) {
      var filter$$1 = fn(s, i, depth);

      if (isArray(filter$$1) && filter$$1.length) {
        eachElement(filter$$1, fn, depth + 1);
      }
    });
  }

  /**
   * Collects self + child elements up to a given depth from a list of elements.
   *
   * @param  {djs.model.Base|Array<djs.model.Base>} elements the elements to select the children from
   * @param  {Boolean} unique whether to return a unique result set (no duplicates)
   * @param  {Number} maxDepth the depth to search through or -1 for infinite
   *
   * @return {Array<djs.model.Base>} found elements
   */
  function selfAndChildren(elements, unique, maxDepth) {
    var result = [],
        processedChildren = [];

    eachElement(elements, function (element, i, depth) {
      add$1(result, element, unique);

      var children = element.children;

      // max traversal depth not reached yet
      if (maxDepth === -1 || depth < maxDepth) {

        // children exist && children not yet processed
        if (children && add$1(processedChildren, children, unique)) {
          return children;
        }
      }
    });

    return result;
  }

  /**
   * Return self + ALL children for a number of elements
   *
   * @param  {Array<djs.model.Base>} elements to query
   * @param  {Boolean} allowDuplicates to allow duplicates in the result set
   *
   * @return {Array<djs.model.Base>} the collected elements
   */
  function selfAndAllChildren(elements, allowDuplicates) {
    return selfAndChildren(elements, !allowDuplicates, -1);
  }

  /**
   * Gets the the closure for all selected elements,
   * their enclosed children and connections.
   *
   * @param {Array<djs.model.Base>} elements
   * @param {Boolean} [isTopLevel=true]
   * @param {Object} [existingClosure]
   *
   * @return {Object} newClosure
   */
  function getClosure(elements, isTopLevel, closure) {

    if (isUndefined(isTopLevel)) {
      isTopLevel = true;
    }

    if (isObject(isTopLevel)) {
      closure = isTopLevel;
      isTopLevel = true;
    }

    closure = closure || {};

    var allShapes = copyObject(closure.allShapes),
        allConnections = copyObject(closure.allConnections),
        enclosedElements = copyObject(closure.enclosedElements),
        enclosedConnections = copyObject(closure.enclosedConnections);

    var topLevel = copyObject(closure.topLevel, isTopLevel && groupBy(elements, function (e) {
      return e.id;
    }));

    function handleConnection(c) {
      if (topLevel[c.source.id] && topLevel[c.target.id]) {
        topLevel[c.id] = [c];
      }

      // not enclosed as a child, but maybe logically
      // (connecting two moved elements?)
      if (allShapes[c.source.id] && allShapes[c.target.id]) {
        enclosedConnections[c.id] = enclosedElements[c.id] = c;
      }

      allConnections[c.id] = c;
    }

    function handleElement(element) {

      enclosedElements[element.id] = element;

      if (element.waypoints) {
        // remember connection
        enclosedConnections[element.id] = allConnections[element.id] = element;
      } else {
        // remember shape
        allShapes[element.id] = element;

        // remember all connections
        forEach(element.incoming, handleConnection);

        forEach(element.outgoing, handleConnection);

        // recurse into children
        return element.children;
      }
    }

    eachElement(elements, handleElement);

    return {
      allShapes: allShapes,
      allConnections: allConnections,
      topLevel: topLevel,
      enclosedConnections: enclosedConnections,
      enclosedElements: enclosedElements
    };
  }

  /**
   * Returns the surrounding bbox for all elements in
   * the array or the element primitive.
   *
   * @param {Array<djs.model.Shape>|djs.model.Shape} elements
   * @param {Boolean} stopRecursion
   */
  function getBBox(elements, stopRecursion) {

    stopRecursion = !!stopRecursion;
    if (!isArray(elements)) {
      elements = [elements];
    }

    var minX, minY, maxX, maxY;

    forEach(elements, function (element) {

      // If element is a connection the bbox must be computed first
      var bbox = element;
      if (element.waypoints && !stopRecursion) {
        bbox = getBBox(element.waypoints, true);
      }

      var x = bbox.x,
          y = bbox.y,
          height = bbox.height || 0,
          width = bbox.width || 0;

      if (x < minX || minX === undefined) {
        minX = x;
      }
      if (y < minY || minY === undefined) {
        minY = y;
      }

      if (x + width > maxX || maxX === undefined) {
        maxX = x + width;
      }
      if (y + height > maxY || maxY === undefined) {
        maxY = y + height;
      }
    });

    return {
      x: minX,
      y: minY,
      height: maxY - minY,
      width: maxX - minX
    };
  }

  /**
   * Returns all elements that are enclosed from the bounding box.
   *
   *   * If bbox.(width|height) is not specified the method returns
   *     all elements with element.x/y > bbox.x/y
   *   * If only bbox.x or bbox.y is specified, method return all elements with
   *     e.x > bbox.x or e.y > bbox.y
   *
   * @param {Array<djs.model.Shape>} elements List of Elements to search through
   * @param {djs.model.Shape} bbox the enclosing bbox.
   *
   * @return {Array<djs.model.Shape>} enclosed elements
   */
  function getEnclosedElements(elements, bbox) {

    var filteredElements = {};

    forEach(elements, function (element) {

      var e = element;

      if (e.waypoints) {
        e = getBBox(e);
      }

      if (!isNumber(bbox.y) && e.x > bbox.x) {
        filteredElements[element.id] = element;
      }
      if (!isNumber(bbox.x) && e.y > bbox.y) {
        filteredElements[element.id] = element;
      }
      if (e.x > bbox.x && e.y > bbox.y) {
        if (isNumber(bbox.width) && isNumber(bbox.height) && e.width + e.x < bbox.width + bbox.x && e.height + e.y < bbox.height + bbox.y) {

          filteredElements[element.id] = element;
        } else if (!isNumber(bbox.width) || !isNumber(bbox.height)) {
          filteredElements[element.id] = element;
        }
      }
    });

    return filteredElements;
  }

  function getType(element) {

    if ('waypoints' in element) {
      return 'connection';
    }

    if ('x' in element) {
      return 'shape';
    }

    return 'root';
  }

  // helpers ///////////////////////////////

  function copyObject(src1, src2) {
    return assign({}, src1 || {}, src2 || {});
  }

  var _typeof$5 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  function round(number, resolution) {
    return Math.round(number * resolution) / resolution;
  }

  function ensurePx(number) {
    return isNumber(number) ? number + 'px' : number;
  }

  /**
   * Creates a HTML container element for a SVG element with
   * the given configuration
   *
   * @param  {Object} options
   * @return {HTMLElement} the container element
   */
  function createContainer(options) {

    options = assign({}, { width: '100%', height: '100%' }, options);

    var container = options.container || document.body;

    // create a <div> around the svg element with the respective size
    // this way we can always get the correct container size
    // (this is impossible for <svg> elements at the moment)
    var parent = document.createElement('div');
    parent.setAttribute('class', 'djs-container');

    assign(parent.style, {
      position: 'relative',
      overflow: 'hidden',
      width: ensurePx(options.width),
      height: ensurePx(options.height)
    });

    container.appendChild(parent);

    return parent;
  }

  function createGroup(parent, cls, childIndex) {
    var group = create('g');
    classes$1(group).add(cls);

    var index = childIndex !== undefined ? childIndex : parent.childNodes.length - 1;

    // must ensure second argument is node or _null_
    // cf. https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore
    parent.insertBefore(group, parent.childNodes[index] || null);

    return group;
  }

  var BASE_LAYER = 'base';

  var REQUIRED_MODEL_ATTRS = {
    shape: ['x', 'y', 'width', 'height'],
    connection: ['waypoints']
  };

  /**
   * The main drawing canvas.
   *
   * @class
   * @constructor
   *
   * @emits Canvas#canvas.init
   *
   * @param {Object} config
   * @param {EventBus} eventBus
   * @param {GraphicsFactory} graphicsFactory
   * @param {ElementRegistry} elementRegistry
   */
  function Canvas(config, eventBus, graphicsFactory, elementRegistry) {

    this._eventBus = eventBus;
    this._elementRegistry = elementRegistry;
    this._graphicsFactory = graphicsFactory;

    this._init(config || {});
  }

  Canvas.$inject = ['config.canvas', 'eventBus', 'graphicsFactory', 'elementRegistry'];

  Canvas.prototype._init = function (config) {

    var eventBus = this._eventBus;

    // Creates a <svg> element that is wrapped into a <div>.
    // This way we are always able to correctly figure out the size of the svg element
    // by querying the parent node.
    //
    // (It is not possible to get the size of a svg element cross browser @ 2014-04-01)
    //
    // <div class="djs-container" style="width: {desired-width}, height: {desired-height}">
    //   <svg width="100%" height="100%">
    //    ...
    //   </svg>
    // </div>

    // html container
    var container = this._container = createContainer(config);

    var svg = this._svg = create('svg');
    attr$1(svg, { width: '100%', height: '100%' });

    append(container, svg);

    var viewport = this._viewport = createGroup(svg, 'viewport');

    this._layers = {};

    // debounce canvas.viewbox.changed events
    // for smoother diagram interaction
    if (config.deferUpdate !== false) {
      this._viewboxChanged = debounce(bind(this._viewboxChanged, this), 300);
    }

    eventBus.on('diagram.init', function () {

      /**
       * An event indicating that the canvas is ready to be drawn on.
       *
       * @memberOf Canvas
       *
       * @event canvas.init
       *
       * @type {Object}
       * @property {SVGElement} svg the created svg element
       * @property {SVGElement} viewport the direct parent of diagram elements and shapes
       */
      eventBus.fire('canvas.init', {
        svg: svg,
        viewport: viewport
      });
    }, this);

    // reset viewbox on shape changes to
    // recompute the viewbox
    eventBus.on(['shape.added', 'connection.added', 'shape.removed', 'connection.removed', 'elements.changed'], function () {
      delete this._cachedViewbox;
    }, this);

    eventBus.on('diagram.destroy', 500, this._destroy, this);
    eventBus.on('diagram.clear', 500, this._clear, this);
  };

  Canvas.prototype._destroy = function (emit) {
    this._eventBus.fire('canvas.destroy', {
      svg: this._svg,
      viewport: this._viewport
    });

    var parent = this._container.parentNode;

    if (parent) {
      parent.removeChild(this._container);
    }

    delete this._svg;
    delete this._container;
    delete this._layers;
    delete this._rootElement;
    delete this._viewport;
  };

  Canvas.prototype._clear = function () {

    var self = this;

    var allElements = this._elementRegistry.getAll();

    // remove all elements
    allElements.forEach(function (element) {
      var type = getType(element);

      if (type === 'root') {
        self.setRootElement(null, true);
      } else {
        self._removeElement(element, type);
      }
    });

    // force recomputation of view box
    delete this._cachedViewbox;
  };

  /**
   * Returns the default layer on which
   * all elements are drawn.
   *
   * @returns {SVGElement}
   */
  Canvas.prototype.getDefaultLayer = function () {
    return this.getLayer(BASE_LAYER, 0);
  };

  /**
   * Returns a layer that is used to draw elements
   * or annotations on it.
   *
   * Non-existing layers retrieved through this method
   * will be created. During creation, the optional index
   * may be used to create layers below or above existing layers.
   * A layer with a certain index is always created above all
   * existing layers with the same index.
   *
   * @param {String} name
   * @param {Number} index
   *
   * @returns {SVGElement}
   */
  Canvas.prototype.getLayer = function (name, index) {

    if (!name) {
      throw new Error('must specify a name');
    }

    var layer = this._layers[name];

    if (!layer) {
      layer = this._layers[name] = this._createLayer(name, index);
    }

    // throw an error if layer creation / retrival is
    // requested on different index
    if (typeof index !== 'undefined' && layer.index !== index) {
      throw new Error('layer <' + name + '> already created at index <' + index + '>');
    }

    return layer.group;
  };

  /**
   * Creates a given layer and returns it.
   *
   * @param {String} name
   * @param {Number} [index=0]
   *
   * @return {Object} layer descriptor with { index, group: SVGGroup }
   */
  Canvas.prototype._createLayer = function (name, index) {

    if (!index) {
      index = 0;
    }

    var childIndex = reduce(this._layers, function (childIndex, layer) {
      if (index >= layer.index) {
        childIndex++;
      }

      return childIndex;
    }, 0);

    return {
      group: createGroup(this._viewport, 'layer-' + name, childIndex),
      index: index
    };
  };

  /**
   * Returns the html element that encloses the
   * drawing canvas.
   *
   * @return {DOMNode}
   */
  Canvas.prototype.getContainer = function () {
    return this._container;
  };

  // markers //////////////////////

  Canvas.prototype._updateMarker = function (element, marker, add$$1) {
    var container;

    if (!element.id) {
      element = this._elementRegistry.get(element);
    }

    // we need to access all
    container = this._elementRegistry._elements[element.id];

    if (!container) {
      return;
    }

    forEach([container.gfx, container.secondaryGfx], function (gfx) {
      if (gfx) {
        // invoke either addClass or removeClass based on mode
        if (add$$1) {
          classes$1(gfx).add(marker);
        } else {
          classes$1(gfx).remove(marker);
        }
      }
    });

    /**
     * An event indicating that a marker has been updated for an element
     *
     * @event element.marker.update
     * @type {Object}
     * @property {djs.model.Element} element the shape
     * @property {Object} gfx the graphical representation of the shape
     * @property {String} marker
     * @property {Boolean} add true if the marker was added, false if it got removed
     */
    this._eventBus.fire('element.marker.update', { element: element, gfx: container.gfx, marker: marker, add: !!add$$1 });
  };

  /**
   * Adds a marker to an element (basically a css class).
   *
   * Fires the element.marker.update event, making it possible to
   * integrate extension into the marker life-cycle, too.
   *
   * @example
   * canvas.addMarker('foo', 'some-marker');
   *
   * var fooGfx = canvas.getGraphics('foo');
   *
   * fooGfx; // <g class="... some-marker"> ... </g>
   *
   * @param {String|djs.model.Base} element
   * @param {String} marker
   */
  Canvas.prototype.addMarker = function (element, marker) {
    this._updateMarker(element, marker, true);
  };

  /**
   * Remove a marker from an element.
   *
   * Fires the element.marker.update event, making it possible to
   * integrate extension into the marker life-cycle, too.
   *
   * @param  {String|djs.model.Base} element
   * @param  {String} marker
   */
  Canvas.prototype.removeMarker = function (element, marker) {
    this._updateMarker(element, marker, false);
  };

  /**
   * Check the existence of a marker on element.
   *
   * @param  {String|djs.model.Base} element
   * @param  {String} marker
   */
  Canvas.prototype.hasMarker = function (element, marker) {
    if (!element.id) {
      element = this._elementRegistry.get(element);
    }

    var gfx = this.getGraphics(element);

    return classes$1(gfx).has(marker);
  };

  /**
   * Toggles a marker on an element.
   *
   * Fires the element.marker.update event, making it possible to
   * integrate extension into the marker life-cycle, too.
   *
   * @param  {String|djs.model.Base} element
   * @param  {String} marker
   */
  Canvas.prototype.toggleMarker = function (element, marker) {
    if (this.hasMarker(element, marker)) {
      this.removeMarker(element, marker);
    } else {
      this.addMarker(element, marker);
    }
  };

  Canvas.prototype.getRootElement = function () {
    if (!this._rootElement) {
      this.setRootElement({ id: '__implicitroot', children: [] });
    }

    return this._rootElement;
  };

  // root element handling //////////////////////

  /**
   * Sets a given element as the new root element for the canvas
   * and returns the new root element.
   *
   * @param {Object|djs.model.Root} element
   * @param {Boolean} [override] whether to override the current root element, if any
   *
   * @return {Object|djs.model.Root} new root element
   */
  Canvas.prototype.setRootElement = function (element, override) {

    if (element) {
      this._ensureValid('root', element);
    }

    var currentRoot = this._rootElement,
        elementRegistry = this._elementRegistry,
        eventBus = this._eventBus;

    if (currentRoot) {
      if (!override) {
        throw new Error('rootElement already set, need to specify override');
      }

      // simulate element remove event sequence
      eventBus.fire('root.remove', { element: currentRoot });
      eventBus.fire('root.removed', { element: currentRoot });

      elementRegistry.remove(currentRoot);
    }

    if (element) {
      var gfx = this.getDefaultLayer();

      // resemble element add event sequence
      eventBus.fire('root.add', { element: element });

      elementRegistry.add(element, gfx, this._svg);

      eventBus.fire('root.added', { element: element, gfx: gfx });
    }

    this._rootElement = element;

    return element;
  };

  // add functionality //////////////////////

  Canvas.prototype._ensureValid = function (type, element) {
    if (!element.id) {
      throw new Error('element must have an id');
    }

    if (this._elementRegistry.get(element.id)) {
      throw new Error('element with id ' + element.id + ' already exists');
    }

    var requiredAttrs = REQUIRED_MODEL_ATTRS[type];

    var valid = every(requiredAttrs, function (attr$$1) {
      return typeof element[attr$$1] !== 'undefined';
    });

    if (!valid) {
      throw new Error('must supply { ' + requiredAttrs.join(', ') + ' } with ' + type);
    }
  };

  Canvas.prototype._setParent = function (element, parent, parentIndex) {
    add(parent.children, element, parentIndex);
    element.parent = parent;
  };

  /**
   * Adds an element to the canvas.
   *
   * This wires the parent <-> child relationship between the element and
   * a explicitly specified parent or an implicit root element.
   *
   * During add it emits the events
   *
   *  * <{type}.add> (element, parent)
   *  * <{type}.added> (element, gfx)
   *
   * Extensions may hook into these events to perform their magic.
   *
   * @param {String} type
   * @param {Object|djs.model.Base} element
   * @param {Object|djs.model.Base} [parent]
   * @param {Number} [parentIndex]
   *
   * @return {Object|djs.model.Base} the added element
   */
  Canvas.prototype._addElement = function (type, element, parent, parentIndex) {

    parent = parent || this.getRootElement();

    var eventBus = this._eventBus,
        graphicsFactory = this._graphicsFactory;

    this._ensureValid(type, element);

    eventBus.fire(type + '.add', { element: element, parent: parent });

    this._setParent(element, parent, parentIndex);

    // create graphics
    var gfx = graphicsFactory.create(type, element, parentIndex);

    this._elementRegistry.add(element, gfx);

    // update its visual
    graphicsFactory.update(type, element, gfx);

    eventBus.fire(type + '.added', { element: element, gfx: gfx });

    return element;
  };

  /**
   * Adds a shape to the canvas
   *
   * @param {Object|djs.model.Shape} shape to add to the diagram
   * @param {djs.model.Base} [parent]
   * @param {Number} [parentIndex]
   *
   * @return {djs.model.Shape} the added shape
   */
  Canvas.prototype.addShape = function (shape, parent, parentIndex) {
    return this._addElement('shape', shape, parent, parentIndex);
  };

  /**
   * Adds a connection to the canvas
   *
   * @param {Object|djs.model.Connection} connection to add to the diagram
   * @param {djs.model.Base} [parent]
   * @param {Number} [parentIndex]
   *
   * @return {djs.model.Connection} the added connection
   */
  Canvas.prototype.addConnection = function (connection, parent, parentIndex) {
    return this._addElement('connection', connection, parent, parentIndex);
  };

  /**
   * Internal remove element
   */
  Canvas.prototype._removeElement = function (element, type) {

    var elementRegistry = this._elementRegistry,
        graphicsFactory = this._graphicsFactory,
        eventBus = this._eventBus;

    element = elementRegistry.get(element.id || element);

    if (!element) {
      // element was removed already
      return;
    }

    eventBus.fire(type + '.remove', { element: element });

    graphicsFactory.remove(element);

    // unset parent <-> child relationship
    remove$2(element.parent && element.parent.children, element);
    element.parent = null;

    eventBus.fire(type + '.removed', { element: element });

    elementRegistry.remove(element);

    return element;
  };

  /**
   * Removes a shape from the canvas
   *
   * @param {String|djs.model.Shape} shape or shape id to be removed
   *
   * @return {djs.model.Shape} the removed shape
   */
  Canvas.prototype.removeShape = function (shape) {

    /**
     * An event indicating that a shape is about to be removed from the canvas.
     *
     * @memberOf Canvas
     *
     * @event shape.remove
     * @type {Object}
     * @property {djs.model.Shape} element the shape descriptor
     * @property {Object} gfx the graphical representation of the shape
     */

    /**
     * An event indicating that a shape has been removed from the canvas.
     *
     * @memberOf Canvas
     *
     * @event shape.removed
     * @type {Object}
     * @property {djs.model.Shape} element the shape descriptor
     * @property {Object} gfx the graphical representation of the shape
     */
    return this._removeElement(shape, 'shape');
  };

  /**
   * Removes a connection from the canvas
   *
   * @param {String|djs.model.Connection} connection or connection id to be removed
   *
   * @return {djs.model.Connection} the removed connection
   */
  Canvas.prototype.removeConnection = function (connection) {

    /**
     * An event indicating that a connection is about to be removed from the canvas.
     *
     * @memberOf Canvas
     *
     * @event connection.remove
     * @type {Object}
     * @property {djs.model.Connection} element the connection descriptor
     * @property {Object} gfx the graphical representation of the connection
     */

    /**
     * An event indicating that a connection has been removed from the canvas.
     *
     * @memberOf Canvas
     *
     * @event connection.removed
     * @type {Object}
     * @property {djs.model.Connection} element the connection descriptor
     * @property {Object} gfx the graphical representation of the connection
     */
    return this._removeElement(connection, 'connection');
  };

  /**
   * Return the graphical object underlaying a certain diagram element
   *
   * @param {String|djs.model.Base} element descriptor of the element
   * @param {Boolean} [secondary=false] whether to return the secondary connected element
   *
   * @return {SVGElement}
   */
  Canvas.prototype.getGraphics = function (element, secondary) {
    return this._elementRegistry.getGraphics(element, secondary);
  };

  /**
   * Perform a viewbox update via a given change function.
   *
   * @param {Function} changeFn
   */
  Canvas.prototype._changeViewbox = function (changeFn) {

    // notify others of the upcoming viewbox change
    this._eventBus.fire('canvas.viewbox.changing');

    // perform actual change
    changeFn.apply(this);

    // reset the cached viewbox so that
    // a new get operation on viewbox or zoom
    // triggers a viewbox re-computation
    this._cachedViewbox = null;

    // notify others of the change; this step
    // may or may not be debounced
    this._viewboxChanged();
  };

  Canvas.prototype._viewboxChanged = function () {
    this._eventBus.fire('canvas.viewbox.changed', { viewbox: this.viewbox() });
  };

  /**
   * Gets or sets the view box of the canvas, i.e. the
   * area that is currently displayed.
   *
   * The getter may return a cached viewbox (if it is currently
   * changing). To force a recomputation, pass `false` as the first argument.
   *
   * @example
   *
   * canvas.viewbox({ x: 100, y: 100, width: 500, height: 500 })
   *
   * // sets the visible area of the diagram to (100|100) -> (600|100)
   * // and and scales it according to the diagram width
   *
   * var viewbox = canvas.viewbox(); // pass `false` to force recomputing the box.
   *
   * console.log(viewbox);
   * // {
   * //   inner: Dimensions,
   * //   outer: Dimensions,
   * //   scale,
   * //   x, y,
   * //   width, height
   * // }
   *
   * // if the current diagram is zoomed and scrolled, you may reset it to the
   * // default zoom via this method, too:
   *
   * var zoomedAndScrolledViewbox = canvas.viewbox();
   *
   * canvas.viewbox({
   *   x: 0,
   *   y: 0,
   *   width: zoomedAndScrolledViewbox.outer.width,
   *   height: zoomedAndScrolledViewbox.outer.height
   * });
   *
   * @param  {Object} [box] the new view box to set
   * @param  {Number} box.x the top left X coordinate of the canvas visible in view box
   * @param  {Number} box.y the top left Y coordinate of the canvas visible in view box
   * @param  {Number} box.width the visible width
   * @param  {Number} box.height
   *
   * @return {Object} the current view box
   */
  Canvas.prototype.viewbox = function (box) {

    if (box === undefined && this._cachedViewbox) {
      return this._cachedViewbox;
    }

    var viewport = this._viewport,
        innerBox,
        outerBox = this.getSize(),
        matrix,
        transform$$1,
        scale,
        x,
        y;

    if (!box) {
      // compute the inner box based on the
      // diagrams default layer. This allows us to exclude
      // external components, such as overlays
      innerBox = this.getDefaultLayer().getBBox();

      transform$$1 = transform(viewport);
      matrix = transform$$1 ? transform$$1.matrix : createMatrix();
      scale = round(matrix.a, 1000);

      x = round(-matrix.e || 0, 1000);
      y = round(-matrix.f || 0, 1000);

      box = this._cachedViewbox = {
        x: x ? x / scale : 0,
        y: y ? y / scale : 0,
        width: outerBox.width / scale,
        height: outerBox.height / scale,
        scale: scale,
        inner: {
          width: innerBox.width,
          height: innerBox.height,
          x: innerBox.x,
          y: innerBox.y
        },
        outer: outerBox
      };

      return box;
    } else {

      this._changeViewbox(function () {
        scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);

        var matrix = this._svg.createSVGMatrix().scale(scale).translate(-box.x, -box.y);

        transform(viewport, matrix);
      });
    }

    return box;
  };

  /**
   * Gets or sets the scroll of the canvas.
   *
   * @param {Object} [delta] the new scroll to apply.
   *
   * @param {Number} [delta.dx]
   * @param {Number} [delta.dy]
   */
  Canvas.prototype.scroll = function (delta) {

    var node = this._viewport;
    var matrix = node.getCTM();

    if (delta) {
      this._changeViewbox(function () {
        delta = assign({ dx: 0, dy: 0 }, delta || {});

        matrix = this._svg.createSVGMatrix().translate(delta.dx, delta.dy).multiply(matrix);

        setCTM(node, matrix);
      });
    }

    return { x: matrix.e, y: matrix.f };
  };

  /**
   * Gets or sets the current zoom of the canvas, optionally zooming
   * to the specified position.
   *
   * The getter may return a cached zoom level. Call it with `false` as
   * the first argument to force recomputation of the current level.
   *
   * @param {String|Number} [newScale] the new zoom level, either a number, i.e. 0.9,
   *                                   or `fit-viewport` to adjust the size to fit the current viewport
   * @param {String|Point} [center] the reference point { x: .., y: ..} to zoom to, 'auto' to zoom into mid or null
   *
   * @return {Number} the current scale
   */
  Canvas.prototype.zoom = function (newScale, center) {

    if (!newScale) {
      return this.viewbox(newScale).scale;
    }

    if (newScale === 'fit-viewport') {
      return this._fitViewport(center);
    }

    var outer, matrix;

    this._changeViewbox(function () {

      if ((typeof center === 'undefined' ? 'undefined' : _typeof$5(center)) !== 'object') {
        outer = this.viewbox().outer;

        center = {
          x: outer.width / 2,
          y: outer.height / 2
        };
      }

      matrix = this._setZoom(newScale, center);
    });

    return round(matrix.a, 1000);
  };

  function setCTM(node, m) {
    var mstr = 'matrix(' + m.a + ',' + m.b + ',' + m.c + ',' + m.d + ',' + m.e + ',' + m.f + ')';
    node.setAttribute('transform', mstr);
  }

  Canvas.prototype._fitViewport = function (center) {

    var vbox = this.viewbox(),
        outer = vbox.outer,
        inner = vbox.inner,
        newScale,
        newViewbox;

    // display the complete diagram without zooming in.
    // instead of relying on internal zoom, we perform a
    // hard reset on the canvas viewbox to realize this
    //
    // if diagram does not need to be zoomed in, we focus it around
    // the diagram origin instead

    if (inner.x >= 0 && inner.y >= 0 && inner.x + inner.width <= outer.width && inner.y + inner.height <= outer.height && !center) {

      newViewbox = {
        x: 0,
        y: 0,
        width: Math.max(inner.width + inner.x, outer.width),
        height: Math.max(inner.height + inner.y, outer.height)
      };
    } else {

      newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);
      newViewbox = {
        x: inner.x + (center ? inner.width / 2 - outer.width / newScale / 2 : 0),
        y: inner.y + (center ? inner.height / 2 - outer.height / newScale / 2 : 0),
        width: outer.width / newScale,
        height: outer.height / newScale
      };
    }

    this.viewbox(newViewbox);

    return this.viewbox(false).scale;
  };

  Canvas.prototype._setZoom = function (scale, center) {

    var svg = this._svg,
        viewport = this._viewport;

    var matrix = svg.createSVGMatrix();
    var point = svg.createSVGPoint();

    var centerPoint, originalPoint, currentMatrix, scaleMatrix, newMatrix;

    currentMatrix = viewport.getCTM();

    var currentScale = currentMatrix.a;

    if (center) {
      centerPoint = assign(point, center);

      // revert applied viewport transformations
      originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());

      // create scale matrix
      scaleMatrix = matrix.translate(originalPoint.x, originalPoint.y).scale(1 / currentScale * scale).translate(-originalPoint.x, -originalPoint.y);

      newMatrix = currentMatrix.multiply(scaleMatrix);
    } else {
      newMatrix = matrix.scale(scale);
    }

    setCTM(this._viewport, newMatrix);

    return newMatrix;
  };

  /**
   * Returns the size of the canvas
   *
   * @return {Dimensions}
   */
  Canvas.prototype.getSize = function () {
    return {
      width: this._container.clientWidth,
      height: this._container.clientHeight
    };
  };

  /**
   * Return the absolute bounding box for the given element
   *
   * The absolute bounding box may be used to display overlays in the
   * callers (browser) coordinate system rather than the zoomed in/out
   * canvas coordinates.
   *
   * @param  {ElementDescriptor} element
   * @return {Bounds} the absolute bounding box
   */
  Canvas.prototype.getAbsoluteBBox = function (element) {
    var vbox = this.viewbox();
    var bbox;

    // connection
    // use svg bbox
    if (element.waypoints) {
      var gfx = this.getGraphics(element);

      bbox = gfx.getBBox();
    }
    // shapes
    // use data
    else {
        bbox = element;
      }

    var x = bbox.x * vbox.scale - vbox.x * vbox.scale;
    var y = bbox.y * vbox.scale - vbox.y * vbox.scale;

    var width = bbox.width * vbox.scale;
    var height = bbox.height * vbox.scale;

    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  };

  /**
   * Fires an event in order other modules can react to the
   * canvas resizing
   */
  Canvas.prototype.resized = function () {

    // force recomputation of view box
    delete this._cachedViewbox;

    this._eventBus.fire('canvas.resized');
  };

  var ELEMENT_ID = 'data-element-id';

  /**
   * @class
   *
   * A registry that keeps track of all shapes in the diagram.
   */
  function ElementRegistry(eventBus) {
    this._elements = {};

    this._eventBus = eventBus;
  }

  ElementRegistry.$inject = ['eventBus'];

  /**
   * Register a pair of (element, gfx, (secondaryGfx)).
   *
   * @param {djs.model.Base} element
   * @param {SVGElement} gfx
   * @param {SVGElement} [secondaryGfx] optional other element to register, too
   */
  ElementRegistry.prototype.add = function (element, gfx, secondaryGfx) {

    var id = element.id;

    this._validateId(id);

    // associate dom node with element
    attr$1(gfx, ELEMENT_ID, id);

    if (secondaryGfx) {
      attr$1(secondaryGfx, ELEMENT_ID, id);
    }

    this._elements[id] = { element: element, gfx: gfx, secondaryGfx: secondaryGfx };
  };

  /**
   * Removes an element from the registry.
   *
   * @param {djs.model.Base} element
   */
  ElementRegistry.prototype.remove = function (element) {
    var elements = this._elements,
        id = element.id || element,
        container = id && elements[id];

    if (container) {

      // unset element id on gfx
      attr$1(container.gfx, ELEMENT_ID, '');

      if (container.secondaryGfx) {
        attr$1(container.secondaryGfx, ELEMENT_ID, '');
      }

      delete elements[id];
    }
  };

  /**
   * Update the id of an element
   *
   * @param {djs.model.Base} element
   * @param {String} newId
   */
  ElementRegistry.prototype.updateId = function (element, newId) {

    this._validateId(newId);

    if (typeof element === 'string') {
      element = this.get(element);
    }

    this._eventBus.fire('element.updateId', {
      element: element,
      newId: newId
    });

    var gfx = this.getGraphics(element),
        secondaryGfx = this.getGraphics(element, true);

    this.remove(element);

    element.id = newId;

    this.add(element, gfx, secondaryGfx);
  };

  /**
   * Return the model element for a given id or graphics.
   *
   * @example
   *
   * elementRegistry.get('SomeElementId_1');
   * elementRegistry.get(gfx);
   *
   *
   * @param {String|SVGElement} filter for selecting the element
   *
   * @return {djs.model.Base}
   */
  ElementRegistry.prototype.get = function (filter) {
    var id;

    if (typeof filter === 'string') {
      id = filter;
    } else {
      id = filter && attr$1(filter, ELEMENT_ID);
    }

    var container = this._elements[id];
    return container && container.element;
  };

  /**
   * Return all elements that match a given filter function.
   *
   * @param {Function} fn
   *
   * @return {Array<djs.model.Base>}
   */
  ElementRegistry.prototype.filter = function (fn) {

    var filtered = [];

    this.forEach(function (element, gfx) {
      if (fn(element, gfx)) {
        filtered.push(element);
      }
    });

    return filtered;
  };

  /**
   * Return all rendered model elements.
   *
   * @return {Array<djs.model.Base>}
   */
  ElementRegistry.prototype.getAll = function () {
    return this.filter(function (e) {
      return e;
    });
  };

  /**
   * Iterate over all diagram elements.
   *
   * @param {Function} fn
   */
  ElementRegistry.prototype.forEach = function (fn) {

    var map = this._elements;

    Object.keys(map).forEach(function (id) {
      var container = map[id],
          element = container.element,
          gfx = container.gfx;

      return fn(element, gfx);
    });
  };

  /**
   * Return the graphical representation of an element or its id.
   *
   * @example
   * elementRegistry.getGraphics('SomeElementId_1');
   * elementRegistry.getGraphics(rootElement); // <g ...>
   *
   * elementRegistry.getGraphics(rootElement, true); // <svg ...>
   *
   *
   * @param {String|djs.model.Base} filter
   * @param {Boolean} [secondary=false] whether to return the secondary connected element
   *
   * @return {SVGElement}
   */
  ElementRegistry.prototype.getGraphics = function (filter, secondary) {
    var id = filter.id || filter;

    var container = this._elements[id];
    return container && (secondary ? container.secondaryGfx : container.gfx);
  };

  /**
   * Validate the suitability of the given id and signals a problem
   * with an exception.
   *
   * @param {String} id
   *
   * @throws {Error} if id is empty or already assigned
   */
  ElementRegistry.prototype._validateId = function (id) {
    if (!id) {
      throw new Error('element must have an id');
    }

    if (this._elements[id]) {
      throw new Error('element with id ' + id + ' already added');
    }
  };

  /**
   * An empty collection stub. Use {@link RefsCollection.extend} to extend a
   * collection with ref semantics.
   *
   * @class RefsCollection
   */

  /**
   * Extends a collection with {@link Refs} aware methods
   *
   * @memberof RefsCollection
   * @static
   *
   * @param  {Array<Object>} collection
   * @param  {Refs} refs instance
   * @param  {Object} property represented by the collection
   * @param  {Object} target object the collection is attached to
   *
   * @return {RefsCollection<Object>} the extended array
   */

  function extend$1(collection, refs, property, target) {

    var inverseProperty = property.inverse;

    /**
     * Removes the given element from the array and returns it.
     *
     * @method RefsCollection#remove
     *
     * @param {Object} element the element to remove
     */
    Object.defineProperty(collection, 'remove', {
      value: function value(element) {
        var idx = this.indexOf(element);
        if (idx !== -1) {
          this.splice(idx, 1);

          // unset inverse
          refs.unset(element, inverseProperty, target);
        }

        return element;
      }
    });

    /**
     * Returns true if the collection contains the given element
     *
     * @method RefsCollection#contains
     *
     * @param {Object} element the element to check for
     */
    Object.defineProperty(collection, 'contains', {
      value: function value(element) {
        return this.indexOf(element) !== -1;
      }
    });

    /**
     * Adds an element to the array, unless it exists already (set semantics).
     *
     * @method RefsCollection#add
     *
     * @param {Object} element the element to add
     * @param {Number} optional index to add element to
     *                 (possibly moving other elements around)
     */
    Object.defineProperty(collection, 'add', {
      value: function value(element, idx) {

        var currentIdx = this.indexOf(element);

        if (typeof idx === 'undefined') {

          if (currentIdx !== -1) {
            // element already in collection (!)
            return;
          }

          // add to end of array, as no idx is specified
          idx = this.length;
        }

        // handle already in collection
        if (currentIdx !== -1) {

          // remove element from currentIdx
          this.splice(currentIdx, 1);
        }

        // add element at idx
        this.splice(idx, 0, element);

        if (currentIdx === -1) {
          // set inverse, unless element was
          // in collection already
          refs.set(element, inverseProperty, target);
        }
      }
    });

    // a simple marker, identifying this element
    // as being a refs collection
    Object.defineProperty(collection, '__refs_collection', {
      value: true
    });

    return collection;
  }

  function isExtended(collection) {
    return collection.__refs_collection === true;
  }

  var extend_1 = extend$1;

  var isExtended_1 = isExtended;

  var collection = {
  	extend: extend_1,
  	isExtended: isExtended_1
  };

  function hasOwnProperty$1(e, property) {
    return Object.prototype.hasOwnProperty.call(e, property.name || property);
  }

  function defineCollectionProperty(ref, property, target) {

    var collection$$1 = collection.extend(target[property.name] || [], ref, property, target);

    Object.defineProperty(target, property.name, {
      enumerable: property.enumerable,
      value: collection$$1
    });

    if (collection$$1.length) {

      collection$$1.forEach(function (o) {
        ref.set(o, property.inverse, target);
      });
    }
  }

  function defineProperty$1(ref, property, target) {

    var inverseProperty = property.inverse;

    var _value = target[property.name];

    Object.defineProperty(target, property.name, {
      configurable: property.configurable,
      enumerable: property.enumerable,

      get: function get() {
        return _value;
      },

      set: function set(value) {

        // return if we already performed all changes
        if (value === _value) {
          return;
        }

        var old = _value;

        // temporary set null
        _value = null;

        if (old) {
          ref.unset(old, inverseProperty, target);
        }

        // set new value
        _value = value;

        // set inverse value
        ref.set(_value, inverseProperty, target);
      }
    });
  }

  /**
   * Creates a new references object defining two inversly related
   * attribute descriptors a and b.
   *
   * <p>
   *   When bound to an object using {@link Refs#bind} the references
   *   get activated and ensure that add and remove operations are applied
   *   reversely, too.
   * </p>
   *
   * <p>
   *   For attributes represented as collections {@link Refs} provides the
   *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions
   *   that must be used to properly hook into the inverse change mechanism.
   * </p>
   *
   * @class Refs
   *
   * @classdesc A bi-directional reference between two attributes.
   *
   * @param {Refs.AttributeDescriptor} a property descriptor
   * @param {Refs.AttributeDescriptor} b property descriptor
   *
   * @example
   *
   * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });
   *
   * var car = { name: 'toyota' };
   * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];
   *
   * refs.bind(car, 'wheels');
   *
   * car.wheels // []
   * car.wheels.add(wheels[0]);
   * car.wheels.add(wheels[1]);
   *
   * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]
   *
   * wheels[0].car // { name: 'toyota' };
   * car.wheels.remove(wheels[0]);
   *
   * wheels[0].car // undefined
   */
  function Refs(a, b) {

    if (!(this instanceof Refs)) {
      return new Refs(a, b);
    }

    // link
    a.inverse = b;
    b.inverse = a;

    this.props = {};
    this.props[a.name] = a;
    this.props[b.name] = b;
  }

  /**
   * Binds one side of a bi-directional reference to a
   * target object.
   *
   * @memberOf Refs
   *
   * @param  {Object} target
   * @param  {String} property
   */
  Refs.prototype.bind = function (target, property) {
    if (typeof property === 'string') {
      if (!this.props[property]) {
        throw new Error('no property <' + property + '> in ref');
      }
      property = this.props[property];
    }

    if (property.collection) {
      defineCollectionProperty(this, property, target);
    } else {
      defineProperty$1(this, property, target);
    }
  };

  Refs.prototype.ensureRefsCollection = function (target, property) {

    var collection$$1 = target[property.name];

    if (!collection.isExtended(collection$$1)) {
      defineCollectionProperty(this, property, target);
    }

    return collection$$1;
  };

  Refs.prototype.ensureBound = function (target, property) {
    if (!hasOwnProperty$1(target, property)) {
      this.bind(target, property);
    }
  };

  Refs.prototype.unset = function (target, property, value) {

    if (target) {
      this.ensureBound(target, property);

      if (property.collection) {
        this.ensureRefsCollection(target, property).remove(value);
      } else {
        target[property.name] = undefined;
      }
    }
  };

  Refs.prototype.set = function (target, property, value) {

    if (target) {
      this.ensureBound(target, property);

      if (property.collection) {
        this.ensureRefsCollection(target, property).add(value);
      } else {
        target[property.name] = value;
      }
    }
  };

  var refs = Refs;

  var objectRefs = refs;

  var Collection = collection;
  objectRefs.Collection = Collection;

  var parentRefs = new objectRefs({ name: 'children', enumerable: true, collection: true }, { name: 'parent' }),
      labelRefs = new objectRefs({ name: 'labels', enumerable: true, collection: true }, { name: 'labelTarget' }),
      attacherRefs = new objectRefs({ name: 'attachers', collection: true }, { name: 'host' }),
      outgoingRefs = new objectRefs({ name: 'outgoing', collection: true }, { name: 'source' }),
      incomingRefs = new objectRefs({ name: 'incoming', collection: true }, { name: 'target' });

  /**
   * @namespace djs.model
   */

  /**
   * @memberOf djs.model
   */

  /**
   * The basic graphical representation
   *
   * @class
   *
   * @abstract
   */
  function Base$1() {

    /**
     * The object that backs up the shape
     *
     * @name Base#businessObject
     * @type Object
     */
    Object.defineProperty(this, 'businessObject', {
      writable: true
    });

    /**
     * Single label support, will mapped to multi label array
     *
     * @name Base#label
     * @type Object
     */
    Object.defineProperty(this, 'label', {
      get: function get() {
        return this.labels[0];
      },
      set: function set(newLabel) {

        var label = this.label,
            labels = this.labels;

        if (!newLabel && label) {
          labels.remove(label);
        } else {
          labels.add(newLabel, 0);
        }
      }
    });

    /**
     * The parent shape
     *
     * @name Base#parent
     * @type Shape
     */
    parentRefs.bind(this, 'parent');

    /**
     * The list of labels
     *
     * @name Base#labels
     * @type Label
     */
    labelRefs.bind(this, 'labels');

    /**
     * The list of outgoing connections
     *
     * @name Base#outgoing
     * @type Array<Connection>
     */
    outgoingRefs.bind(this, 'outgoing');

    /**
     * The list of incoming connections
     *
     * @name Base#incoming
     * @type Array<Connection>
     */
    incomingRefs.bind(this, 'incoming');
  }

  /**
   * A graphical object
   *
   * @class
   * @constructor
   *
   * @extends Base
   */
  function Shape() {
    Base$1.call(this);

    /**
     * The list of children
     *
     * @name Shape#children
     * @type Array<Base>
     */
    parentRefs.bind(this, 'children');

    /**
     * @name Shape#host
     * @type Shape
     */
    attacherRefs.bind(this, 'host');

    /**
     * @name Shape#attachers
     * @type Shape
     */
    attacherRefs.bind(this, 'attachers');
  }

  inherits_browser(Shape, Base$1);

  /**
   * A root graphical object
   *
   * @class
   * @constructor
   *
   * @extends Shape
   */
  function Root() {
    Shape.call(this);
  }

  inherits_browser(Root, Shape);

  /**
   * A label for an element
   *
   * @class
   * @constructor
   *
   * @extends Shape
   */
  function Label() {
    Shape.call(this);

    /**
     * The labeled element
     *
     * @name Label#labelTarget
     * @type Base
     */
    labelRefs.bind(this, 'labelTarget');
  }

  inherits_browser(Label, Shape);

  /**
   * A connection between two elements
   *
   * @class
   * @constructor
   *
   * @extends Base
   */
  function Connection() {
    Base$1.call(this);

    /**
     * The element this connection originates from
     *
     * @name Connection#source
     * @type Base
     */
    outgoingRefs.bind(this, 'source');

    /**
     * The element this connection points to
     *
     * @name Connection#target
     * @type Base
     */
    incomingRefs.bind(this, 'target');
  }

  inherits_browser(Connection, Base$1);

  var types$4 = {
    connection: Connection,
    shape: Shape,
    label: Label,
    root: Root
  };

  /**
   * Creates a new model element of the specified type
   *
   * @method create
   *
   * @example
   *
   * var shape1 = Model.create('shape', { x: 10, y: 10, width: 100, height: 100 });
   * var shape2 = Model.create('shape', { x: 210, y: 210, width: 100, height: 100 });
   *
   * var connection = Model.create('connection', { waypoints: [ { x: 110, y: 55 }, {x: 210, y: 55 } ] });
   *
   * @param  {String} type lower-cased model name
   * @param  {Object} attrs attributes to initialize the new model instance with
   *
   * @return {Base} the new model instance
   */
  function create$1(type, attrs) {
    var Type = types$4[type];
    if (!Type) {
      throw new Error('unknown type: <' + type + '>');
    }
    return assign(new Type(), attrs);
  }

  /**
   * A factory for diagram-js shapes
   */
  function ElementFactory() {
    this._uid = 12;
  }

  ElementFactory.prototype.createRoot = function (attrs) {
    return this.create('root', attrs);
  };

  ElementFactory.prototype.createLabel = function (attrs) {
    return this.create('label', attrs);
  };

  ElementFactory.prototype.createShape = function (attrs) {
    return this.create('shape', attrs);
  };

  ElementFactory.prototype.createConnection = function (attrs) {
    return this.create('connection', attrs);
  };

  /**
   * Create a model element with the given type and
   * a number of pre-set attributes.
   *
   * @param  {String} type
   * @param  {Object} attrs
   * @return {djs.model.Base} the newly created model instance
   */
  ElementFactory.prototype.create = function (type, attrs) {

    attrs = assign({}, attrs || {});

    if (!attrs.id) {
      attrs.id = type + '_' + this._uid++;
    }

    return create$1(type, attrs);
  };

  /**
   * SVGs for elements are generated by the {@link GraphicsFactory}.
   *
   * This utility gives quick access to the important semantic
   * parts of an element.
   */

  /**
   * Returns the visual part of a diagram element
   *
   * @param {Snap<SVGElement>} gfx
   *
   * @return {Snap<SVGElement>}
   */
  function getVisual(gfx) {
    return query('.djs-visual', gfx);
  }

  /**
   * Returns the children for a given diagram element.
   *
   * @param {Snap<SVGElement>} gfx
   * @return {Snap<SVGElement>}
   */
  function getChildren(gfx) {
    return gfx.parentNode.childNodes[1];
  }

  /**
   * @param {SVGElement} element
   * @param {Number} x
   * @param {Number} y
   */
  function translate(gfx, x, y) {
    var translate = createTransform();
    translate.setTranslate(x, y);

    transform(gfx, translate);
  }

  /**
   * @param {SVGElement} element
   * @param {Number} angle
   */
  function rotate(gfx, angle) {
    var rotate = createTransform();
    rotate.setRotate(angle, 0, 0);

    transform(gfx, rotate);
  }

  /**
   * A factory that creates graphical elements
   *
   * @param {EventBus} eventBus
   * @param {ElementRegistry} elementRegistry
   */
  function GraphicsFactory(eventBus, elementRegistry) {
    this._eventBus = eventBus;
    this._elementRegistry = elementRegistry;
  }

  GraphicsFactory.$inject = ['eventBus', 'elementRegistry'];

  GraphicsFactory.prototype._getChildren = function (element) {

    var gfx = this._elementRegistry.getGraphics(element);

    var childrenGfx;

    // root element
    if (!element.parent) {
      childrenGfx = gfx;
    } else {
      childrenGfx = getChildren(gfx);
      if (!childrenGfx) {
        childrenGfx = create('g');
        classes$1(childrenGfx).add('djs-children');

        append(gfx.parentNode, childrenGfx);
      }
    }

    return childrenGfx;
  };

  /**
   * Clears the graphical representation of the element and returns the
   * cleared visual (the <g class="djs-visual" /> element).
   */
  GraphicsFactory.prototype._clear = function (gfx) {
    var visual = getVisual(gfx);

    clear(visual);

    return visual;
  };

  /**
   * Creates a gfx container for shapes and connections
   *
   * The layout is as follows:
   *
   * <g class="djs-group">
   *
   *   <!-- the gfx -->
   *   <g class="djs-element djs-(shape|connection)">
   *     <g class="djs-visual">
   *       <!-- the renderer draws in here -->
   *     </g>
   *
   *     <!-- extensions (overlays, click box, ...) goes here
   *   </g>
   *
   *   <!-- the gfx child nodes -->
   *   <g class="djs-children"></g>
   * </g>
   *
   * @param {Object} parent
   * @param {String} type the type of the element, i.e. shape | connection
   * @param {Number} [parentIndex] position to create container in parent
   */
  GraphicsFactory.prototype._createContainer = function (type, childrenGfx, parentIndex) {
    var outerGfx = create('g');
    classes$1(outerGfx).add('djs-group');

    // insert node at position
    if (typeof parentIndex !== 'undefined') {
      prependTo(outerGfx, childrenGfx, childrenGfx.childNodes[parentIndex]);
    } else {
      append(childrenGfx, outerGfx);
    }

    var gfx = create('g');
    classes$1(gfx).add('djs-element');
    classes$1(gfx).add('djs-' + type);

    append(outerGfx, gfx);

    // create visual
    var visual = create('g');
    classes$1(visual).add('djs-visual');

    append(gfx, visual);

    return gfx;
  };

  GraphicsFactory.prototype.create = function (type, element, parentIndex) {
    var childrenGfx = this._getChildren(element.parent);
    return this._createContainer(type, childrenGfx, parentIndex);
  };

  GraphicsFactory.prototype.updateContainments = function (elements) {

    var self = this,
        elementRegistry = this._elementRegistry,
        parents;

    parents = reduce(elements, function (map$$1, e) {

      if (e.parent) {
        map$$1[e.parent.id] = e.parent;
      }

      return map$$1;
    }, {});

    // update all parents of changed and reorganized their children
    // in the correct order (as indicated in our model)
    forEach(parents, function (parent) {

      var children = parent.children;

      if (!children) {
        return;
      }

      var childGfx = self._getChildren(parent);

      forEach(children.slice().reverse(), function (c) {
        var gfx = elementRegistry.getGraphics(c);

        prependTo(gfx.parentNode, childGfx);
      });
    });
  };

  GraphicsFactory.prototype.drawShape = function (visual, element) {
    var eventBus = this._eventBus;

    return eventBus.fire('render.shape', { gfx: visual, element: element });
  };

  GraphicsFactory.prototype.getShapePath = function (element) {
    var eventBus = this._eventBus;

    return eventBus.fire('render.getShapePath', element);
  };

  GraphicsFactory.prototype.drawConnection = function (visual, element) {
    var eventBus = this._eventBus;

    return eventBus.fire('render.connection', { gfx: visual, element: element });
  };

  GraphicsFactory.prototype.getConnectionPath = function (waypoints) {
    var eventBus = this._eventBus;

    return eventBus.fire('render.getConnectionPath', waypoints);
  };

  GraphicsFactory.prototype.update = function (type, element, gfx) {
    // Do not update root element
    if (!element.parent) {
      return;
    }

    var visual = this._clear(gfx);

    // redraw
    if (type === 'shape') {
      this.drawShape(visual, element);

      // update positioning
      translate(gfx, element.x, element.y);
    } else if (type === 'connection') {
      this.drawConnection(visual, element);
    } else {
      throw new Error('unknown type: ' + type);
    }

    if (element.hidden) {
      attr$1(gfx, 'display', 'none');
    } else {
      attr$1(gfx, 'display', 'block');
    }
  };

  GraphicsFactory.prototype.remove = function (element) {
    var gfx = this._elementRegistry.getGraphics(element);

    // remove
    remove$1(gfx.parentNode);
  };

  // helpers //////////////////////

  function prependTo(newNode, parentNode, siblingNode) {
    parentNode.insertBefore(newNode, siblingNode || parentNode.firstChild);
  }

  var CoreModule = {
    __depends__: [DrawModule],
    __init__: ['canvas'],
    canvas: ['type', Canvas],
    elementRegistry: ['type', ElementRegistry],
    elementFactory: ['type', ElementFactory],
    eventBus: ['type', EventBus],
    graphicsFactory: ['type', GraphicsFactory]
  };

  /**
   * Bootstrap an injector from a list of modules, instantiating a number of default components
   *
   * @ignore
   * @param {Array<didi.Module>} bootstrapModules
   *
   * @return {didi.Injector} a injector to use to access the components
   */
  function bootstrap(bootstrapModules) {

    var modules = [],
        components = [];

    function hasModule(m) {
      return modules.indexOf(m) >= 0;
    }

    function addModule(m) {
      modules.push(m);
    }

    function visit(m) {
      if (hasModule(m)) {
        return;
      }

      (m.__depends__ || []).forEach(visit);

      if (hasModule(m)) {
        return;
      }

      addModule(m);

      (m.__init__ || []).forEach(function (c) {
        components.push(c);
      });
    }

    bootstrapModules.forEach(visit);

    var injector = new Injector(modules);

    components.forEach(function (c) {

      try {
        // eagerly resolve component (fn or string)
        injector[typeof c === 'string' ? 'get' : 'invoke'](c);
      } catch (e) {
        console.error('Failed to instantiate component');
        console.error(e.stack);

        throw e;
      }
    });

    return injector;
  }

  /**
   * Creates an injector from passed options.
   *
   * @ignore
   * @param  {Object} options
   * @return {didi.Injector}
   */
  function createInjector(options) {

    options = options || {};

    var configModule = {
      'config': ['value', options]
    };

    var modules = [configModule, CoreModule].concat(options.modules || []);

    return bootstrap(modules);
  }

  /**
   * The main diagram-js entry point that bootstraps the diagram with the given
   * configuration.
   *
   * To register extensions with the diagram, pass them as Array<didi.Module> to the constructor.
   *
   * @class djs.Diagram
   * @memberOf djs
   * @constructor
   *
   * @example
   *
   * <caption>Creating a plug-in that logs whenever a shape is added to the canvas.</caption>
   *
   * // plug-in implemenentation
   * function MyLoggingPlugin(eventBus) {
   *   eventBus.on('shape.added', function(event) {
   *     console.log('shape ', event.shape, ' was added to the diagram');
   *   });
   * }
   *
   * // export as module
   * export default {
   *   __init__: [ 'myLoggingPlugin' ],
   *     myLoggingPlugin: [ 'type', MyLoggingPlugin ]
   * };
   *
   *
   * // instantiate the diagram with the new plug-in
   *
   * import MyLoggingModule from 'path-to-my-logging-plugin';
   *
   * var diagram = new Diagram({
   *   modules: [
   *     MyLoggingModule
   *   ]
   * });
   *
   * diagram.invoke([ 'canvas', function(canvas) {
   *   // add shape to drawing canvas
   *   canvas.addShape({ x: 10, y: 10 });
   * });
   *
   * // 'shape ... was added to the diagram' logged to console
   *
   * @param {Object} options
   * @param {Array<didi.Module>} [options.modules] external modules to instantiate with the diagram
   * @param {didi.Injector} [injector] an (optional) injector to bootstrap the diagram with
   */
  function Diagram(options, injector) {

    // create injector unless explicitly specified
    this.injector = injector = injector || createInjector(options);

    // API

    /**
     * Resolves a diagram service
     *
     * @method Diagram#get
     *
     * @param {String} name the name of the diagram service to be retrieved
     * @param {Boolean} [strict=true] if false, resolve missing services to null
     */
    this.get = injector.get;

    /**
     * Executes a function into which diagram services are injected
     *
     * @method Diagram#invoke
     *
     * @param {Function|Object[]} fn the function to resolve
     * @param {Object} locals a number of locals to use to resolve certain dependencies
     */
    this.invoke = injector.invoke;

    // init

    // indicate via event


    /**
     * An event indicating that all plug-ins are loaded.
     *
     * Use this event to fire other events to interested plug-ins
     *
     * @memberOf Diagram
     *
     * @event diagram.init
     *
     * @example
     *
     * eventBus.on('diagram.init', function() {
     *   eventBus.fire('my-custom-event', { foo: 'BAR' });
     * });
     *
     * @type {Object}
     */
    this.get('eventBus').fire('diagram.init');
  }

  /**
   * Destroys the diagram
   *
   * @method  Diagram#destroy
   */
  Diagram.prototype.destroy = function () {
    this.get('eventBus').fire('diagram.destroy');
  };

  /**
   * Clear the diagram, removing all contents.
   */
  Diagram.prototype.clear = function () {
    this.get('eventBus').fire('diagram.clear');
  };

  var Diagram$1 = /*#__PURE__*/Object.freeze({
    default: Diagram
  });

  var require$$0 = ( Diagram$1 && Diagram ) || Diagram$1;

  var diagramJs = require$$0;

  function parseID(element) {
    return element && element.href.slice(1);
  }

  function DRDTreeWalker(handler, options) {

    // list of elements to handle deferred to ensure
    // prerequisites are drawn
    var deferred = [];

    function visit(element, di) {

      var gfx = element.gfx;

      // avoid multiple rendering of elements
      if (gfx) {
        throw new Error('already rendered ' + element.id);
      }

      // call handler
      return handler.element(element, di);
    }

    // Semantic handling //////////////////////

    function handleDefinitions(definitions) {

      // make sure we walk the correct dmnElement
      handler.root(definitions);

      forEach(['decision', 'drgElements', 'artifacts'], function (element) {
        if (definitions[element]) {
          forEach(definitions[element], handleElement);
        }
      });

      handleDeferred(deferred);
    }

    function handleDeferred(elements) {
      forEach(elements, function (d) {
        d();
      });
    }

    function handleElement(element) {
      var edges = [];

      handleDI(element, function (extensionElement) {
        if (is(extensionElement, 'biodi:Bounds')) {
          visit(element, extensionElement);
        } else if (is(extensionElement, 'biodi:Edge')) {
          edges.push(extensionElement);
        }
      });

      handleConnections(edges, element);
    }

    function handleConnections(edges, element) {

      function deferConnection(semantic, property) {
        var id = parseID(property),
            edge = find(edges, matchPattern({ source: id }));

        if (edge) {
          deferred.push(function () {
            visit(semantic, edge);
          });
        }
      }

      if (is(element, 'dmn:Association')) {
        return deferConnection(element, element.sourceRef);
      }

      forEach(['informationRequirement', 'knowledgeRequirement', 'authorityRequirement'], function (requirements) {
        forEach(element[requirements], function (requirement) {
          var properties = null;

          // get the href
          if (is(requirement, 'dmn:InformationRequirement')) {
            properties = ['requiredDecision', 'requiredInput'];
          } else if (is(requirement, 'dmn:KnowledgeRequirement')) {
            properties = ['requiredKnowledge'];
          } else if (is(requirement, 'dmn:AuthorityRequirement')) {
            properties = ['requiredDecision', 'requiredInput', 'requiredAuthority'];
          }

          if (properties) {
            forEach(properties, function (property) {
              if (requirement[property]) {
                deferConnection(requirement, requirement[property]);
              }
            });
          }
        });
      });
    }

    function handleDI(element, fn) {
      var extensionElements = element.extensionElements;

      if (!extensionElements) {
        return;
      }

      forEach(extensionElements.values, fn);
    }

    // API //////////////////////

    return {
      handleDefinitions: handleDefinitions
    };
  }

  /**
   * Import the definitions into a diagram.
   *
   * Errors and warnings are reported through the specified callback.
   *
   * @param  {Drd} drd
   * @param  {ModdleElement} definitions
   * @param  {Function} done
   *         the callback, invoked with (err, [ warning ]) once the import is done
   */
  function importDRD(drd, definitions, done) {

    var importer = drd.get('drdImporter'),
        eventBus = drd.get('eventBus');

    var error,
        warnings = [];

    function render(definitions) {

      var visitor = {
        root: function root(element) {
          return importer.root(element);
        },

        element: function element(_element, di) {
          return importer.add(_element, di);
        },

        error: function error(message, context) {
          warnings.push({ message: message, context: context });
        }
      };

      var walker = new DRDTreeWalker(visitor);

      // import
      walker.handleDefinitions(definitions);
    }

    eventBus.fire('import.start', { definitions: definitions });

    try {
      render(definitions);
    } catch (e) {
      error = e;
    }

    eventBus.fire('import.done', { error: error, warnings: warnings });

    done(error, warnings);
  }

  var DEFAULT_BOX_PADDING = 0;

  var DEFAULT_LABEL_SIZE = {
    width: 150,
    height: 50
  };

  function parseAlign(align) {

    var parts = align.split('-');

    return {
      horizontal: parts[0] || 'center',
      vertical: parts[1] || 'top'
    };
  }

  function parsePadding(padding) {

    if (isObject(padding)) {
      return assign({ top: 0, left: 0, right: 0, bottom: 0 }, padding);
    } else {
      return {
        top: padding,
        left: padding,
        right: padding,
        bottom: padding
      };
    }
  }

  function getTextBBox(text, fakeText) {

    fakeText.textContent = text;

    var textBBox;

    try {
      var bbox,
          emptyLine = text === '';

      // add dummy text, when line is empty to
      // determine correct height
      fakeText.textContent = emptyLine ? 'dummy' : text;

      textBBox = fakeText.getBBox();

      // take text rendering related horizontal
      // padding into account
      bbox = {
        width: textBBox.width + textBBox.x * 2,
        height: textBBox.height
      };

      if (emptyLine) {
        // correct width
        bbox.width = 0;
      }

      return bbox;
    } catch (e) {
      return { width: 0, height: 0 };
    }
  }

  /**
   * Layout the next line and return the layouted element.
   *
   * Alters the lines passed.
   *
   * @param  {Array<String>} lines
   * @return {Object} the line descriptor, an object { width, height, text }
   */
  function layoutNext(lines, maxWidth, fakeText) {

    var originalLine = lines.shift(),
        fitLine = originalLine;

    var textBBox;

    for (;;) {
      textBBox = getTextBBox(fitLine, fakeText);

      textBBox.width = fitLine ? textBBox.width : 0;

      // try to fit
      if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {
        return fit(lines, fitLine, originalLine, textBBox);
      }

      fitLine = shortenLine(fitLine, textBBox.width, maxWidth);
    }
  }

  function fit(lines, fitLine, originalLine, textBBox) {
    if (fitLine.length < originalLine.length) {
      var remainder = originalLine.slice(fitLine.length).trim();

      lines.unshift(remainder);
    }

    return {
      width: textBBox.width,
      height: textBBox.height,
      text: fitLine
    };
  }

  /**
   * Shortens a line based on spacing and hyphens.
   * Returns the shortened result on success.
   *
   * @param  {String} line
   * @param  {Number} maxLength the maximum characters of the string
   * @return {String} the shortened string
   */
  function semanticShorten(line, maxLength) {
    var parts = line.split(/(\s|-)/g),
        part,
        shortenedParts = [],
        length = 0;

    // try to shorten via spaces + hyphens
    if (parts.length > 1) {
      while (part = parts.shift()) {
        if (part.length + length < maxLength) {
          shortenedParts.push(part);
          length += part.length;
        } else {
          // remove previous part, too if hyphen does not fit anymore
          if (part === '-') {
            shortenedParts.pop();
          }

          break;
        }
      }
    }

    return shortenedParts.join('');
  }

  function shortenLine(line, width, maxWidth) {
    var length = Math.max(line.length * (maxWidth / width), 1);

    // try to shorten semantically (i.e. based on spaces and hyphens)
    var shortenedLine = semanticShorten(line, length);

    if (!shortenedLine) {

      // force shorten by cutting the long word
      shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));
    }

    return shortenedLine;
  }

  function getHelperSvg() {
    var helperSvg = document.getElementById('helper-svg');

    if (!helperSvg) {
      helperSvg = create('svg');

      attr$1(helperSvg, {
        id: 'helper-svg',
        width: 0,
        height: 0,
        style: 'visibility: hidden; position: fixed'
      });

      document.body.appendChild(helperSvg);
    }

    return helperSvg;
  }

  /**
   * Creates a new label utility
   *
   * @param {Object} config
   * @param {Dimensions} config.size
   * @param {Number} config.padding
   * @param {Object} config.style
   * @param {String} config.align
   */
  function Text(config) {

    this._config = assign({}, {
      size: DEFAULT_LABEL_SIZE,
      padding: DEFAULT_BOX_PADDING,
      style: {},
      align: 'center-top'
    }, config || {});
  }

  /**
   * Returns the layouted text as an SVG element.
   *
   * @param {String} text
   * @param {Object} options
   *
   * @return {SVGElement}
   */
  Text.prototype.createText = function (text, options) {
    return this.layoutText(text, options).element;
  };

  /**
   * Returns a labels layouted dimensions.
   *
   * @param {String} text to layout
   * @param {Object} options
   *
   * @return {Dimensions}
   */
  Text.prototype.getDimensions = function (text, options) {
    return this.layoutText(text, options).dimensions;
  };

  /**
   * Creates and returns a label and its bounding box.
   *
   * @method Text#createText
   *
   * @param {String} text the text to render on the label
   * @param {Object} options
   * @param {String} options.align how to align in the bounding box.
   *                               Any of { 'center-middle', 'center-top' },
   *                               defaults to 'center-top'.
   * @param {String} options.style style to be applied to the text
   * @param {boolean} options.fitBox indicates if box will be recalculated to
   *                                 fit text
   *
   * @return {Object} { element, dimensions }
   */
  Text.prototype.layoutText = function (text, options) {
    var box = assign({}, this._config.size, options.box),
        style = assign({}, this._config.style, options.style),
        align = parseAlign(options.align || this._config.align),
        padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding),
        fitBox = options.fitBox || false;

    var lineHeight = getLineHeight(style);

    var lines = text.split(/\r?\n/g),
        layouted = [];

    var maxWidth = box.width - padding.left - padding.right;

    // ensure correct rendering by attaching helper text node to invisible SVG
    var helperText = create('text');
    attr$1(helperText, { x: 0, y: 0 });
    attr$1(helperText, style);

    var helperSvg = getHelperSvg();

    append(helperSvg, helperText);

    while (lines.length) {
      layouted.push(layoutNext(lines, maxWidth, helperText));
    }

    if (align.vertical === 'middle') {
      padding.top = padding.bottom = 0;
    }

    var totalHeight = reduce(layouted, function (sum, line, idx) {
      return sum + (lineHeight || line.height);
    }, 0) + padding.top + padding.bottom;

    var maxLineWidth = reduce(layouted, function (sum, line, idx) {
      return line.width > sum ? line.width : sum;
    }, 0);

    // the y position of the next line
    var y = padding.top;

    if (align.vertical === 'middle') {
      y += (box.height - totalHeight) / 2;
    }

    // magic number initial offset
    y -= (lineHeight || layouted[0].height) / 4;

    var textElement = create('text');

    attr$1(textElement, style);

    // layout each line taking into account that parent
    // shape might resize to fit text size
    forEach(layouted, function (line) {

      var x;

      y += lineHeight || line.height;

      switch (align.horizontal) {
        case 'left':
          x = padding.left;
          break;

        case 'right':
          x = (fitBox ? maxLineWidth : maxWidth) - padding.right - line.width;
          break;

        default:
          // aka center
          x = Math.max(((fitBox ? maxLineWidth : maxWidth) - line.width) / 2 + padding.left, 0);
      }

      var tspan = create('tspan');
      attr$1(tspan, { x: x, y: y });

      tspan.textContent = line.text;

      append(textElement, tspan);
    });

    remove$1(helperText);

    var dimensions = {
      width: maxLineWidth,
      height: totalHeight
    };

    return {
      dimensions: dimensions,
      element: textElement
    };
  };

  function getLineHeight(style) {
    if ('fontSize' in style && 'lineHeight' in style) {
      return style.lineHeight * parseInt(style.fontSize, 10);
    }
  }

  function DrdRenderer(eventBus, pathMap, styles) {

    BaseRenderer.call(this, eventBus);

    var LABEL_STYLE = {
      fontFamily: 'Arial, sans-serif',
      fontSize: '12px'
    };

    var textUtil = new Text({
      style: LABEL_STYLE,
      size: { width: 100 }
    });

    var markers = {};

    function addMarker(id, element) {
      markers[id] = element;
    }

    function marker(id) {
      var marker = markers[id];

      return 'url(#' + marker.id + ')';
    }

    function initMarkers(svg) {

      function createMarker(id, options) {
        var attrs = assign({
          strokeWidth: 1,
          strokeLinecap: 'round',
          strokeDasharray: 'none'
        }, options.attrs);

        var ref = options.ref || { x: 0, y: 0 };

        var scale = options.scale || 1;

        // fix for safari / chrome / firefox bug not correctly
        // resetting stroke dash array
        if (attrs.strokeDasharray === 'none') {
          attrs.strokeDasharray = [10000, 1];
        }

        var marker = create('marker');

        attr$1(options.element, attrs);

        append(marker, options.element);

        attr$1(marker, {
          id: id,
          viewBox: '0 0 20 20',
          refX: ref.x,
          refY: ref.y,
          markerWidth: 20 * scale,
          markerHeight: 20 * scale,
          orient: 'auto'
        });

        var defs = query('defs', svg);

        if (!defs) {
          defs = create('defs');

          append(svg, defs);
        }

        append(defs, marker);

        return addMarker(id, marker);
      }

      var associationStart = create('path');
      attr$1(associationStart, { d: 'M 11 5 L 1 10 L 11 15' });

      createMarker('association-start', {
        element: associationStart,
        attrs: {
          fill: 'none',
          stroke: 'black',
          strokeWidth: 1.5
        },
        ref: { x: 1, y: 10 },
        scale: 0.5
      });

      var associationEnd = create('path');
      attr$1(associationEnd, { d: 'M 1 5 L 11 10 L 1 15' });

      createMarker('association-end', {
        element: associationEnd,
        attrs: {
          fill: 'none',
          stroke: 'black',
          strokeWidth: 1.5
        },
        ref: { x: 12, y: 10 },
        scale: 0.5
      });

      var informationRequirementEnd = create('path');
      attr$1(informationRequirementEnd, { d: 'M 1 5 L 11 10 L 1 15 Z' });

      createMarker('information-requirement-end', {
        element: informationRequirementEnd,
        ref: { x: 11, y: 10 },
        scale: 1
      });

      var knowledgeRequirementEnd = create('path');
      attr$1(knowledgeRequirementEnd, { d: 'M 1 3 L 11 10 L 1 17' });

      createMarker('knowledge-requirement-end', {
        element: knowledgeRequirementEnd,
        attrs: {
          fill: 'none',
          stroke: 'black',
          strokeWidth: 2
        },
        ref: { x: 11, y: 10 },
        scale: 0.8
      });

      var authorityRequirementEnd = create('circle');
      attr$1(authorityRequirementEnd, { cx: 3, cy: 3, r: 3 });

      createMarker('authority-requirement-end', {
        element: authorityRequirementEnd,
        ref: { x: 3, y: 3 },
        scale: 0.9
      });
    }

    function computeStyle(custom, traits, defaultStyles) {
      if (!isArray(traits)) {
        defaultStyles = traits;
        traits = [];
      }

      return styles.style(traits || [], assign(defaultStyles, custom || {}));
    }

    function drawRect(p, width, height, r, offset, attrs) {

      if (isObject(offset)) {
        attrs = offset;
        offset = 0;
      }

      offset = offset || 0;

      attrs = computeStyle(attrs, {
        stroke: 'black',
        strokeWidth: 2,
        fill: 'white'
      });

      var rect = create('rect');
      attr$1(rect, {
        x: offset,
        y: offset,
        width: width - offset * 2,
        height: height - offset * 2,
        rx: r,
        ry: r
      });
      attr$1(rect, attrs);

      append(p, rect);

      return rect;
    }

    function renderLabel(p, label, options) {
      var text = textUtil.createText(label || '', options);

      attr(text, 'class', 'djs-label');

      append(p, text);

      return text;
    }

    function renderEmbeddedLabel(p, element, align) {
      var name = getName(element);
      return renderLabel(p, name, { box: element, align: align, padding: 5 });
    }

    function drawPath(p, d, attrs) {

      attrs = computeStyle(attrs, ['no-fill'], {
        strokeWidth: 2,
        stroke: 'black'
      });

      var path = create('path');
      attr$1(path, { d: d });
      attr$1(path, attrs);

      append(p, path);

      return path;
    }

    var handlers = {
      'dmn:Decision': function dmnDecision(p, element, attrs) {
        var rect = drawRect(p, element.width, element.height, 0, attrs);

        renderEmbeddedLabel(p, element, 'center-middle');

        return rect;
      },
      'dmn:KnowledgeSource': function dmnKnowledgeSource(p, element, attrs) {

        var pathData = pathMap.getScaledPath('KNOWLEDGE_SOURCE', {
          xScaleFactor: 1.021,
          yScaleFactor: 1,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.0,
            my: 0.075
          }
        });

        var knowledgeSource = drawPath(p, pathData, {
          strokeWidth: 2,
          fill: 'white',
          stroke: 'black'
        });

        renderEmbeddedLabel(p, element, 'center-middle');

        return knowledgeSource;
      },
      'dmn:BusinessKnowledgeModel': function dmnBusinessKnowledgeModel(p, element, attrs) {

        var pathData = pathMap.getScaledPath('BUSINESS_KNOWLEDGE_MODEL', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.0,
            my: 0.3
          }
        });

        var businessKnowledge = drawPath(p, pathData, {
          strokeWidth: 2,
          fill: 'white',
          stroke: 'black'
        });

        renderEmbeddedLabel(p, element, 'center-middle');

        return businessKnowledge;
      },
      'dmn:InputData': function dmnInputData(p, element, attrs) {

        var rect = drawRect(p, element.width, element.height, 22, attrs);

        renderEmbeddedLabel(p, element, 'center-middle');

        return rect;
      },
      'dmn:TextAnnotation': function dmnTextAnnotation(p, element, attrs) {
        var style = {
          'fill': 'none',
          'stroke': 'none'
        };
        var textElement = drawRect(p, element.width, element.height, 0, 0, style),
            textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.0,
            my: 0.0
          }
        });

        drawPath(p, textPathData);

        var text = getSemantic(element).text || '';

        renderLabel(p, text, { box: element, align: 'left-middle', padding: 5 });

        return textElement;
      },
      'dmn:Association': function dmnAssociation(p, element, attrs) {
        var semantic = getSemantic(element);

        attrs = assign({
          strokeDasharray: '0.5, 5',
          strokeLinecap: 'round',
          strokeLinejoin: 'round',
          fill: 'none'
        }, attrs || {});

        if (semantic.associationDirection === 'One' || semantic.associationDirection === 'Both') {
          attrs.markerEnd = marker('association-end');
        }

        if (semantic.associationDirection === 'Both') {
          attrs.markerStart = marker('association-start');
        }

        return drawLine(p, element.waypoints, attrs);
      },
      'dmn:InformationRequirement': function dmnInformationRequirement(p, element, attrs) {

        attrs = assign({
          strokeWidth: 1,
          strokeLinecap: 'round',
          strokeLinejoin: 'round',
          markerEnd: marker('information-requirement-end')
        }, attrs || {});

        return drawLine(p, element.waypoints, attrs);
      },
      'dmn:KnowledgeRequirement': function dmnKnowledgeRequirement(p, element, attrs) {

        attrs = assign({
          strokeWidth: 1,
          strokeDasharray: 5,
          strokeLinecap: 'round',
          strokeLinejoin: 'round',
          markerEnd: marker('knowledge-requirement-end')
        }, attrs || {});

        return drawLine(p, element.waypoints, attrs);
      },
      'dmn:AuthorityRequirement': function dmnAuthorityRequirement(p, element, attrs) {

        attrs = assign({
          strokeWidth: 1.5,
          strokeDasharray: 5,
          strokeLinecap: 'round',
          strokeLinejoin: 'round',
          markerEnd: marker('authority-requirement-end')
        }, attrs || {});

        return drawLine(p, element.waypoints, attrs);
      }
    };

    // draw shape and connection //////////////////

    function drawShape(parent, element) {
      var h = handlers[element.type];

      if (!h) {
        return BaseRenderer.prototype.drawShape.apply(this, [parent, element]);
      } else {
        return h(parent, element);
      }
    }

    function drawConnection(parent, element) {
      var type = element.type;
      var h = handlers[type];

      if (!h) {
        return BaseRenderer.prototype.drawConnection.apply(this, [parent, element]);
      } else {
        return h(parent, element);
      }
    }

    function drawLine(p, waypoints, attrs) {
      attrs = computeStyle(attrs, ['no-fill'], {
        stroke: 'black',
        strokeWidth: 2,
        fill: 'none'
      });

      var line = createLine(waypoints, attrs);

      append(p, line);

      return line;
    }

    this.canRender = function (element) {
      return is(element, 'dmn:DMNElement') || is(element, 'dmn:InformationRequirement') || is(element, 'dmn:KnowledgeRequirement') || is(element, 'dmn:AuthorityRequirement');
    };

    this.drawShape = drawShape;
    this.drawConnection = drawConnection;

    // hook onto canvas init event to initialize
    // connection start/end markers on svg
    eventBus.on('canvas.init', function (event) {
      initMarkers(event.svg);
    });
  }

  inherits_browser(DrdRenderer, BaseRenderer);

  DrdRenderer.$inject = ['eventBus', 'pathMap', 'styles'];

  // helper functions //////////////////////

  function getSemantic(element) {
    return element.businessObject;
  }

  /* eslint-disable max-len */

  /**
   * Map containing SVG paths needed by BpmnRenderer.
   */

  function PathMap() {

    /**
     * Contains a map of path elements
     *
     * <h1>Path definition</h1>
     * A parameterized path is defined like this:
     * <pre>
     * 'GATEWAY_PARALLEL': {
     *   d: 'm {mx},{my} {e.x0},0 0,{e.x1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +
            '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',
     *   height: 17.5,
     *   width:  17.5,
     *   heightElements: [2.5, 7.5],
     *   widthElements: [2.5, 7.5]
     * }
     * </pre>
     * <p>It's important to specify a correct <b>height and width</b> for the path as the scaling
     * is based on the ratio between the specified height and width in this object and the
     * height and width that is set as scale target (Note x,y coordinates will be scaled with
     * individual ratios).</p>
     * <p>The '<b>heightElements</b>' and '<b>widthElements</b>' array must contain the values that will be scaled.
     * The scaling is based on the computed ratios.
     * Coordinates on the y axis should be in the <b>heightElement</b>'s array, they will be scaled using
     * the computed ratio coefficient.
     * In the parameterized path the scaled values can be accessed through the 'e' object in {} brackets.
     *   <ul>
     *    <li>The values for the y axis can be accessed in the path string using {e.y0}, {e.y1}, ....</li>
     *    <li>The values for the x axis can be accessed in the path string using {e.x0}, {e.x1}, ....</li>
     *   </ul>
     *   The numbers x0, x1 respectively y0, y1, ... map to the corresponding array index.
     * </p>
      m1,1
      l 0,55.3
      c 29.8,19.7 48.4,-4.2 67.2,-6.7
      c 12.2,-2.3 19.8,1.6 30.8,6.2
      l 0,-54.6
      z
      */
    this.pathMap = {
      'KNOWLEDGE_SOURCE': {
        d: 'm {mx},{my} ' + 'l 0,{e.y0} ' + 'c {e.x0},{e.y1} {e.x1},-{e.y2} {e.x2},-{e.y3} ' + 'c {e.x3},-{e.y4} {e.x4},{e.y5} {e.x5},{e.y6} ' + 'l 0,-{e.y7}z',
        width: 100,
        height: 65,
        widthElements: [29.8, 48.4, 67.2, 12.2, 19.8, 30.8],
        heightElements: [55.3, 19.7, 4.2, 6.7, 2.3, 1.6, 6.2, 54.6]
      },
      'BUSINESS_KNOWLEDGE_MODEL': {
        d: 'm {mx},{my} l {e.x0},-{e.y0} l {e.x1},0 l 0,{e.y1} l -{e.x2},{e.y2} l -{e.x3},0z',
        width: 125,
        height: 45,
        widthElements: [13.8, 109.2, 13.8, 109.1],
        heightElements: [13.2, 29.8, 13.2]
      },
      'TEXT_ANNOTATION': {
        d: 'm {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0',
        width: 10,
        height: 30,
        widthElements: [10],
        heightElements: [30]
      }
    };

    this.getRawPath = function getRawPath(pathId) {
      return this.pathMap[pathId].d;
    };

    /**
     * Scales the path to the given height and width.
     * <h1>Use case</h1>
     * <p>Use case is to scale the content of elements (event, gateways) based
     * on the element bounding box's size.
     * </p>
     * <h1>Why not transform</h1>
     * <p>Scaling a path with transform() will also scale the stroke and IE does not support
     * the option 'non-scaling-stroke' to prevent this.
     * Also there are use cases where only some parts of a path should be
     * scaled.</p>
     *
     * @param {String} pathId The ID of the path.
     * @param {Object} param <p>
     *   Example param object scales the path to 60% size of the container (data.width, data.height).
     *   <pre>
     *   {
     *     xScaleFactor: 0.6,
     *     yScaleFactor:0.6,
     *     containerWidth: data.width,
     *     containerHeight: data.height,
     *     position: {
     *       mx: 0.46,
     *       my: 0.2,
     *     }
     *   }
     *   </pre>
     *   <ul>
     *    <li>targetpathwidth = xScaleFactor * containerWidth</li>
     *    <li>targetpathheight = yScaleFactor * containerHeight</li>
     *    <li>Position is used to set the starting coordinate of the path. M is computed:
      *    <ul>
      *      <li>position.x * containerWidth</li>
      *      <li>position.y * containerHeight</li>
      *    </ul>
      *    Center of the container <pre> position: {
     *       mx: 0.5,
     *       my: 0.5,
     *     }</pre>
     *     Upper left corner of the container
     *     <pre> position: {
     *       mx: 0.0,
     *       my: 0.0,
     *     }</pre>
     *    </li>
     *   </ul>
     * </p>
     *
     */
    this.getScaledPath = function getScaledPath(pathId, param) {
      var rawPath = this.pathMap[pathId];

      // positioning
      // compute the start point of the path
      var mx, my;

      if (param.abspos) {
        mx = param.abspos.x;
        my = param.abspos.y;
      } else {
        mx = param.containerWidth * param.position.mx;
        my = param.containerHeight * param.position.my;
      }

      var coordinates = {}; // map for the scaled coordinates
      if (param.position) {

        // path
        var heightRatio = param.containerHeight / rawPath.height * param.yScaleFactor;
        var widthRatio = param.containerWidth / rawPath.width * param.xScaleFactor;

        // Apply height ratio
        for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {
          coordinates['y' + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;
        }

        // Apply width ratio
        for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {
          coordinates['x' + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;
        }
      }

      // Apply value to raw path
      var path = format(rawPath.d, {
        mx: mx,
        my: my,
        e: coordinates
      });
      return path;
    };
  }

  // helpers //////////////////////

  // copied from https://github.com/adobe-webplatform/Snap.svg/blob/master/src/svg.js
  var tokenRegex = /\{([^}]+)\}/g,
      objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g; // matches .xxxxx or ["xxxxx"] to run over object properties

  function replacer(all, key, obj) {
    var res = obj;
    key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
      name = name || quotedName;
      if (res) {
        if (name in res) {
          res = res[name];
        }
        typeof res == 'function' && isFunc && (res = res());
      }
    });
    res = (res == null || res == obj ? all : res) + '';

    return res;
  }

  function format(str, obj) {
    return String(str).replace(tokenRegex, function (all, key) {
      return replacer(all, key, obj);
    });
  }

  var DrawModule$1 = {
    __init__: ['drdRenderer'],
    drdRenderer: ['type', DrdRenderer],
    pathMap: ['type', PathMap]
  };

  function elementData(semantic, attrs) {
    return assign({
      id: semantic.id,
      type: semantic.$type,
      businessObject: semantic
    }, attrs);
  }

  function getHREF(element) {
    return element && element.href.slice(1);
  }

  function collectWaypoints(edge) {
    var waypoints = edge.waypoints;

    if (waypoints) {
      return map(waypoints, function (waypoint) {
        var position = { x: waypoint.x, y: waypoint.y };

        return assign({ original: position }, position);
      });
    }
  }

  function DrdImporter(eventBus, canvas, elementFactory, elementRegistry) {

    this._eventBus = eventBus;
    this._canvas = canvas;
    this._elementRegistry = elementRegistry;
    this._elementFactory = elementFactory;
  }

  DrdImporter.$inject = ['eventBus', 'canvas', 'elementFactory', 'elementRegistry'];

  DrdImporter.prototype.root = function (diagram) {
    var element = this._elementFactory.createRoot(elementData(diagram));

    this._canvas.setRootElement(element);

    return element;
  };

  /**
   * Add drd element (semantic) to the canvas.
   */
  DrdImporter.prototype.add = function (semantic, di) {
    var elementFactory = this._elementFactory,
        canvas = this._canvas,
        eventBus = this._eventBus;

    var element, waypoints, sourceShape, targetShape, elementDefinition, sourceID, targetID;

    if (di.$instanceOf('biodi:Bounds')) {
      elementDefinition = elementData(semantic, {
        x: Math.round(di.x),
        y: Math.round(di.y),
        width: Math.round(di.width),
        height: Math.round(di.height)
      });

      element = elementFactory.createShape(elementDefinition);

      canvas.addShape(element);

      eventBus.fire('drdElement.added', { element: element, di: di });
    } else if (di.$instanceOf('biodi:Edge')) {
      waypoints = collectWaypoints(di);

      sourceID = di.source;
      targetID = semantic.$parent.id;

      if (is(semantic, 'dmn:Association')) {
        targetID = getHREF(semantic.targetRef);
      }

      sourceShape = this._getShape(sourceID);
      targetShape = this._getShape(targetID);

      if (sourceShape && targetShape) {
        elementDefinition = elementData(semantic, {
          hidden: false,
          source: sourceShape,
          target: targetShape,
          waypoints: waypoints
        });

        element = elementFactory.createConnection(elementDefinition);

        canvas.addConnection(element);

        eventBus.fire('drdElement.added', { element: element, di: di });
      }
    } else {
      throw new Error('unknown di for element ' + semantic.id);
    }

    return element;
  };

  DrdImporter.prototype._getShape = function (id) {
    return this._elementRegistry.get(id);
  };

  var ImportModule = {
    drdImporter: ['type', DrdImporter]
  };

  var CoreModule$1 = {
    __depends__: [DrawModule$1, ImportModule]
  };

  /**
   * A simple translation stub to be used for multi-language support
   * in diagrams. Can be easily replaced with a more sophisticated
   * solution.
   *
   * @example
   *
   * // use it inside any diagram component by injecting `translate`.
   *
   * function MyService(translate) {
   *   alert(translate('HELLO {you}', { you: 'You!' }));
   * }
   *
   * @param {String} template to interpolate
   * @param {Object} [replacements] a map with substitutes
   *
   * @return {String} the translated string
   */
  function translate$1(template, replacements) {

    replacements = replacements || {};

    return template.replace(/{([^}]+)}/g, function (_, key) {
      return replacements[key] || '{' + key + '}';
    });
  }

  var DiagramTranslate = {
    translate: ['value', translate$1]
  };

  function __stopPropagation(event) {
    if (!event || typeof event.stopPropagation !== 'function') {
      return;
    }

    event.stopPropagation();
  }

  function getOriginal(event) {
    return event.originalEvent || event.srcEvent;
  }

  function stopPropagation(event, immediate) {
    __stopPropagation(event, immediate);
    __stopPropagation(getOriginal(event), immediate);
  }

  function toPoint(event) {

    if (event.pointers && event.pointers.length) {
      event = event.pointers[0];
    }

    if (event.touches && event.touches.length) {
      event = event.touches[0];
    }

    return event ? {
      x: event.clientX,
      y: event.clientY
    } : null;
  }

  function isMac() {
    return (/mac/i.test(navigator.platform)
    );
  }

  function isPrimaryButton(event) {
    // button === 0 -> left áka primary mouse button
    return !(getOriginal(event) || event).button;
  }

  function hasPrimaryModifier(event) {
    var originalEvent = getOriginal(event) || event;

    if (!isPrimaryButton(event)) {
      return false;
    }

    // Use alt as primary modifier key for mac OS
    if (isMac()) {
      return originalEvent.metaKey;
    } else {
      return originalEvent.ctrlKey;
    }
  }

  function hasSecondaryModifier(event) {
    var originalEvent = getOriginal(event) || event;

    return isPrimaryButton(event) && originalEvent.shiftKey;
  }

  function allowAll(e) {
    return true;
  }

  var LOW_PRIORITY = 500;

  /**
   * A plugin that provides interaction events for diagram elements.
   *
   * It emits the following events:
   *
   *   * element.hover
   *   * element.out
   *   * element.click
   *   * element.dblclick
   *   * element.mousedown
   *   * element.contextmenu
   *
   * Each event is a tuple { element, gfx, originalEvent }.
   *
   * Canceling the event via Event#preventDefault()
   * prevents the original DOM operation.
   *
   * @param {EventBus} eventBus
   */
  function InteractionEvents(eventBus, elementRegistry, styles) {

    var HIT_STYLE = styles.cls('djs-hit', ['no-fill', 'no-border'], {
      stroke: 'white',
      strokeWidth: 15
    });

    /**
     * Fire an interaction event.
     *
     * @param {String} type local event name, e.g. element.click.
     * @param {DOMEvent} event native event
     * @param {djs.model.Base} [element] the diagram element to emit the event on;
     *                                   defaults to the event target
     */
    function fire(type, event, element) {

      if (isIgnored(type, event)) {
        return;
      }

      var target, gfx, returnValue;

      if (!element) {
        target = event.delegateTarget || event.target;

        if (target) {
          gfx = target;
          element = elementRegistry.get(gfx);
        }
      } else {
        gfx = elementRegistry.getGraphics(element);
      }

      if (!gfx || !element) {
        return;
      }

      returnValue = eventBus.fire(type, {
        element: element,
        gfx: gfx,
        originalEvent: event
      });

      if (returnValue === false) {
        event.stopPropagation();
        event.preventDefault();
      }
    }

    // TODO(nikku): document this
    var handlers = {};

    function mouseHandler(localEventName) {
      return handlers[localEventName];
    }

    function isIgnored(localEventName, event) {

      var filter$$1 = ignoredFilters[localEventName] || isPrimaryButton;

      // only react on left mouse button interactions
      // except for interaction events that are enabled
      // for secundary mouse button
      return !filter$$1(event);
    }

    var bindings = {
      mouseover: 'element.hover',
      mouseout: 'element.out',
      click: 'element.click',
      dblclick: 'element.dblclick',
      mousedown: 'element.mousedown',
      mouseup: 'element.mouseup',
      contextmenu: 'element.contextmenu'
    };

    var ignoredFilters = {
      'element.contextmenu': allowAll
    };

    // manual event trigger

    /**
     * Trigger an interaction event (based on a native dom event)
     * on the target shape or connection.
     *
     * @param {String} eventName the name of the triggered DOM event
     * @param {MouseEvent} event
     * @param {djs.model.Base} targetElement
     */
    function triggerMouseEvent(eventName, event, targetElement) {

      // i.e. element.mousedown...
      var localEventName = bindings[eventName];

      if (!localEventName) {
        throw new Error('unmapped DOM event name <' + eventName + '>');
      }

      return fire(localEventName, event, targetElement);
    }

    var elementSelector = 'svg, .djs-element';

    // event registration

    function registerEvent(node, event, localEvent, ignoredFilter) {

      var handler = handlers[localEvent] = function (event) {
        fire(localEvent, event);
      };

      if (ignoredFilter) {
        ignoredFilters[localEvent] = ignoredFilter;
      }

      handler.$delegate = delegateEvents.bind(node, elementSelector, event, handler);
    }

    function unregisterEvent(node, event, localEvent) {

      var handler = mouseHandler(localEvent);

      if (!handler) {
        return;
      }

      delegateEvents.unbind(node, event, handler.$delegate);
    }

    function registerEvents(svg) {
      forEach(bindings, function (val, key) {
        registerEvent(svg, key, val);
      });
    }

    function unregisterEvents(svg) {
      forEach(bindings, function (val, key) {
        unregisterEvent(svg, key, val);
      });
    }

    eventBus.on('canvas.destroy', function (event) {
      unregisterEvents(event.svg);
    });

    eventBus.on('canvas.init', function (event) {
      registerEvents(event.svg);
    });

    eventBus.on(['shape.added', 'connection.added'], function (event) {
      var element = event.element,
          gfx = event.gfx,
          hit;

      if (element.waypoints) {
        hit = createLine(element.waypoints);
      } else {
        hit = create('rect');
        attr$1(hit, {
          x: 0,
          y: 0,
          width: element.width,
          height: element.height
        });
      }

      attr$1(hit, HIT_STYLE);

      append(gfx, hit);
    });

    // Update djs-hit on change.
    // A low priortity is necessary, because djs-hit of labels has to be updated
    // after the label bounds have been updated in the renderer.
    eventBus.on('shape.changed', LOW_PRIORITY, function (event) {

      var element = event.element,
          gfx = event.gfx,
          hit = query('.djs-hit', gfx);

      attr$1(hit, {
        width: element.width,
        height: element.height
      });
    });

    eventBus.on('connection.changed', function (event) {

      var element = event.element,
          gfx = event.gfx,
          hit = query('.djs-hit', gfx);

      updateLine(hit, element.waypoints);
    });

    // API

    this.fire = fire;

    this.triggerMouseEvent = triggerMouseEvent;

    this.mouseHandler = mouseHandler;

    this.registerEvent = registerEvent;
    this.unregisterEvent = unregisterEvent;
  }

  InteractionEvents.$inject = ['eventBus', 'elementRegistry', 'styles'];

  /**
   * An event indicating that the mouse hovered over an element
   *
   * @event element.hover
   *
   * @type {Object}
   * @property {djs.model.Base} element
   * @property {SVGElement} gfx
   * @property {Event} originalEvent
   */

  /**
   * An event indicating that the mouse has left an element
   *
   * @event element.out
   *
   * @type {Object}
   * @property {djs.model.Base} element
   * @property {SVGElement} gfx
   * @property {Event} originalEvent
   */

  /**
   * An event indicating that the mouse has clicked an element
   *
   * @event element.click
   *
   * @type {Object}
   * @property {djs.model.Base} element
   * @property {SVGElement} gfx
   * @property {Event} originalEvent
   */

  /**
   * An event indicating that the mouse has double clicked an element
   *
   * @event element.dblclick
   *
   * @type {Object}
   * @property {djs.model.Base} element
   * @property {SVGElement} gfx
   * @property {Event} originalEvent
   */

  /**
   * An event indicating that the mouse has gone down on an element.
   *
   * @event element.mousedown
   *
   * @type {Object}
   * @property {djs.model.Base} element
   * @property {SVGElement} gfx
   * @property {Event} originalEvent
   */

  /**
   * An event indicating that the mouse has gone up on an element.
   *
   * @event element.mouseup
   *
   * @type {Object}
   * @property {djs.model.Base} element
   * @property {SVGElement} gfx
   * @property {Event} originalEvent
   */

  /**
   * An event indicating that the context menu action is triggered
   * via mouse or touch controls.
   *
   * @event element.contextmenu
   *
   * @type {Object}
   * @property {djs.model.Base} element
   * @property {SVGElement} gfx
   * @property {Event} originalEvent
   */

  var InteractionEventsModule = {
    __init__: ['interactionEvents'],
    interactionEvents: ['type', InteractionEvents]
  };

  var LOW_PRIORITY$1 = 500;

  /**
   * @class
   *
   * A plugin that adds an outline to shapes and connections that may be activated and styled
   * via CSS classes.
   *
   * @param {EventBus} eventBus
   * @param {Styles} styles
   * @param {ElementRegistry} elementRegistry
   */
  function Outline(eventBus, styles, elementRegistry) {

    this.offset = 6;

    var OUTLINE_STYLE = styles.cls('djs-outline', ['no-fill']);

    var self = this;

    function createOutline(gfx, bounds) {
      var outline = create('rect');

      attr$1(outline, assign({
        x: 10,
        y: 10,
        width: 100,
        height: 100
      }, OUTLINE_STYLE));

      append(gfx, outline);

      return outline;
    }

    // A low priortity is necessary, because outlines of labels have to be updated
    // after the label bounds have been updated in the renderer.
    eventBus.on(['shape.added', 'shape.changed'], LOW_PRIORITY$1, function (event) {
      var element = event.element,
          gfx = event.gfx;

      var outline = query('.djs-outline', gfx);

      if (!outline) {
        outline = createOutline(gfx, element);
      }

      self.updateShapeOutline(outline, element);
    });

    eventBus.on(['connection.added', 'connection.changed'], function (event) {
      var element = event.element,
          gfx = event.gfx;

      var outline = query('.djs-outline', gfx);

      if (!outline) {
        outline = createOutline(gfx, element);
      }

      self.updateConnectionOutline(outline, element);
    });
  }

  /**
   * Updates the outline of a shape respecting the dimension of the
   * element and an outline offset.
   *
   * @param  {SVGElement} outline
   * @param  {djs.model.Base} element
   */
  Outline.prototype.updateShapeOutline = function (outline, element) {

    attr$1(outline, {
      x: -this.offset,
      y: -this.offset,
      width: element.width + this.offset * 2,
      height: element.height + this.offset * 2
    });
  };

  /**
   * Updates the outline of a connection respecting the bounding box of
   * the connection and an outline offset.
   *
   * @param  {SVGElement} outline
   * @param  {djs.model.Base} element
   */
  Outline.prototype.updateConnectionOutline = function (outline, connection) {

    var bbox = getBBox(connection);

    attr$1(outline, {
      x: bbox.x - this.offset,
      y: bbox.y - this.offset,
      width: bbox.width + this.offset * 2,
      height: bbox.height + this.offset * 2
    });
  };

  Outline.$inject = ['eventBus', 'styles', 'elementRegistry'];

  var OutlineModule = {
    __init__: ['outline'],
    outline: ['type', Outline]
  };

  /**
   * A service that offers the current selection in a diagram.
   * Offers the api to control the selection, too.
   *
   * @class
   *
   * @param {EventBus} eventBus the event bus
   */
  function Selection(eventBus) {

    this._eventBus = eventBus;

    this._selectedElements = [];

    var self = this;

    eventBus.on(['shape.remove', 'connection.remove'], function (e) {
      var element = e.element;
      self.deselect(element);
    });

    eventBus.on(['diagram.clear'], function (e) {
      self.select(null);
    });
  }

  Selection.$inject = ['eventBus'];

  Selection.prototype.deselect = function (element) {
    var selectedElements = this._selectedElements;

    var idx = selectedElements.indexOf(element);

    if (idx !== -1) {
      var oldSelection = selectedElements.slice();

      selectedElements.splice(idx, 1);

      this._eventBus.fire('selection.changed', { oldSelection: oldSelection, newSelection: selectedElements });
    }
  };

  Selection.prototype.get = function () {
    return this._selectedElements;
  };

  Selection.prototype.isSelected = function (element) {
    return this._selectedElements.indexOf(element) !== -1;
  };

  /**
   * This method selects one or more elements on the diagram.
   *
   * By passing an additional add parameter you can decide whether or not the element(s)
   * should be added to the already existing selection or not.
   *
   * @method Selection#select
   *
   * @param  {Object|Object[]} elements element or array of elements to be selected
   * @param  {boolean} [add] whether the element(s) should be appended to the current selection, defaults to false
   */
  Selection.prototype.select = function (elements, add) {
    var selectedElements = this._selectedElements,
        oldSelection = selectedElements.slice();

    if (!isArray(elements)) {
      elements = elements ? [elements] : [];
    }

    // selection may be cleared by passing an empty array or null
    // to the method
    if (add) {
      forEach(elements, function (element) {
        if (selectedElements.indexOf(element) !== -1) {
          // already selected
          return;
        } else {
          selectedElements.push(element);
        }
      });
    } else {
      this._selectedElements = selectedElements = elements.slice();
    }

    this._eventBus.fire('selection.changed', { oldSelection: oldSelection, newSelection: selectedElements });
  };

  var MARKER_HOVER = 'hover',
      MARKER_SELECTED = 'selected';

  /**
   * A plugin that adds a visible selection UI to shapes and connections
   * by appending the <code>hover</code> and <code>selected</code> classes to them.
   *
   * @class
   *
   * Makes elements selectable, too.
   *
   * @param {EventBus} events
   * @param {SelectionService} selection
   * @param {Canvas} canvas
   */
  function SelectionVisuals(events, canvas, selection, styles) {

    this._multiSelectionBox = null;

    function addMarker(e, cls) {
      canvas.addMarker(e, cls);
    }

    function removeMarker(e, cls) {
      canvas.removeMarker(e, cls);
    }

    events.on('element.hover', function (event) {
      addMarker(event.element, MARKER_HOVER);
    });

    events.on('element.out', function (event) {
      removeMarker(event.element, MARKER_HOVER);
    });

    events.on('selection.changed', function (event) {

      function deselect(s) {
        removeMarker(s, MARKER_SELECTED);
      }

      function select(s) {
        addMarker(s, MARKER_SELECTED);
      }

      var oldSelection = event.oldSelection,
          newSelection = event.newSelection;

      forEach(oldSelection, function (e) {
        if (newSelection.indexOf(e) === -1) {
          deselect(e);
        }
      });

      forEach(newSelection, function (e) {
        if (oldSelection.indexOf(e) === -1) {
          select(e);
        }
      });
    });
  }

  SelectionVisuals.$inject = ['eventBus', 'canvas', 'selection', 'styles'];

  function SelectionBehavior(eventBus, selection, canvas, elementRegistry) {

    eventBus.on('create.end', 500, function (e) {

      // select the created shape after a
      // successful create operation
      if (e.context.canExecute) {
        selection.select(e.context.shape);
      }
    });

    eventBus.on('connect.end', 500, function (e) {

      // select the connect end target
      // after a connect operation
      if (e.context.canExecute && e.context.target) {
        selection.select(e.context.target);
      }
    });

    eventBus.on('shape.move.end', 500, function (e) {
      var previousSelection = e.previousSelection || [];

      var shape = elementRegistry.get(e.context.shape.id);

      // make sure at least the main moved element is being
      // selected after a move operation
      var inSelection = find(previousSelection, function (selectedShape) {
        return shape.id === selectedShape.id;
      });

      if (!inSelection) {
        selection.select(shape);
      }
    });

    // Shift + click selection
    eventBus.on('element.click', function (event) {

      var element = event.element;

      // do not select the root element
      // or connections
      if (element === canvas.getRootElement()) {
        element = null;
      }

      var isSelected = selection.isSelected(element),
          isMultiSelect = selection.get().length > 1;

      // mouse-event: SELECTION_KEY
      var add = hasPrimaryModifier(event);

      // select OR deselect element in multi selection
      if (isSelected && isMultiSelect) {
        if (add) {
          return selection.deselect(element);
        } else {
          return selection.select(element);
        }
      } else if (!isSelected) {
        selection.select(element, add);
      } else {
        selection.deselect(element);
      }
    });
  }

  SelectionBehavior.$inject = ['eventBus', 'selection', 'canvas', 'elementRegistry'];

  var DiagramSelection = {
    __init__: ['selectionVisuals', 'selectionBehavior'],
    __depends__: [InteractionEventsModule, OutlineModule],
    selection: ['type', Selection],
    selectionVisuals: ['type', SelectionVisuals],
    selectionBehavior: ['type', SelectionBehavior]
  };

  /**
   * Util that provides unique IDs.
   *
   * @class djs.util.IdGenerator
   * @constructor
   * @memberOf djs.util
   *
   * The ids can be customized via a given prefix and contain a random value to avoid collisions.
   *
   * @param {String} prefix a prefix to prepend to generated ids (for better readability)
   */
  function IdGenerator(prefix) {

    this._counter = 0;
    this._prefix = (prefix ? prefix + '-' : '') + Math.floor(Math.random() * 1000000000) + '-';
  }

  /**
   * Returns a next unique ID.
   *
   * @method djs.util.IdGenerator#next
   *
   * @returns {String} the id
   */
  IdGenerator.prototype.next = function () {
    return this._prefix + ++this._counter;
  };

  // document wide unique overlay ids
  var ids$1 = new IdGenerator('ov');

  var LOW_PRIORITY$2 = 500;

  function createRoot(parent) {
    var root = domify('<div class="djs-overlay-container" style="position: absolute; width: 0; height: 0;" />');
    parent.insertBefore(root, parent.firstChild);

    return root;
  }

  function setPosition(el, x, y) {
    assign(el.style, { left: x + 'px', top: y + 'px' });
  }

  function setVisible(el, visible) {
    el.style.display = visible === false ? 'none' : '';
  }

  function setTransform(el, transform) {

    el.style['transform-origin'] = 'top left';

    ['', '-ms-', '-webkit-'].forEach(function (prefix) {
      el.style[prefix + 'transform'] = transform;
    });
  }

  function isDef(o) {
    return typeof o !== 'undefined';
  }

  /**
   * A service that allows users to attach overlays to diagram elements.
   *
   * The overlay service will take care of overlay positioning during updates.
   *
   * @example
   *
   * // add a pink badge on the top left of the shape
   * overlays.add(someShape, {
   *   position: {
   *     top: -5,
   *     left: -5
   *   },
   *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
   * });
   *
   * // or add via shape id
   *
   * overlays.add('some-element-id', {
   *   position: {
   *     top: -5,
   *     left: -5
   *   }
   *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
   * });
   *
   * // or add with optional type
   *
   * overlays.add(someShape, 'badge', {
   *   position: {
   *     top: -5,
   *     left: -5
   *   }
   *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
   * });
   *
   *
   * // remove an overlay
   *
   * var id = overlays.add(...);
   * overlays.remove(id);
   *
   *
   * You may configure overlay defaults during tool by providing a `config` module
   * with `overlays.defaults` as an entry:
   *
   * {
   *   overlays: {
   *     defaults: {
   *       show: {
   *         minZoom: 0.7,
   *         maxZoom: 5.0
   *       },
   *       scale: {
   *         min: 1
   *       }
   *     }
   * }
   *
   * @param {Object} config
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   * @param {ElementRegistry} elementRegistry
   */
  function Overlays(config, eventBus, canvas, elementRegistry) {

    this._eventBus = eventBus;
    this._canvas = canvas;
    this._elementRegistry = elementRegistry;

    this._ids = ids$1;

    this._overlayDefaults = assign({
      // no show constraints
      show: null,

      // always scale
      scale: true
    }, config && config.defaults);

    /**
     * Mapping overlayId -> overlay
     */
    this._overlays = {};

    /**
     * Mapping elementId -> overlay container
     */
    this._overlayContainers = [];

    // root html element for all overlays
    this._overlayRoot = createRoot(canvas.getContainer());

    this._init();
  }

  Overlays.$inject = ['config.overlays', 'eventBus', 'canvas', 'elementRegistry'];

  /**
   * Returns the overlay with the specified id or a list of overlays
   * for an element with a given type.
   *
   * @example
   *
   * // return the single overlay with the given id
   * overlays.get('some-id');
   *
   * // return all overlays for the shape
   * overlays.get({ element: someShape });
   *
   * // return all overlays on shape with type 'badge'
   * overlays.get({ element: someShape, type: 'badge' });
   *
   * // shape can also be specified as id
   * overlays.get({ element: 'element-id', type: 'badge' });
   *
   *
   * @param {Object} search
   * @param {String} [search.id]
   * @param {String|djs.model.Base} [search.element]
   * @param {String} [search.type]
   *
   * @return {Object|Array<Object>} the overlay(s)
   */
  Overlays.prototype.get = function (search) {

    if (isString(search)) {
      search = { id: search };
    }

    if (isString(search.element)) {
      search.element = this._elementRegistry.get(search.element);
    }

    if (search.element) {
      var container = this._getOverlayContainer(search.element, true);

      // return a list of overlays when searching by element (+type)
      if (container) {
        return search.type ? filter(container.overlays, matchPattern({ type: search.type })) : container.overlays.slice();
      } else {
        return [];
      }
    } else if (search.type) {
      return filter(this._overlays, matchPattern({ type: search.type }));
    } else {
      // return single element when searching by id
      return search.id ? this._overlays[search.id] : null;
    }
  };

  /**
   * Adds a HTML overlay to an element.
   *
   * @param {String|djs.model.Base}   element   attach overlay to this shape
   * @param {String}                  [type]    optional type to assign to the overlay
   * @param {Object}                  overlay   the overlay configuration
   *
   * @param {String|DOMElement}       overlay.html                 html element to use as an overlay
   * @param {Object}                  [overlay.show]               show configuration
   * @param {Number}                  [overlay.show.minZoom]       minimal zoom level to show the overlay
   * @param {Number}                  [overlay.show.maxZoom]       maximum zoom level to show the overlay
   * @param {Object}                  overlay.position             where to attach the overlay
   * @param {Number}                  [overlay.position.left]      relative to element bbox left attachment
   * @param {Number}                  [overlay.position.top]       relative to element bbox top attachment
   * @param {Number}                  [overlay.position.bottom]    relative to element bbox bottom attachment
   * @param {Number}                  [overlay.position.right]     relative to element bbox right attachment
   * @param {Boolean|Object}          [overlay.scale=true]         false to preserve the same size regardless of
   *                                                               diagram zoom
   * @param {Number}                  [overlay.scale.min]
   * @param {Number}                  [overlay.scale.max]
   *
   * @return {String}                 id that may be used to reference the overlay for update or removal
   */
  Overlays.prototype.add = function (element, type, overlay) {

    if (isObject(type)) {
      overlay = type;
      type = null;
    }

    if (!element.id) {
      element = this._elementRegistry.get(element);
    }

    if (!overlay.position) {
      throw new Error('must specifiy overlay position');
    }

    if (!overlay.html) {
      throw new Error('must specifiy overlay html');
    }

    if (!element) {
      throw new Error('invalid element specified');
    }

    var id = this._ids.next();

    overlay = assign({}, this._overlayDefaults, overlay, {
      id: id,
      type: type,
      element: element,
      html: overlay.html
    });

    this._addOverlay(overlay);

    return id;
  };

  /**
   * Remove an overlay with the given id or all overlays matching the given filter.
   *
   * @see Overlays#get for filter options.
   *
   * @param {String} [id]
   * @param {Object} [filter]
   */
  Overlays.prototype.remove = function (filter$$1) {

    var overlays = this.get(filter$$1) || [];

    if (!isArray(overlays)) {
      overlays = [overlays];
    }

    var self = this;

    forEach(overlays, function (overlay) {

      var container = self._getOverlayContainer(overlay.element, true);

      if (overlay) {
        remove(overlay.html);
        remove(overlay.htmlContainer);

        delete overlay.htmlContainer;
        delete overlay.element;

        delete self._overlays[overlay.id];
      }

      if (container) {
        var idx = container.overlays.indexOf(overlay);
        if (idx !== -1) {
          container.overlays.splice(idx, 1);
        }
      }
    });
  };

  Overlays.prototype.show = function () {
    setVisible(this._overlayRoot);
  };

  Overlays.prototype.hide = function () {
    setVisible(this._overlayRoot, false);
  };

  Overlays.prototype.clear = function () {
    this._overlays = {};

    this._overlayContainers = [];

    clear(this._overlayRoot);
  };

  Overlays.prototype._updateOverlayContainer = function (container) {
    var element = container.element,
        html = container.html;

    // update container left,top according to the elements x,y coordinates
    // this ensures we can attach child elements relative to this container

    var x = element.x,
        y = element.y;

    if (element.waypoints) {
      var bbox = getBBox(element);
      x = bbox.x;
      y = bbox.y;
    }

    setPosition(html, x, y);

    attr(container.html, 'data-container-id', element.id);
  };

  Overlays.prototype._updateOverlay = function (overlay) {

    var position = overlay.position,
        htmlContainer = overlay.htmlContainer,
        element = overlay.element;

    // update overlay html relative to shape because
    // it is already positioned on the element

    // update relative
    var left = position.left,
        top = position.top;

    if (position.right !== undefined) {

      var width;

      if (element.waypoints) {
        width = getBBox(element).width;
      } else {
        width = element.width;
      }

      left = position.right * -1 + width;
    }

    if (position.bottom !== undefined) {

      var height;

      if (element.waypoints) {
        height = getBBox(element).height;
      } else {
        height = element.height;
      }

      top = position.bottom * -1 + height;
    }

    setPosition(htmlContainer, left || 0, top || 0);
  };

  Overlays.prototype._createOverlayContainer = function (element) {
    var html = domify('<div class="djs-overlays" style="position: absolute" />');

    this._overlayRoot.appendChild(html);

    var container = {
      html: html,
      element: element,
      overlays: []
    };

    this._updateOverlayContainer(container);

    this._overlayContainers.push(container);

    return container;
  };

  Overlays.prototype._updateRoot = function (viewbox) {
    var scale = viewbox.scale || 1;

    var matrix = 'matrix(' + [scale, 0, 0, scale, -1 * viewbox.x * scale, -1 * viewbox.y * scale].join(',') + ')';

    setTransform(this._overlayRoot, matrix);
  };

  Overlays.prototype._getOverlayContainer = function (element, raw) {
    var container = find(this._overlayContainers, function (c) {
      return c.element === element;
    });

    if (!container && !raw) {
      return this._createOverlayContainer(element);
    }

    return container;
  };

  Overlays.prototype._addOverlay = function (overlay) {

    var id = overlay.id,
        element = overlay.element,
        html = overlay.html,
        htmlContainer,
        overlayContainer;

    // unwrap jquery (for those who need it)
    if (html.get && html.constructor.prototype.jquery) {
      html = html.get(0);
    }

    // create proper html elements from
    // overlay HTML strings
    if (isString(html)) {
      html = domify(html);
    }

    overlayContainer = this._getOverlayContainer(element);

    htmlContainer = domify('<div class="djs-overlay" data-overlay-id="' + id + '" style="position: absolute">');

    htmlContainer.appendChild(html);

    if (overlay.type) {
      classes(htmlContainer).add('djs-overlay-' + overlay.type);
    }

    overlay.htmlContainer = htmlContainer;

    overlayContainer.overlays.push(overlay);
    overlayContainer.html.appendChild(htmlContainer);

    this._overlays[id] = overlay;

    this._updateOverlay(overlay);
    this._updateOverlayVisibilty(overlay, this._canvas.viewbox());
  };

  Overlays.prototype._updateOverlayVisibilty = function (overlay, viewbox) {
    var show = overlay.show,
        minZoom = show && show.minZoom,
        maxZoom = show && show.maxZoom,
        htmlContainer = overlay.htmlContainer,
        visible = true;

    if (show) {
      if (isDef(minZoom) && minZoom > viewbox.scale || isDef(maxZoom) && maxZoom < viewbox.scale) {
        visible = false;
      }

      setVisible(htmlContainer, visible);
    }

    this._updateOverlayScale(overlay, viewbox);
  };

  Overlays.prototype._updateOverlayScale = function (overlay, viewbox) {
    var shouldScale = overlay.scale,
        minScale,
        maxScale,
        htmlContainer = overlay.htmlContainer;

    var scale,
        transform = '';

    if (shouldScale !== true) {

      if (shouldScale === false) {
        minScale = 1;
        maxScale = 1;
      } else {
        minScale = shouldScale.min;
        maxScale = shouldScale.max;
      }

      if (isDef(minScale) && viewbox.scale < minScale) {
        scale = (1 / viewbox.scale || 1) * minScale;
      }

      if (isDef(maxScale) && viewbox.scale > maxScale) {
        scale = (1 / viewbox.scale || 1) * maxScale;
      }
    }

    if (isDef(scale)) {
      transform = 'scale(' + scale + ',' + scale + ')';
    }

    setTransform(htmlContainer, transform);
  };

  Overlays.prototype._updateOverlaysVisibilty = function (viewbox) {

    var self = this;

    forEach(this._overlays, function (overlay) {
      self._updateOverlayVisibilty(overlay, viewbox);
    });
  };

  Overlays.prototype._init = function () {

    var eventBus = this._eventBus;

    var self = this;

    // scroll/zoom integration

    function updateViewbox(viewbox) {
      self._updateRoot(viewbox);
      self._updateOverlaysVisibilty(viewbox);

      self.show();
    }

    eventBus.on('canvas.viewbox.changing', function (event) {
      self.hide();
    });

    eventBus.on('canvas.viewbox.changed', function (event) {
      updateViewbox(event.viewbox);
    });

    // remove integration

    eventBus.on(['shape.remove', 'connection.remove'], function (e) {
      var element = e.element;
      var overlays = self.get({ element: element });

      forEach(overlays, function (o) {
        self.remove(o.id);
      });

      var container = self._getOverlayContainer(element);

      if (container) {
        remove(container.html);
        var i = self._overlayContainers.indexOf(container);
        if (i !== -1) {
          self._overlayContainers.splice(i, 1);
        }
      }
    });

    // move integration

    eventBus.on('element.changed', LOW_PRIORITY$2, function (e) {
      var element = e.element;

      var container = self._getOverlayContainer(element, true);

      if (container) {
        forEach(container.overlays, function (overlay) {
          self._updateOverlay(overlay);
        });

        self._updateOverlayContainer(container);
      }
    });

    // marker integration, simply add them on the overlays as classes, too.

    eventBus.on('element.marker.update', function (e) {
      var container = self._getOverlayContainer(e.element, true);
      if (container) {
        classes(container.html)[e.add ? 'add' : 'remove'](e.marker);
      }
    });

    // clear overlays with diagram

    eventBus.on('diagram.clear', this.clear, this);
  };

  var OverlaysModule = {
    __init__: ['overlays'],
    overlays: ['type', Overlays]
  };

  function DefinitionIdView(eventBus, canvas) {
    this._eventBus = eventBus;
    this._canvas = canvas;

    eventBus.on('diagram.init', function () {
      this._init();
    }, this);

    eventBus.on('import.done', function (event) {
      this.update();
    }, this);
  }

  DefinitionIdView.$inject = ['eventBus', 'canvas'];

  /**
   * Initialize
   */
  DefinitionIdView.prototype._init = function () {
    var canvas = this._canvas,
        eventBus = this._eventBus;

    var parent = canvas.getContainer(),
        container = this._container = domify(DefinitionIdView.HTML_MARKUP);

    parent.appendChild(container);

    this.nameElement = query('.dmn-definitions-name', this._container);
    this.idElement = query('.dmn-definitions-id', this._container);

    delegateEvents.bind(container, '.dmn-definitions-name, .dmn-definitions-id', 'mousedown', function (event) {
      event.stopPropagation();
    });

    eventBus.fire('definitionIdView.create', {
      html: container
    });
  };

  DefinitionIdView.prototype.update = function (newName) {
    var businessObject = this._canvas.getRootElement().businessObject;

    this.nameElement.textContent = businessObject.name;
    this.idElement.textContent = businessObject.id;
  };

  /* markup definition */

  DefinitionIdView.HTML_MARKUP = '<div class="dmn-definitions">' + '<div class="dmn-definitions-name" title="Definition Name"></div>' + '<div class="dmn-definitions-id" title="Definition ID"></div>' + '</div>';

  function PaletteAdapter(eventBus, canvas) {

    function toggleMarker(cls, on) {
      var container = canvas.getContainer();

      classes(container).toggle(cls, on);
    }

    eventBus.on('palette.create', function () {
      toggleMarker('with-palette', true);
    });

    eventBus.on('palette.changed', function (event) {
      toggleMarker('with-palette-two-column', event.twoColumn);
    });
  }

  PaletteAdapter.$inject = ['eventBus', 'canvas'];

  var DefinitionPropertiesViewer = {
    __init__: ['definitionPropertiesView', 'definitionPropertiesPaletteAdapter'],
    definitionPropertiesView: ['type', DefinitionIdView],
    definitionPropertiesPaletteAdapter: ['type', PaletteAdapter]
  };

  var _createClass$2 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var PROVIDERS = [{
    className: 'dmn-icon-decision-table',
    matches: function matches(el) {
      var businessObject = el.businessObject;

      return is(businessObject, 'dmn:Decision') && businessObject.decisionTable;
    }
  }, {
    className: 'dmn-icon-literal-expression',
    matches: function matches(el) {
      var businessObject = el.businessObject;

      return is(businessObject, 'dmn:Decision') && businessObject.literalExpression;
    }
  }];

  /**
   * Displays overlays that can be clicked in order to drill
   * down into a DMN 1.1 element.
   */

  var DrillDown = function () {
    function DrillDown(injector, eventBus, overlays, config) {
      var _this = this;

      _classCallCheck$2(this, DrillDown);

      this._injector = injector;
      this._eventBus = eventBus;
      this._overlays = overlays;

      this._config = config || { enabled: true };

      eventBus.on(['shape.added'], function (_ref) {
        var element = _ref.element;

        for (var i = 0; i < PROVIDERS.length; i++) {
          var _PROVIDERS$i = PROVIDERS[i],
              matches = _PROVIDERS$i.matches,
              className = _PROVIDERS$i.className;

          var editable = matches && matches(element);

          if (editable) {
            _this.addOverlay(element, className);
          }
        }
      });
    }

    /**
     * Add overlay to an element that enables drill down.
     *
     * @param {Object} element Element to add overlay to.
     * @param {string} className
     *        CSS class that will be added to overlay in order to display icon.
     */

    _createClass$2(DrillDown, [{
      key: 'addOverlay',
      value: function addOverlay(element, className) {
        var html = domify('\n      <div class="drill-down-overlay">\n        <span class="' + className + '"></span>\n      </div>\n    ');

        var overlayId = this._overlays.add(element, {
          position: {
            top: 2,
            left: 2
          },
          html: html
        });

        // TODO(nikku): can we remove renamed to drillDown.enabled
        if (this._config.enabled !== false) {
          classes(html).add('interactive');

          this.bindEventListener(element, html, overlayId);
        }
      }

      /**
       * @param {Object} element
       * @param {Object} overlay
       * @param {string} id
       */

    }, {
      key: 'bindEventListener',
      value: function bindEventListener(element, overlay, id) {
        var _this2 = this;

        var overlays = this._overlays,
            eventBus = this._eventBus;

        var overlaysRoot = overlays._overlayRoot;

        delegateEvents.bind(overlaysRoot, '[data-overlay-id="' + id + '"]', 'click', function () {

          var triggerDefault = eventBus.fire('drillDown.click', {
            element: element
          });

          if (triggerDefault === false) {
            return;
          }

          _this2.drillDown(element);
        });
      }

      /**
       * Drill down into the specific element.
       *
       * @param  {djs.model.Base} element
       *
       * @return {Boolean} whether drill down was executed
       */

    }, {
      key: 'drillDown',
      value: function drillDown(element) {

        var parent = this._injector.get('_parent', false);

        // no parent; skip drill down
        if (!parent) {
          return false;
        }

        var view = parent.getView(element.businessObject);

        // no view to drill down to
        if (!view) {
          return false;
        }

        parent.open(view);

        return true;
      }
    }]);

    return DrillDown;
  }();

  DrillDown.$inject = ['injector', 'eventBus', 'overlays', 'config.drillDown'];

  var DrillDownModule = {
    __depends__: [OverlaysModule],
    __init__: ['drillDown'],
    drillDown: ['type', DrillDown]
  };

  /**
   * This file must not be changed or exchanged.
   *
   * @see http://bpmn.io/license for more information.
   */

  // inlined ../../../../resources/logo.svg
  // eslint-disable-next-line
  var BPMNIO_LOGO_SVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 960 960"><path fill="#fff" d="M960 60v839c0 33-27 61-60 61H60c-33 0-60-27-60-60V60C0 27 27 0 60 0h839c34 0 61 27 61 60z"/><path fill="#52b415" d="M217 548a205 205 0 0 0-144 58 202 202 0 0 0-4 286 202 202 0 0 0 285 3 200 200 0 0 0 48-219 203 203 0 0 0-185-128zM752 6a206 206 0 0 0-192 285 206 206 0 0 0 269 111 207 207 0 0 0 111-260A204 204 0 0 0 752 6zM62 0A62 62 0 0 0 0 62v398l60 46a259 259 0 0 1 89-36c5-28 10-57 14-85l99 2 12 85a246 246 0 0 1 88 38l70-52 69 71-52 68c17 30 29 58 35 90l86 14-2 100-86 12a240 240 0 0 1-38 89l43 58h413c37 0 60-27 60-61V407a220 220 0 0 1-44 40l21 85-93 39-45-76a258 258 0 0 1-98 1l-45 76-94-39 22-85a298 298 0 0 1-70-69l-86 22-38-94 76-45a258 258 0 0 1-1-98l-76-45 40-94 85 22a271 271 0 0 1 41-47z"/></svg>';
  var BPMNIO_LOGO_URL = 'data:image/svg+xml,' + encodeURIComponent(BPMNIO_LOGO_SVG);

  var BPMNIO_IMG = '<img width="52" height="52" src="' + BPMNIO_LOGO_URL + '" />';

  function css(attrs) {
    return attrs.join(';');
  }

  var LIGHTBOX_STYLES = css(['z-index: 1001', 'position: fixed', 'top: 0', 'left: 0', 'right: 0', 'bottom: 0']);

  var BACKDROP_STYLES = css(['width: 100%', 'height: 100%', 'background: rgba(0,0,0,0.2)']);

  var NOTICE_STYLES = css(['position: absolute', 'left: 50%', 'top: 40%', 'margin: 0 -130px', 'width: 260px', 'padding: 10px', 'background: white', 'border: solid 1px #AAA', 'border-radius: 3px', 'font-family: Helvetica, Arial, sans-serif', 'font-size: 14px', 'line-height: 1.2em']);

  /* eslint-disable max-len */
  var LIGHTBOX_MARKUP = '<div class="bjs-powered-by-lightbox" style="' + LIGHTBOX_STYLES + '">' + '<div class="backdrop" style="' + BACKDROP_STYLES + '"></div>' + '<div class="notice" style="' + NOTICE_STYLES + '">' + '<a href="http://bpmn.io" target="_blank" style="float: left; margin-right: 10px">' + BPMNIO_IMG + '</a>' + 'Web-based tooling for BPMN, DMN and CMMN diagrams ' + 'powered by <a href="http://bpmn.io" target="_blank">bpmn.io</a>.' + '</div>' + '</div>';
  /* eslint-enable */

  var lightbox;

  function open() {

    if (!lightbox) {
      lightbox = domify(LIGHTBOX_MARKUP);

      delegateEvents.bind(lightbox, '.backdrop', 'click', function (event) {
        document.body.removeChild(lightbox);
      });
    }

    document.body.appendChild(lightbox);
  }

  var _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  function _toConsumableArray$3(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function _objectWithoutProperties(obj, keys) {
    var target = {};for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
    }return target;
  }

  /**
   * A viewer for DMN 1.1 diagrams.
   *
   * Have a look at {@link NavigatedViewer} or {@link Modeler} for bundles that include
   * additional features.
   *
   *
   * ## Extending the Viewer
   *
   * In order to extend the viewer pass extension modules to bootstrap via the
   * `additionalModules` option. An extension module is an object that exposes
   * named services.
   *
   * The following example depicts the integration of a simple
   * logging component that integrates with interaction events:
   *
   *
   * ```javascript
   *
   * // logging component
   * function InteractionLogger(eventBus) {
   *   eventBus.on('element.hover', function(event) {
   *     console.log()
   *   })
   * }
   *
   * InteractionLogger.$inject = [ 'eventBus' ]; // minification save
   *
   * // extension module
   * var extensionModule = {
   *   __init__: [ 'interactionLogger' ],
   *   interactionLogger: [ 'type', InteractionLogger ]
   * };
   *
   * // extend the viewer
   * var drdViewer = new Viewer({ additionalModules: [ extensionModule ] });
   * drdViewer.importXML(...);
   * ```
   *
   * @param {Object} options configuration options to pass to the viewer
   * @param {DOMElement} [options.container]
   *        the container to render the viewer in, defaults to body
   * @param {Array<didi.Module>} [options.modules]
   *        a list of modules to override the default modules
   * @param {Array<didi.Module>} [options.additionalModules]
   *        a list of modules to use with the default modules
   */
  function Viewer(options) {

    this._container = this._createContainer();

    /* <project-logo> */

    addProjectLogo(this._container);

    /* </project-logo> */

    this._init(this._container, options);
  }

  inherits_browser(Viewer, diagramJs);

  /**
   * Export the currently displayed DMN 1.1 diagram as
   * an SVG image.
   *
   * @param {Object} [options]
   * @param {Function} done invoked with (err, svgStr)
   */
  Viewer.prototype.saveSVG = function (options, done) {

    if (!done) {
      done = options;
      options = {};
    }

    var canvas = this.get('canvas');

    var contentNode = canvas.getDefaultLayer(),
        defsNode = query('defs', canvas._svg);

    var contents = innerSVG(contentNode),
        defs = defsNode && defsNode.outerHTML || '';

    var bbox = contentNode.getBBox();

    /* eslint-disable max-len */
    var svg = '<?xml version="1.0" encoding="utf-8"?>\n' + '<!-- created with dmn-js / http://bpmn.io -->\n' + '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' + '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'width="' + bbox.width + '" height="' + bbox.height + '" ' + 'viewBox="' + bbox.x + ' ' + bbox.y + ' ' + bbox.width + ' ' + bbox.height + '" version="1.1">' + defs + contents + '</svg>';
    /* eslint-enable */

    done(null, svg);
  };

  Viewer.prototype.getModules = function () {
    return this._modules;
  };

  /**
   * Destroy the viewer instance and remove all its
   * remainders from the document tree.
   */
  Viewer.prototype.destroy = function () {

    // diagram destroy
    diagramJs.prototype.destroy.call(this);

    // dom detach
    remove(this._container);
  };

  /**
   * Register an event listener
   *
   * Remove a previously added listener via {@link #off(event, callback)}.
   *
   * @param {String} event
   * @param {Number} [priority]
   * @param {Function} callback
   * @param {Object} [that]
   */
  Viewer.prototype.on = function (event$$1, priority, callback, target) {
    return this.get('eventBus').on(event$$1, priority, callback, target);
  };

  /**
   * De-register an event listener
   *
   * @param {String} event
   * @param {Function} callback
   */
  Viewer.prototype.off = function (event$$1, callback) {
    this.get('eventBus').off(event$$1, callback);
  };

  Viewer.prototype._init = function (container, options) {
    var additionalModules = options.additionalModules,
        canvas = options.canvas,
        additionalOptions = _objectWithoutProperties(options, ['additionalModules', 'canvas']);

    var baseModules = options.modules || this.getModules(),
        staticModules = [{
      drd: ['value', this]
    }];

    var modules = [].concat(staticModules, _toConsumableArray$3(baseModules), _toConsumableArray$3(additionalModules || []));

    var diagramOptions = _extends$2({}, additionalOptions, {
      canvas: _extends$2({}, canvas, {
        container: container
      }),
      modules: modules
    });

    // invoke diagram constructor
    diagramJs.call(this, diagramOptions);

    if (options && options.container) {
      this.attachTo(options.container);
    }
  };

  /**
   * Emit an event on the underlying {@link EventBus}
   *
   * @param  {String} type
   * @param  {Object} event
   *
   * @return {Object} event processing result (if any)
   */
  Viewer.prototype._emit = function (type, event$$1) {
    return this.get('eventBus').fire(type, event$$1);
  };

  Viewer.prototype._createContainer = function () {
    return domify('<div class="dmn-drd-container"></div>');
  };

  Viewer.prototype.open = function (definitions, done) {

    var err;

    // use try/catch to not swallow synchronous exceptions
    // that may be raised during model parsing
    try {

      if (this._definitions) {
        // clear existing rendered diagram
        this.clear();
      }

      // update definitions
      this._definitions = definitions;

      // perform graphical import
      return importDRD(this, definitions, done);
    } catch (e) {
      err = e;
    }

    return done(err);
  };

  /**
   * Attach viewer to given parent node.
   *
   * @param  {Element} parentNode
   */
  Viewer.prototype.attachTo = function (parentNode) {

    if (!parentNode) {
      throw new Error('parentNode required');
    }

    // ensure we detach from the
    // previous, old parent
    this.detach();

    var container = this._container;

    parentNode.appendChild(container);

    this._emit('attach', {});

    this.get('canvas').resized();
  };

  /**
   * Detach viewer from parent node, if attached.
   */
  Viewer.prototype.detach = function () {

    var container = this._container,
        parentNode = container.parentNode;

    if (!parentNode) {
      return;
    }

    this._emit('detach', {});

    parentNode.removeChild(container);
  };

  Viewer.prototype._modules = [CoreModule$1, DiagramTranslate, DiagramSelection, OverlaysModule, DefinitionPropertiesViewer, DrillDownModule];

  /**
   * Adds the project logo to the diagram container as
   * required by the bpmn.io license.
   *
   * @see http://bpmn.io/license
   *
   * @param {Element} container
   */
  function addProjectLogo(container) {
    var img = BPMNIO_IMG;

    var linkMarkup = '<a href="http://bpmn.io" ' + 'target="_blank" ' + 'class="bjs-powered-by" ' + 'title="Powered by bpmn.io" ' + 'style="position: absolute; bottom: 15px; right: 15px; z-index: 100">' + img + '</a>';

    var linkElement = domify(linkMarkup);

    container.appendChild(linkElement);

    componentEvent.bind(linkElement, 'click', function (event$$1) {
      open();

      event$$1.preventDefault();
    });
  }

  /* </project-logo> */

  function center(bounds) {
    return {
      x: bounds.x + bounds.width / 2,
      y: bounds.y + bounds.height / 2
    };
  }

  function delta(a, b) {
    return {
      x: a.x - b.x,
      y: a.y - b.y
    };
  }

  /**
   * Get the logarithm of x with base 10
   * @param  {Integer} value
   */
  function log10(x) {
    return Math.log(x) / Math.log(10);
  }

  /**
   * Get step size for given range and number of steps.
   *
   * @param {Object} range - Range.
   * @param {number} range.min - Range minimum.
   * @param {number} range.max - Range maximum.
   */
  function getStepSize(range, steps) {

    var minLinearRange = log10(range.min),
        maxLinearRange = log10(range.max);

    var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);

    return absoluteLinearRange / steps;
  }

  function cap(range, scale) {
    return Math.max(range.min, Math.min(range.max, scale));
  }

  var sign = Math.sign || function (n) {
    return n >= 0 ? 1 : -1;
  };

  var RANGE = { min: 0.2, max: 4 },
      NUM_STEPS = 10;

  var DELTA_THRESHOLD = 0.1;

  var DEFAULT_SCALE = 0.75;

  /**
   * An implementation of zooming and scrolling within the
   * {@link Canvas} via the mouse wheel.
   *
   * Mouse wheel zooming / scrolling may be disabled using
   * the {@link toggle(enabled)} method.
   *
   * @param {Object} [config]
   * @param {Boolean} [config.enabled=true] default enabled state
   * @param {Number} [config.scale=.75] scroll sensivity
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   */
  function ZoomScroll(config, eventBus, canvas) {

    config = config || {};

    this._enabled = false;

    this._canvas = canvas;
    this._container = canvas._container;

    this._handleWheel = bind(this._handleWheel, this);

    this._totalDelta = 0;
    this._scale = config.scale || DEFAULT_SCALE;

    var self = this;

    eventBus.on('canvas.init', function (e) {
      self._init(config.enabled !== false);
    });
  }

  ZoomScroll.$inject = ['config.zoomScroll', 'eventBus', 'canvas'];

  ZoomScroll.prototype.scroll = function scroll(delta$$1) {
    this._canvas.scroll(delta$$1);
  };

  ZoomScroll.prototype.reset = function reset() {
    this._canvas.zoom('fit-viewport');
  };

  /**
   * Zoom depending on delta.
   *
   * @param {number} delta - Zoom delta.
   * @param {Object} position - Zoom position.
   */
  ZoomScroll.prototype.zoom = function zoom(delta$$1, position) {

    // zoom with half the step size of stepZoom
    var stepSize = getStepSize(RANGE, NUM_STEPS * 2);

    // add until threshold reached
    this._totalDelta += delta$$1;

    if (Math.abs(this._totalDelta) > DELTA_THRESHOLD) {
      this._zoom(delta$$1, position, stepSize);

      // reset
      this._totalDelta = 0;
    }
  };

  ZoomScroll.prototype._handleWheel = function handleWheel(event$$1) {
    // event is already handled by '.djs-scrollable'
    if (closest(event$$1.target, '.djs-scrollable', true)) {
      return;
    }

    var element = this._container;

    event$$1.preventDefault();

    // pinch to zoom is mapped to wheel + ctrlKey = true
    // in modern browsers (!)

    var isZoom = event$$1.ctrlKey;

    var isHorizontalScroll = event$$1.shiftKey;

    var factor = -1 * this._scale,
        delta$$1;

    if (isZoom) {
      factor *= event$$1.deltaMode === 0 ? 0.020 : 0.32;
    } else {
      factor *= event$$1.deltaMode === 0 ? 1.0 : 16.0;
    }

    if (isZoom) {
      var elementRect = element.getBoundingClientRect();

      var offset = {
        x: event$$1.clientX - elementRect.left,
        y: event$$1.clientY - elementRect.top
      };

      delta$$1 = Math.sqrt(Math.pow(event$$1.deltaY, 2) + Math.pow(event$$1.deltaX, 2)) * sign(event$$1.deltaY) * factor;

      // zoom in relative to diagram {x,y} coordinates
      this.zoom(delta$$1, offset);
    } else {

      if (isHorizontalScroll) {
        delta$$1 = {
          dx: factor * event$$1.deltaY,
          dy: 0
        };
      } else {
        delta$$1 = {
          dx: factor * event$$1.deltaX,
          dy: factor * event$$1.deltaY
        };
      }

      this.scroll(delta$$1);
    }
  };

  /**
   * Zoom with fixed step size.
   *
   * @param {number} delta - Zoom delta (1 for zooming in, -1 for out).
   * @param {Object} position - Zoom position.
   */
  ZoomScroll.prototype.stepZoom = function stepZoom(delta$$1, position) {

    var stepSize = getStepSize(RANGE, NUM_STEPS);

    this._zoom(delta$$1, position, stepSize);
  };

  /**
   * Zoom in/out given a step size.
   *
   * @param {number} delta - Zoom delta. Can be positive or negative.
   * @param {Object} position - Zoom position.
   * @param {number} stepSize - Step size.
   */
  ZoomScroll.prototype._zoom = function (delta$$1, position, stepSize) {
    var canvas = this._canvas;

    var direction = delta$$1 > 0 ? 1 : -1;

    var currentLinearZoomLevel = log10(canvas.zoom());

    // snap to a proximate zoom step
    var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepSize) * stepSize;

    // increase or decrease one zoom step in the given direction
    newLinearZoomLevel += stepSize * direction;

    // calculate the absolute logarithmic zoom level based on the linear zoom level
    // (e.g. 2 for an absolute x2 zoom)
    var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);

    canvas.zoom(cap(RANGE, newLogZoomLevel), position);
  };

  /**
   * Toggle the zoom scroll ability via mouse wheel.
   *
   * @param  {Boolean} [newEnabled] new enabled state
   */
  ZoomScroll.prototype.toggle = function toggle(newEnabled) {

    var element = this._container;
    var handleWheel = this._handleWheel;

    var oldEnabled = this._enabled;

    if (typeof newEnabled === 'undefined') {
      newEnabled = !oldEnabled;
    }

    // only react on actual changes
    if (oldEnabled !== newEnabled) {

      // add or remove wheel listener based on
      // changed enabled state
      componentEvent[newEnabled ? 'bind' : 'unbind'](element, 'wheel', handleWheel, false);
    }

    this._enabled = newEnabled;

    return newEnabled;
  };

  ZoomScroll.prototype._init = function (newEnabled) {
    this.toggle(newEnabled);
  };

  var ZoomScrollModule = {
    __init__: ['zoomScroll'],
    zoomScroll: ['type', ZoomScroll]
  };

  var CURSOR_CLS_PATTERN = /^djs-cursor-.*$/;

  function set$1(mode) {
    var classes$$1 = classes(document.body);

    classes$$1.removeMatching(CURSOR_CLS_PATTERN);

    if (mode) {
      classes$$1.add('djs-cursor-' + mode);
    }
  }

  function unset() {
    set$1(null);
  }

  var TRAP_PRIORITY = 5000;

  /**
   * Installs a click trap that prevents a ghost click following a dragging operation.
   *
   * @return {Function} a function to immediately remove the installed trap.
   */
  function install(eventBus, eventName) {

    eventName = eventName || 'element.click';

    function trap() {
      return false;
    }

    eventBus.once(eventName, TRAP_PRIORITY, trap);

    return function () {
      eventBus.off(eventName, trap);
    };
  }

  function length(point) {
    return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
  }

  var THRESHOLD = 15;

  function MoveCanvas(eventBus, canvas) {

    var context;

    function handleMove(event$$1) {

      var start = context.start,
          position = toPoint(event$$1),
          delta$$1 = delta(position, start);

      if (!context.dragging && length(delta$$1) > THRESHOLD) {
        context.dragging = true;

        install(eventBus);

        set$1('grab');
      }

      if (context.dragging) {

        var lastPosition = context.last || context.start;

        delta$$1 = delta(position, lastPosition);

        canvas.scroll({
          dx: delta$$1.x,
          dy: delta$$1.y
        });

        context.last = position;
      }

      // prevent select
      event$$1.preventDefault();
    }

    function handleEnd(event$$1) {
      componentEvent.unbind(document, 'mousemove', handleMove);
      componentEvent.unbind(document, 'mouseup', handleEnd);

      context = null;

      unset();
    }

    function handleStart(event$$1) {
      // event is already handled by '.djs-draggable'
      if (closest(event$$1.target, '.djs-draggable')) {
        return;
      }

      // reject non-left left mouse button or modifier key
      if (event$$1.button || event$$1.ctrlKey || event$$1.shiftKey || event$$1.altKey) {
        return;
      }

      context = {
        start: toPoint(event$$1)
      };

      componentEvent.bind(document, 'mousemove', handleMove);
      componentEvent.bind(document, 'mouseup', handleEnd);

      // we've handled the event
      return true;
    }

    // listen for move on element mouse down;
    // allow others to hook into the event before us though
    // (dragging / element moving will do this)
    eventBus.on('element.mousedown', 500, function (e) {
      return handleStart(e.originalEvent);
    });
  }

  MoveCanvas.$inject = ['eventBus', 'canvas'];

  var MoveCanvas$1 = {
    __init__: ['moveCanvas'],
    moveCanvas: ['type', MoveCanvas]
  };

  var hammer = createCommonjsModule(function (module) {
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  /*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license */
  (function (window, document, exportName, undefined) {

      var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
      var TEST_ELEMENT = document.createElement('div');

      var TYPE_FUNCTION = 'function';

      var round = Math.round;
      var abs = Math.abs;
      var now = Date.now;

      /**
       * set a timeout with a given scope
       * @param {Function} fn
       * @param {Number} timeout
       * @param {Object} context
       * @returns {number}
       */
      function setTimeoutContext(fn, timeout, context) {
          return setTimeout(bindFn(fn, context), timeout);
      }

      /**
       * if the argument is an array, we want to execute the fn on each entry
       * if it aint an array we don't want to do a thing.
       * this is used by all the methods that accept a single and array argument.
       * @param {*|Array} arg
       * @param {String} fn
       * @param {Object} [context]
       * @returns {Boolean}
       */
      function invokeArrayArg(arg, fn, context) {
          if (Array.isArray(arg)) {
              each(arg, context[fn], context);
              return true;
          }
          return false;
      }

      /**
       * walk objects and arrays
       * @param {Object} obj
       * @param {Function} iterator
       * @param {Object} context
       */
      function each(obj, iterator, context) {
          var i;

          if (!obj) {
              return;
          }

          if (obj.forEach) {
              obj.forEach(iterator, context);
          } else if (obj.length !== undefined) {
              i = 0;
              while (i < obj.length) {
                  iterator.call(context, obj[i], i, obj);
                  i++;
              }
          } else {
              for (i in obj) {
                  obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
              }
          }
      }

      /**
       * wrap a method with a deprecation warning and stack trace
       * @param {Function} method
       * @param {String} name
       * @param {String} message
       * @returns {Function} A new function wrapping the supplied method.
       */
      function deprecate(method, name, message) {
          var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
          return function () {
              var e = new Error('get-stack-trace');
              var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

              var log = window.console && (window.console.warn || window.console.log);
              if (log) {
                  log.call(window.console, deprecationMessage, stack);
              }
              return method.apply(this, arguments);
          };
      }

      /**
       * extend object.
       * means that properties in dest will be overwritten by the ones in src.
       * @param {Object} target
       * @param {...Object} objects_to_assign
       * @returns {Object} target
       */
      var assign;
      if (typeof Object.assign !== 'function') {
          assign = function assign(target) {
              if (target === undefined || target === null) {
                  throw new TypeError('Cannot convert undefined or null to object');
              }

              var output = Object(target);
              for (var index = 1; index < arguments.length; index++) {
                  var source = arguments[index];
                  if (source !== undefined && source !== null) {
                      for (var nextKey in source) {
                          if (source.hasOwnProperty(nextKey)) {
                              output[nextKey] = source[nextKey];
                          }
                      }
                  }
              }
              return output;
          };
      } else {
          assign = Object.assign;
      }

      /**
       * extend object.
       * means that properties in dest will be overwritten by the ones in src.
       * @param {Object} dest
       * @param {Object} src
       * @param {Boolean} [merge=false]
       * @returns {Object} dest
       */
      var extend = deprecate(function extend(dest, src, merge) {
          var keys = Object.keys(src);
          var i = 0;
          while (i < keys.length) {
              if (!merge || merge && dest[keys[i]] === undefined) {
                  dest[keys[i]] = src[keys[i]];
              }
              i++;
          }
          return dest;
      }, 'extend', 'Use `assign`.');

      /**
       * merge the values from src in the dest.
       * means that properties that exist in dest will not be overwritten by src
       * @param {Object} dest
       * @param {Object} src
       * @returns {Object} dest
       */
      var merge = deprecate(function merge(dest, src) {
          return extend(dest, src, true);
      }, 'merge', 'Use `assign`.');

      /**
       * simple class inheritance
       * @param {Function} child
       * @param {Function} base
       * @param {Object} [properties]
       */
      function inherit(child, base, properties) {
          var baseP = base.prototype,
              childP;

          childP = child.prototype = Object.create(baseP);
          childP.constructor = child;
          childP._super = baseP;

          if (properties) {
              assign(childP, properties);
          }
      }

      /**
       * simple function bind
       * @param {Function} fn
       * @param {Object} context
       * @returns {Function}
       */
      function bindFn(fn, context) {
          return function boundFn() {
              return fn.apply(context, arguments);
          };
      }

      /**
       * let a boolean value also be a function that must return a boolean
       * this first item in args will be used as the context
       * @param {Boolean|Function} val
       * @param {Array} [args]
       * @returns {Boolean}
       */
      function boolOrFn(val, args) {
          if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == TYPE_FUNCTION) {
              return val.apply(args ? args[0] || undefined : undefined, args);
          }
          return val;
      }

      /**
       * use the val2 when val1 is undefined
       * @param {*} val1
       * @param {*} val2
       * @returns {*}
       */
      function ifUndefined(val1, val2) {
          return val1 === undefined ? val2 : val1;
      }

      /**
       * addEventListener with multiple events at once
       * @param {EventTarget} target
       * @param {String} types
       * @param {Function} handler
       */
      function addEventListeners(target, types, handler) {
          each(splitStr(types), function (type) {
              target.addEventListener(type, handler, false);
          });
      }

      /**
       * removeEventListener with multiple events at once
       * @param {EventTarget} target
       * @param {String} types
       * @param {Function} handler
       */
      function removeEventListeners(target, types, handler) {
          each(splitStr(types), function (type) {
              target.removeEventListener(type, handler, false);
          });
      }

      /**
       * find if a node is in the given parent
       * @method hasParent
       * @param {HTMLElement} node
       * @param {HTMLElement} parent
       * @return {Boolean} found
       */
      function hasParent(node, parent) {
          while (node) {
              if (node == parent) {
                  return true;
              }
              node = node.parentNode;
          }
          return false;
      }

      /**
       * small indexOf wrapper
       * @param {String} str
       * @param {String} find
       * @returns {Boolean} found
       */
      function inStr(str, find) {
          return str.indexOf(find) > -1;
      }

      /**
       * split string on whitespace
       * @param {String} str
       * @returns {Array} words
       */
      function splitStr(str) {
          return str.trim().split(/\s+/g);
      }

      /**
       * find if a array contains the object using indexOf or a simple polyFill
       * @param {Array} src
       * @param {String} find
       * @param {String} [findByKey]
       * @return {Boolean|Number} false when not found, or the index
       */
      function inArray(src, find, findByKey) {
          if (src.indexOf && !findByKey) {
              return src.indexOf(find);
          } else {
              var i = 0;
              while (i < src.length) {
                  if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                      return i;
                  }
                  i++;
              }
              return -1;
          }
      }

      /**
       * convert array-like objects to real arrays
       * @param {Object} obj
       * @returns {Array}
       */
      function toArray(obj) {
          return Array.prototype.slice.call(obj, 0);
      }

      /**
       * unique array with objects based on a key (like 'id') or just by the array's value
       * @param {Array} src [{id:1},{id:2},{id:1}]
       * @param {String} [key]
       * @param {Boolean} [sort=False]
       * @returns {Array} [{id:1},{id:2}]
       */
      function uniqueArray(src, key, sort) {
          var results = [];
          var values = [];
          var i = 0;

          while (i < src.length) {
              var val = key ? src[i][key] : src[i];
              if (inArray(values, val) < 0) {
                  results.push(src[i]);
              }
              values[i] = val;
              i++;
          }

          if (sort) {
              if (!key) {
                  results = results.sort();
              } else {
                  results = results.sort(function sortUniqueArray(a, b) {
                      return a[key] > b[key];
                  });
              }
          }

          return results;
      }

      /**
       * get the prefixed property
       * @param {Object} obj
       * @param {String} property
       * @returns {String|Undefined} prefixed
       */
      function prefixed(obj, property) {
          var prefix, prop;
          var camelProp = property[0].toUpperCase() + property.slice(1);

          var i = 0;
          while (i < VENDOR_PREFIXES.length) {
              prefix = VENDOR_PREFIXES[i];
              prop = prefix ? prefix + camelProp : property;

              if (prop in obj) {
                  return prop;
              }
              i++;
          }
          return undefined;
      }

      /**
       * get a unique id
       * @returns {number} uniqueId
       */
      var _uniqueId = 1;
      function uniqueId() {
          return _uniqueId++;
      }

      /**
       * get the window object of an element
       * @param {HTMLElement} element
       * @returns {DocumentView|Window}
       */
      function getWindowForElement(element) {
          var doc = element.ownerDocument || element;
          return doc.defaultView || doc.parentWindow || window;
      }

      var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

      var SUPPORT_TOUCH = 'ontouchstart' in window;
      var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
      var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

      var INPUT_TYPE_TOUCH = 'touch';
      var INPUT_TYPE_PEN = 'pen';
      var INPUT_TYPE_MOUSE = 'mouse';
      var INPUT_TYPE_KINECT = 'kinect';

      var COMPUTE_INTERVAL = 25;

      var INPUT_START = 1;
      var INPUT_MOVE = 2;
      var INPUT_END = 4;
      var INPUT_CANCEL = 8;

      var DIRECTION_NONE = 1;
      var DIRECTION_LEFT = 2;
      var DIRECTION_RIGHT = 4;
      var DIRECTION_UP = 8;
      var DIRECTION_DOWN = 16;

      var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
      var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
      var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

      var PROPS_XY = ['x', 'y'];
      var PROPS_CLIENT_XY = ['clientX', 'clientY'];

      /**
       * create new input type manager
       * @param {Manager} manager
       * @param {Function} callback
       * @returns {Input}
       * @constructor
       */
      function Input(manager, callback) {
          var self = this;
          this.manager = manager;
          this.callback = callback;
          this.element = manager.element;
          this.target = manager.options.inputTarget;

          // smaller wrapper around the handler, for the scope and the enabled state of the manager,
          // so when disabled the input events are completely bypassed.
          this.domHandler = function (ev) {
              if (boolOrFn(manager.options.enable, [manager])) {
                  self.handler(ev);
              }
          };

          this.init();
      }

      Input.prototype = {
          /**
           * should handle the inputEvent data and trigger the callback
           * @virtual
           */
          handler: function handler() {},

          /**
           * bind the events
           */
          init: function init() {
              this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
              this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
              this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          },

          /**
           * unbind the events
           */
          destroy: function destroy() {
              this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
              this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
              this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          }
      };

      /**
       * create new input type manager
       * called by the Manager constructor
       * @param {Hammer} manager
       * @returns {Input}
       */
      function createInputInstance(manager) {
          var Type;
          var inputClass = manager.options.inputClass;

          if (inputClass) {
              Type = inputClass;
          } else if (SUPPORT_POINTER_EVENTS) {
              Type = PointerEventInput;
          } else if (SUPPORT_ONLY_TOUCH) {
              Type = TouchInput;
          } else if (!SUPPORT_TOUCH) {
              Type = MouseInput;
          } else {
              Type = TouchMouseInput;
          }
          return new Type(manager, inputHandler);
      }

      /**
       * handle input events
       * @param {Manager} manager
       * @param {String} eventType
       * @param {Object} input
       */
      function inputHandler(manager, eventType, input) {
          var pointersLen = input.pointers.length;
          var changedPointersLen = input.changedPointers.length;
          var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
          var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;

          input.isFirst = !!isFirst;
          input.isFinal = !!isFinal;

          if (isFirst) {
              manager.session = {};
          }

          // source event is the normalized value of the domEvents
          // like 'touchstart, mouseup, pointerdown'
          input.eventType = eventType;

          // compute scale, rotation etc
          computeInputData(manager, input);

          // emit secret event
          manager.emit('hammer.input', input);

          manager.recognize(input);
          manager.session.prevInput = input;
      }

      /**
       * extend the data with some usable properties like scale, rotate, velocity etc
       * @param {Object} manager
       * @param {Object} input
       */
      function computeInputData(manager, input) {
          var session = manager.session;
          var pointers = input.pointers;
          var pointersLength = pointers.length;

          // store the first input to calculate the distance and direction
          if (!session.firstInput) {
              session.firstInput = simpleCloneInputData(input);
          }

          // to compute scale and rotation we need to store the multiple touches
          if (pointersLength > 1 && !session.firstMultiple) {
              session.firstMultiple = simpleCloneInputData(input);
          } else if (pointersLength === 1) {
              session.firstMultiple = false;
          }

          var firstInput = session.firstInput;
          var firstMultiple = session.firstMultiple;
          var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

          var center = input.center = getCenter(pointers);
          input.timeStamp = now();
          input.deltaTime = input.timeStamp - firstInput.timeStamp;

          input.angle = getAngle(offsetCenter, center);
          input.distance = getDistance(offsetCenter, center);

          computeDeltaXY(session, input);
          input.offsetDirection = getDirection(input.deltaX, input.deltaY);

          var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
          input.overallVelocityX = overallVelocity.x;
          input.overallVelocityY = overallVelocity.y;
          input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;

          input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
          input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

          input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;

          computeIntervalInputData(session, input);

          // find the correct target
          var target = manager.element;
          if (hasParent(input.srcEvent.target, target)) {
              target = input.srcEvent.target;
          }
          input.target = target;
      }

      function computeDeltaXY(session, input) {
          var center = input.center;
          var offset = session.offsetDelta || {};
          var prevDelta = session.prevDelta || {};
          var prevInput = session.prevInput || {};

          if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
              prevDelta = session.prevDelta = {
                  x: prevInput.deltaX || 0,
                  y: prevInput.deltaY || 0
              };

              offset = session.offsetDelta = {
                  x: center.x,
                  y: center.y
              };
          }

          input.deltaX = prevDelta.x + (center.x - offset.x);
          input.deltaY = prevDelta.y + (center.y - offset.y);
      }

      /**
       * velocity is calculated every x ms
       * @param {Object} session
       * @param {Object} input
       */
      function computeIntervalInputData(session, input) {
          var last = session.lastInterval || input,
              deltaTime = input.timeStamp - last.timeStamp,
              velocity,
              velocityX,
              velocityY,
              direction;

          if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
              var deltaX = input.deltaX - last.deltaX;
              var deltaY = input.deltaY - last.deltaY;

              var v = getVelocity(deltaTime, deltaX, deltaY);
              velocityX = v.x;
              velocityY = v.y;
              velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
              direction = getDirection(deltaX, deltaY);

              session.lastInterval = input;
          } else {
              // use latest velocity info if it doesn't overtake a minimum period
              velocity = last.velocity;
              velocityX = last.velocityX;
              velocityY = last.velocityY;
              direction = last.direction;
          }

          input.velocity = velocity;
          input.velocityX = velocityX;
          input.velocityY = velocityY;
          input.direction = direction;
      }

      /**
       * create a simple clone from the input used for storage of firstInput and firstMultiple
       * @param {Object} input
       * @returns {Object} clonedInputData
       */
      function simpleCloneInputData(input) {
          // make a simple copy of the pointers because we will get a reference if we don't
          // we only need clientXY for the calculations
          var pointers = [];
          var i = 0;
          while (i < input.pointers.length) {
              pointers[i] = {
                  clientX: round(input.pointers[i].clientX),
                  clientY: round(input.pointers[i].clientY)
              };
              i++;
          }

          return {
              timeStamp: now(),
              pointers: pointers,
              center: getCenter(pointers),
              deltaX: input.deltaX,
              deltaY: input.deltaY
          };
      }

      /**
       * get the center of all the pointers
       * @param {Array} pointers
       * @return {Object} center contains `x` and `y` properties
       */
      function getCenter(pointers) {
          var pointersLength = pointers.length;

          // no need to loop when only one touch
          if (pointersLength === 1) {
              return {
                  x: round(pointers[0].clientX),
                  y: round(pointers[0].clientY)
              };
          }

          var x = 0,
              y = 0,
              i = 0;
          while (i < pointersLength) {
              x += pointers[i].clientX;
              y += pointers[i].clientY;
              i++;
          }

          return {
              x: round(x / pointersLength),
              y: round(y / pointersLength)
          };
      }

      /**
       * calculate the velocity between two points. unit is in px per ms.
       * @param {Number} deltaTime
       * @param {Number} x
       * @param {Number} y
       * @return {Object} velocity `x` and `y`
       */
      function getVelocity(deltaTime, x, y) {
          return {
              x: x / deltaTime || 0,
              y: y / deltaTime || 0
          };
      }

      /**
       * get the direction between two points
       * @param {Number} x
       * @param {Number} y
       * @return {Number} direction
       */
      function getDirection(x, y) {
          if (x === y) {
              return DIRECTION_NONE;
          }

          if (abs(x) >= abs(y)) {
              return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
          return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
      }

      /**
       * calculate the absolute distance between two points
       * @param {Object} p1 {x, y}
       * @param {Object} p2 {x, y}
       * @param {Array} [props] containing x and y keys
       * @return {Number} distance
       */
      function getDistance(p1, p2, props) {
          if (!props) {
              props = PROPS_XY;
          }
          var x = p2[props[0]] - p1[props[0]],
              y = p2[props[1]] - p1[props[1]];

          return Math.sqrt(x * x + y * y);
      }

      /**
       * calculate the angle between two coordinates
       * @param {Object} p1
       * @param {Object} p2
       * @param {Array} [props] containing x and y keys
       * @return {Number} angle
       */
      function getAngle(p1, p2, props) {
          if (!props) {
              props = PROPS_XY;
          }
          var x = p2[props[0]] - p1[props[0]],
              y = p2[props[1]] - p1[props[1]];
          return Math.atan2(y, x) * 180 / Math.PI;
      }

      /**
       * calculate the rotation degrees between two pointersets
       * @param {Array} start array of pointers
       * @param {Array} end array of pointers
       * @return {Number} rotation
       */
      function getRotation(start, end) {
          return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
      }

      /**
       * calculate the scale factor between two pointersets
       * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
       * @param {Array} start array of pointers
       * @param {Array} end array of pointers
       * @return {Number} scale
       */
      function getScale(start, end) {
          return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
      }

      var MOUSE_INPUT_MAP = {
          mousedown: INPUT_START,
          mousemove: INPUT_MOVE,
          mouseup: INPUT_END
      };

      var MOUSE_ELEMENT_EVENTS = 'mousedown';
      var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

      /**
       * Mouse events input
       * @constructor
       * @extends Input
       */
      function MouseInput() {
          this.evEl = MOUSE_ELEMENT_EVENTS;
          this.evWin = MOUSE_WINDOW_EVENTS;

          this.pressed = false; // mousedown state

          Input.apply(this, arguments);
      }

      inherit(MouseInput, Input, {
          /**
           * handle mouse events
           * @param {Object} ev
           */
          handler: function MEhandler(ev) {
              var eventType = MOUSE_INPUT_MAP[ev.type];

              // on start we want to have the left mouse button down
              if (eventType & INPUT_START && ev.button === 0) {
                  this.pressed = true;
              }

              if (eventType & INPUT_MOVE && ev.which !== 1) {
                  eventType = INPUT_END;
              }

              // mouse must be down
              if (!this.pressed) {
                  return;
              }

              if (eventType & INPUT_END) {
                  this.pressed = false;
              }

              this.callback(this.manager, eventType, {
                  pointers: [ev],
                  changedPointers: [ev],
                  pointerType: INPUT_TYPE_MOUSE,
                  srcEvent: ev
              });
          }
      });

      var POINTER_INPUT_MAP = {
          pointerdown: INPUT_START,
          pointermove: INPUT_MOVE,
          pointerup: INPUT_END,
          pointercancel: INPUT_CANCEL,
          pointerout: INPUT_CANCEL
      };

      // in IE10 the pointer types is defined as an enum
      var IE10_POINTER_TYPE_ENUM = {
          2: INPUT_TYPE_TOUCH,
          3: INPUT_TYPE_PEN,
          4: INPUT_TYPE_MOUSE,
          5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
      };

      var POINTER_ELEMENT_EVENTS = 'pointerdown';
      var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

      // IE10 has prefixed support, and case-sensitive
      if (window.MSPointerEvent && !window.PointerEvent) {
          POINTER_ELEMENT_EVENTS = 'MSPointerDown';
          POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
      }

      /**
       * Pointer events input
       * @constructor
       * @extends Input
       */
      function PointerEventInput() {
          this.evEl = POINTER_ELEMENT_EVENTS;
          this.evWin = POINTER_WINDOW_EVENTS;

          Input.apply(this, arguments);

          this.store = this.manager.session.pointerEvents = [];
      }

      inherit(PointerEventInput, Input, {
          /**
           * handle mouse events
           * @param {Object} ev
           */
          handler: function PEhandler(ev) {
              var store = this.store;
              var removePointer = false;

              var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
              var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
              var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

              var isTouch = pointerType == INPUT_TYPE_TOUCH;

              // get index of the event in the store
              var storeIndex = inArray(store, ev.pointerId, 'pointerId');

              // start and mouse must be down
              if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                  if (storeIndex < 0) {
                      store.push(ev);
                      storeIndex = store.length - 1;
                  }
              } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                  removePointer = true;
              }

              // it not found, so the pointer hasn't been down (so it's probably a hover)
              if (storeIndex < 0) {
                  return;
              }

              // update the event in the store
              store[storeIndex] = ev;

              this.callback(this.manager, eventType, {
                  pointers: store,
                  changedPointers: [ev],
                  pointerType: pointerType,
                  srcEvent: ev
              });

              if (removePointer) {
                  // remove from the store
                  store.splice(storeIndex, 1);
              }
          }
      });

      var SINGLE_TOUCH_INPUT_MAP = {
          touchstart: INPUT_START,
          touchmove: INPUT_MOVE,
          touchend: INPUT_END,
          touchcancel: INPUT_CANCEL
      };

      var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
      var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

      /**
       * Touch events input
       * @constructor
       * @extends Input
       */
      function SingleTouchInput() {
          this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
          this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
          this.started = false;

          Input.apply(this, arguments);
      }

      inherit(SingleTouchInput, Input, {
          handler: function TEhandler(ev) {
              var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

              // should we handle the touch events?
              if (type === INPUT_START) {
                  this.started = true;
              }

              if (!this.started) {
                  return;
              }

              var touches = normalizeSingleTouches.call(this, ev, type);

              // when done, reset the started state
              if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                  this.started = false;
              }

              this.callback(this.manager, type, {
                  pointers: touches[0],
                  changedPointers: touches[1],
                  pointerType: INPUT_TYPE_TOUCH,
                  srcEvent: ev
              });
          }
      });

      /**
       * @this {TouchInput}
       * @param {Object} ev
       * @param {Number} type flag
       * @returns {undefined|Array} [all, changed]
       */
      function normalizeSingleTouches(ev, type) {
          var all = toArray(ev.touches);
          var changed = toArray(ev.changedTouches);

          if (type & (INPUT_END | INPUT_CANCEL)) {
              all = uniqueArray(all.concat(changed), 'identifier', true);
          }

          return [all, changed];
      }

      var TOUCH_INPUT_MAP = {
          touchstart: INPUT_START,
          touchmove: INPUT_MOVE,
          touchend: INPUT_END,
          touchcancel: INPUT_CANCEL
      };

      var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

      /**
       * Multi-user touch events input
       * @constructor
       * @extends Input
       */
      function TouchInput() {
          this.evTarget = TOUCH_TARGET_EVENTS;
          this.targetIds = {};

          Input.apply(this, arguments);
      }

      inherit(TouchInput, Input, {
          handler: function MTEhandler(ev) {
              var type = TOUCH_INPUT_MAP[ev.type];
              var touches = getTouches.call(this, ev, type);
              if (!touches) {
                  return;
              }

              this.callback(this.manager, type, {
                  pointers: touches[0],
                  changedPointers: touches[1],
                  pointerType: INPUT_TYPE_TOUCH,
                  srcEvent: ev
              });
          }
      });

      /**
       * @this {TouchInput}
       * @param {Object} ev
       * @param {Number} type flag
       * @returns {undefined|Array} [all, changed]
       */
      function getTouches(ev, type) {
          var allTouches = toArray(ev.touches);
          var targetIds = this.targetIds;

          // when there is only one touch, the process can be simplified
          if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
              targetIds[allTouches[0].identifier] = true;
              return [allTouches, allTouches];
          }

          var i,
              targetTouches,
              changedTouches = toArray(ev.changedTouches),
              changedTargetTouches = [],
              target = this.target;

          // get target touches from touches
          targetTouches = allTouches.filter(function (touch) {
              return hasParent(touch.target, target);
          });

          // collect touches
          if (type === INPUT_START) {
              i = 0;
              while (i < targetTouches.length) {
                  targetIds[targetTouches[i].identifier] = true;
                  i++;
              }
          }

          // filter changed touches to only contain touches that exist in the collected target ids
          i = 0;
          while (i < changedTouches.length) {
              if (targetIds[changedTouches[i].identifier]) {
                  changedTargetTouches.push(changedTouches[i]);
              }

              // cleanup removed touches
              if (type & (INPUT_END | INPUT_CANCEL)) {
                  delete targetIds[changedTouches[i].identifier];
              }
              i++;
          }

          if (!changedTargetTouches.length) {
              return;
          }

          return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
      }

      /**
       * Combined touch and mouse input
       *
       * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
       * This because touch devices also emit mouse events while doing a touch.
       *
       * @constructor
       * @extends Input
       */

      var DEDUP_TIMEOUT = 2500;
      var DEDUP_DISTANCE = 25;

      function TouchMouseInput() {
          Input.apply(this, arguments);

          var handler = bindFn(this.handler, this);
          this.touch = new TouchInput(this.manager, handler);
          this.mouse = new MouseInput(this.manager, handler);

          this.primaryTouch = null;
          this.lastTouches = [];
      }

      inherit(TouchMouseInput, Input, {
          /**
           * handle mouse and touch events
           * @param {Hammer} manager
           * @param {String} inputEvent
           * @param {Object} inputData
           */
          handler: function TMEhandler(manager, inputEvent, inputData) {
              var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
                  isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;

              if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
                  return;
              }

              // when we're in a touch event, record touches to  de-dupe synthetic mouse event
              if (isTouch) {
                  recordTouches.call(this, inputEvent, inputData);
              } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
                  return;
              }

              this.callback(manager, inputEvent, inputData);
          },

          /**
           * remove the event listeners
           */
          destroy: function destroy() {
              this.touch.destroy();
              this.mouse.destroy();
          }
      });

      function recordTouches(eventType, eventData) {
          if (eventType & INPUT_START) {
              this.primaryTouch = eventData.changedPointers[0].identifier;
              setLastTouch.call(this, eventData);
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
              setLastTouch.call(this, eventData);
          }
      }

      function setLastTouch(eventData) {
          var touch = eventData.changedPointers[0];

          if (touch.identifier === this.primaryTouch) {
              var lastTouch = { x: touch.clientX, y: touch.clientY };
              this.lastTouches.push(lastTouch);
              var lts = this.lastTouches;
              var removeLastTouch = function removeLastTouch() {
                  var i = lts.indexOf(lastTouch);
                  if (i > -1) {
                      lts.splice(i, 1);
                  }
              };
              setTimeout(removeLastTouch, DEDUP_TIMEOUT);
          }
      }

      function isSyntheticEvent(eventData) {
          var x = eventData.srcEvent.clientX,
              y = eventData.srcEvent.clientY;
          for (var i = 0; i < this.lastTouches.length; i++) {
              var t = this.lastTouches[i];
              var dx = Math.abs(x - t.x),
                  dy = Math.abs(y - t.y);
              if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
                  return true;
              }
          }
          return false;
      }

      var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
      var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

      // magical touchAction value
      var TOUCH_ACTION_COMPUTE = 'compute';
      var TOUCH_ACTION_AUTO = 'auto';
      var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
      var TOUCH_ACTION_NONE = 'none';
      var TOUCH_ACTION_PAN_X = 'pan-x';
      var TOUCH_ACTION_PAN_Y = 'pan-y';
      var TOUCH_ACTION_MAP = getTouchActionProps();

      /**
       * Touch Action
       * sets the touchAction property or uses the js alternative
       * @param {Manager} manager
       * @param {String} value
       * @constructor
       */
      function TouchAction(manager, value) {
          this.manager = manager;
          this.set(value);
      }

      TouchAction.prototype = {
          /**
           * set the touchAction value on the element or enable the polyfill
           * @param {String} value
           */
          set: function set(value) {
              // find out the touch-action by the event handlers
              if (value == TOUCH_ACTION_COMPUTE) {
                  value = this.compute();
              }

              if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
                  this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
              }
              this.actions = value.toLowerCase().trim();
          },

          /**
           * just re-set the touchAction value
           */
          update: function update() {
              this.set(this.manager.options.touchAction);
          },

          /**
           * compute the value for the touchAction property based on the recognizer's settings
           * @returns {String} value
           */
          compute: function compute() {
              var actions = [];
              each(this.manager.recognizers, function (recognizer) {
                  if (boolOrFn(recognizer.options.enable, [recognizer])) {
                      actions = actions.concat(recognizer.getTouchAction());
                  }
              });
              return cleanTouchActions(actions.join(' '));
          },

          /**
           * this method is called on each input cycle and provides the preventing of the browser behavior
           * @param {Object} input
           */
          preventDefaults: function preventDefaults(input) {
              var srcEvent = input.srcEvent;
              var direction = input.offsetDirection;

              // if the touch action did prevented once this session
              if (this.manager.session.prevented) {
                  srcEvent.preventDefault();
                  return;
              }

              var actions = this.actions;
              var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
              var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
              var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

              if (hasNone) {
                  //do not prevent defaults if this is a tap gesture

                  var isTapPointer = input.pointers.length === 1;
                  var isTapMovement = input.distance < 2;
                  var isTapTouchTime = input.deltaTime < 250;

                  if (isTapPointer && isTapMovement && isTapTouchTime) {
                      return;
                  }
              }

              if (hasPanX && hasPanY) {
                  // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
                  return;
              }

              if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
                  return this.preventSrc(srcEvent);
              }
          },

          /**
           * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
           * @param {Object} srcEvent
           */
          preventSrc: function preventSrc(srcEvent) {
              this.manager.session.prevented = true;
              srcEvent.preventDefault();
          }
      };

      /**
       * when the touchActions are collected they are not a valid value, so we need to clean things up. *
       * @param {String} actions
       * @returns {*}
       */
      function cleanTouchActions(actions) {
          // none
          if (inStr(actions, TOUCH_ACTION_NONE)) {
              return TOUCH_ACTION_NONE;
          }

          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

          // if both pan-x and pan-y are set (different recognizers
          // for different directions, e.g. horizontal pan but vertical swipe?)
          // we need none (as otherwise with pan-x pan-y combined none of these
          // recognizers will work, since the browser would handle all panning
          if (hasPanX && hasPanY) {
              return TOUCH_ACTION_NONE;
          }

          // pan-x OR pan-y
          if (hasPanX || hasPanY) {
              return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
          }

          // manipulation
          if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
              return TOUCH_ACTION_MANIPULATION;
          }

          return TOUCH_ACTION_AUTO;
      }

      function getTouchActionProps() {
          if (!NATIVE_TOUCH_ACTION) {
              return false;
          }
          var touchMap = {};
          var cssSupports = window.CSS && window.CSS.supports;
          ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {

              // If css.supports is not supported but there is native touch-action assume it supports
              // all values. This is the case for IE 10 and 11.
              touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
          });
          return touchMap;
      }

      /**
       * Recognizer flow explained; *
       * All recognizers have the initial state of POSSIBLE when a input session starts.
       * The definition of a input session is from the first input until the last input, with all it's movement in it. *
       * Example session for mouse-input: mousedown -> mousemove -> mouseup
       *
       * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
       * which determines with state it should be.
       *
       * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
       * POSSIBLE to give it another change on the next cycle.
       *
       *               Possible
       *                  |
       *            +-----+---------------+
       *            |                     |
       *      +-----+-----+               |
       *      |           |               |
       *   Failed      Cancelled          |
       *                          +-------+------+
       *                          |              |
       *                      Recognized       Began
       *                                         |
       *                                      Changed
       *                                         |
       *                                  Ended/Recognized
       */
      var STATE_POSSIBLE = 1;
      var STATE_BEGAN = 2;
      var STATE_CHANGED = 4;
      var STATE_ENDED = 8;
      var STATE_RECOGNIZED = STATE_ENDED;
      var STATE_CANCELLED = 16;
      var STATE_FAILED = 32;

      /**
       * Recognizer
       * Every recognizer needs to extend from this class.
       * @constructor
       * @param {Object} options
       */
      function Recognizer(options) {
          this.options = assign({}, this.defaults, options || {});

          this.id = uniqueId();

          this.manager = null;

          // default is enable true
          this.options.enable = ifUndefined(this.options.enable, true);

          this.state = STATE_POSSIBLE;

          this.simultaneous = {};
          this.requireFail = [];
      }

      Recognizer.prototype = {
          /**
           * @virtual
           * @type {Object}
           */
          defaults: {},

          /**
           * set options
           * @param {Object} options
           * @return {Recognizer}
           */
          set: function set(options) {
              assign(this.options, options);

              // also update the touchAction, in case something changed about the directions/enabled state
              this.manager && this.manager.touchAction.update();
              return this;
          },

          /**
           * recognize simultaneous with an other recognizer.
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */
          recognizeWith: function recognizeWith(otherRecognizer) {
              if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                  return this;
              }

              var simultaneous = this.simultaneous;
              otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
              if (!simultaneous[otherRecognizer.id]) {
                  simultaneous[otherRecognizer.id] = otherRecognizer;
                  otherRecognizer.recognizeWith(this);
              }
              return this;
          },

          /**
           * drop the simultaneous link. it doesnt remove the link on the other recognizer.
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */
          dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {
              if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                  return this;
              }

              otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
              delete this.simultaneous[otherRecognizer.id];
              return this;
          },

          /**
           * recognizer can only run when an other is failing
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */
          requireFailure: function requireFailure(otherRecognizer) {
              if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                  return this;
              }

              var requireFail = this.requireFail;
              otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
              if (inArray(requireFail, otherRecognizer) === -1) {
                  requireFail.push(otherRecognizer);
                  otherRecognizer.requireFailure(this);
              }
              return this;
          },

          /**
           * drop the requireFailure link. it does not remove the link on the other recognizer.
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */
          dropRequireFailure: function dropRequireFailure(otherRecognizer) {
              if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                  return this;
              }

              otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
              var index = inArray(this.requireFail, otherRecognizer);
              if (index > -1) {
                  this.requireFail.splice(index, 1);
              }
              return this;
          },

          /**
           * has require failures boolean
           * @returns {boolean}
           */
          hasRequireFailures: function hasRequireFailures() {
              return this.requireFail.length > 0;
          },

          /**
           * if the recognizer can recognize simultaneous with an other recognizer
           * @param {Recognizer} otherRecognizer
           * @returns {Boolean}
           */
          canRecognizeWith: function canRecognizeWith(otherRecognizer) {
              return !!this.simultaneous[otherRecognizer.id];
          },

          /**
           * You should use `tryEmit` instead of `emit` directly to check
           * that all the needed recognizers has failed before emitting.
           * @param {Object} input
           */
          emit: function emit(input) {
              var self = this;
              var state = this.state;

              function emit(event) {
                  self.manager.emit(event, input);
              }

              // 'panstart' and 'panmove'
              if (state < STATE_ENDED) {
                  emit(self.options.event + stateStr(state));
              }

              emit(self.options.event); // simple 'eventName' events

              if (input.additionalEvent) {
                  // additional event(panleft, panright, pinchin, pinchout...)
                  emit(input.additionalEvent);
              }

              // panend and pancancel
              if (state >= STATE_ENDED) {
                  emit(self.options.event + stateStr(state));
              }
          },

          /**
           * Check that all the require failure recognizers has failed,
           * if true, it emits a gesture event,
           * otherwise, setup the state to FAILED.
           * @param {Object} input
           */
          tryEmit: function tryEmit(input) {
              if (this.canEmit()) {
                  return this.emit(input);
              }
              // it's failing anyway
              this.state = STATE_FAILED;
          },

          /**
           * can we emit?
           * @returns {boolean}
           */
          canEmit: function canEmit() {
              var i = 0;
              while (i < this.requireFail.length) {
                  if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                      return false;
                  }
                  i++;
              }
              return true;
          },

          /**
           * update the recognizer
           * @param {Object} inputData
           */
          recognize: function recognize(inputData) {
              // make a new copy of the inputData
              // so we can change the inputData without messing up the other recognizers
              var inputDataClone = assign({}, inputData);

              // is is enabled and allow recognizing?
              if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                  this.reset();
                  this.state = STATE_FAILED;
                  return;
              }

              // reset when we've reached the end
              if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                  this.state = STATE_POSSIBLE;
              }

              this.state = this.process(inputDataClone);

              // the recognizer has recognized a gesture
              // so trigger an event
              if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                  this.tryEmit(inputDataClone);
              }
          },

          /**
           * return the state of the recognizer
           * the actual recognizing happens in this method
           * @virtual
           * @param {Object} inputData
           * @returns {Const} STATE
           */
          process: function process(inputData) {}, // jshint ignore:line

          /**
           * return the preferred touch-action
           * @virtual
           * @returns {Array}
           */
          getTouchAction: function getTouchAction() {},

          /**
           * called when the gesture isn't allowed to recognize
           * like when another is being recognized or it is disabled
           * @virtual
           */
          reset: function reset() {}
      };

      /**
       * get a usable string, used as event postfix
       * @param {Const} state
       * @returns {String} state
       */
      function stateStr(state) {
          if (state & STATE_CANCELLED) {
              return 'cancel';
          } else if (state & STATE_ENDED) {
              return 'end';
          } else if (state & STATE_CHANGED) {
              return 'move';
          } else if (state & STATE_BEGAN) {
              return 'start';
          }
          return '';
      }

      /**
       * direction cons to string
       * @param {Const} direction
       * @returns {String}
       */
      function directionStr(direction) {
          if (direction == DIRECTION_DOWN) {
              return 'down';
          } else if (direction == DIRECTION_UP) {
              return 'up';
          } else if (direction == DIRECTION_LEFT) {
              return 'left';
          } else if (direction == DIRECTION_RIGHT) {
              return 'right';
          }
          return '';
      }

      /**
       * get a recognizer by name if it is bound to a manager
       * @param {Recognizer|String} otherRecognizer
       * @param {Recognizer} recognizer
       * @returns {Recognizer}
       */
      function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
          var manager = recognizer.manager;
          if (manager) {
              return manager.get(otherRecognizer);
          }
          return otherRecognizer;
      }

      /**
       * This recognizer is just used as a base for the simple attribute recognizers.
       * @constructor
       * @extends Recognizer
       */
      function AttrRecognizer() {
          Recognizer.apply(this, arguments);
      }

      inherit(AttrRecognizer, Recognizer, {
          /**
           * @namespace
           * @memberof AttrRecognizer
           */
          defaults: {
              /**
               * @type {Number}
               * @default 1
               */
              pointers: 1
          },

          /**
           * Used to check if it the recognizer receives valid input, like input.distance > 10.
           * @memberof AttrRecognizer
           * @param {Object} input
           * @returns {Boolean} recognized
           */
          attrTest: function attrTest(input) {
              var optionPointers = this.options.pointers;
              return optionPointers === 0 || input.pointers.length === optionPointers;
          },

          /**
           * Process the input and return the state for the recognizer
           * @memberof AttrRecognizer
           * @param {Object} input
           * @returns {*} State
           */
          process: function process(input) {
              var state = this.state;
              var eventType = input.eventType;

              var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
              var isValid = this.attrTest(input);

              // on cancel input and we've recognized before, return STATE_CANCELLED
              if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                  return state | STATE_CANCELLED;
              } else if (isRecognized || isValid) {
                  if (eventType & INPUT_END) {
                      return state | STATE_ENDED;
                  } else if (!(state & STATE_BEGAN)) {
                      return STATE_BEGAN;
                  }
                  return state | STATE_CHANGED;
              }
              return STATE_FAILED;
          }
      });

      /**
       * Pan
       * Recognized when the pointer is down and moved in the allowed direction.
       * @constructor
       * @extends AttrRecognizer
       */
      function PanRecognizer() {
          AttrRecognizer.apply(this, arguments);

          this.pX = null;
          this.pY = null;
      }

      inherit(PanRecognizer, AttrRecognizer, {
          /**
           * @namespace
           * @memberof PanRecognizer
           */
          defaults: {
              event: 'pan',
              threshold: 10,
              pointers: 1,
              direction: DIRECTION_ALL
          },

          getTouchAction: function getTouchAction() {
              var direction = this.options.direction;
              var actions = [];
              if (direction & DIRECTION_HORIZONTAL) {
                  actions.push(TOUCH_ACTION_PAN_Y);
              }
              if (direction & DIRECTION_VERTICAL) {
                  actions.push(TOUCH_ACTION_PAN_X);
              }
              return actions;
          },

          directionTest: function directionTest(input) {
              var options = this.options;
              var hasMoved = true;
              var distance = input.distance;
              var direction = input.direction;
              var x = input.deltaX;
              var y = input.deltaY;

              // lock to axis?
              if (!(direction & options.direction)) {
                  if (options.direction & DIRECTION_HORIZONTAL) {
                      direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                      hasMoved = x != this.pX;
                      distance = Math.abs(input.deltaX);
                  } else {
                      direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                      hasMoved = y != this.pY;
                      distance = Math.abs(input.deltaY);
                  }
              }
              input.direction = direction;
              return hasMoved && distance > options.threshold && direction & options.direction;
          },

          attrTest: function attrTest(input) {
              return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
          },

          emit: function emit(input) {

              this.pX = input.deltaX;
              this.pY = input.deltaY;

              var direction = directionStr(input.direction);

              if (direction) {
                  input.additionalEvent = this.options.event + direction;
              }
              this._super.emit.call(this, input);
          }
      });

      /**
       * Pinch
       * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
       * @constructor
       * @extends AttrRecognizer
       */
      function PinchRecognizer() {
          AttrRecognizer.apply(this, arguments);
      }

      inherit(PinchRecognizer, AttrRecognizer, {
          /**
           * @namespace
           * @memberof PinchRecognizer
           */
          defaults: {
              event: 'pinch',
              threshold: 0,
              pointers: 2
          },

          getTouchAction: function getTouchAction() {
              return [TOUCH_ACTION_NONE];
          },

          attrTest: function attrTest(input) {
              return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
          },

          emit: function emit(input) {
              if (input.scale !== 1) {
                  var inOut = input.scale < 1 ? 'in' : 'out';
                  input.additionalEvent = this.options.event + inOut;
              }
              this._super.emit.call(this, input);
          }
      });

      /**
       * Press
       * Recognized when the pointer is down for x ms without any movement.
       * @constructor
       * @extends Recognizer
       */
      function PressRecognizer() {
          Recognizer.apply(this, arguments);

          this._timer = null;
          this._input = null;
      }

      inherit(PressRecognizer, Recognizer, {
          /**
           * @namespace
           * @memberof PressRecognizer
           */
          defaults: {
              event: 'press',
              pointers: 1,
              time: 251, // minimal time of the pointer to be pressed
              threshold: 9 // a minimal movement is ok, but keep it low
          },

          getTouchAction: function getTouchAction() {
              return [TOUCH_ACTION_AUTO];
          },

          process: function process(input) {
              var options = this.options;
              var validPointers = input.pointers.length === options.pointers;
              var validMovement = input.distance < options.threshold;
              var validTime = input.deltaTime > options.time;

              this._input = input;

              // we only allow little movement
              // and we've reached an end event, so a tap is possible
              if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
                  this.reset();
              } else if (input.eventType & INPUT_START) {
                  this.reset();
                  this._timer = setTimeoutContext(function () {
                      this.state = STATE_RECOGNIZED;
                      this.tryEmit();
                  }, options.time, this);
              } else if (input.eventType & INPUT_END) {
                  return STATE_RECOGNIZED;
              }
              return STATE_FAILED;
          },

          reset: function reset() {
              clearTimeout(this._timer);
          },

          emit: function emit(input) {
              if (this.state !== STATE_RECOGNIZED) {
                  return;
              }

              if (input && input.eventType & INPUT_END) {
                  this.manager.emit(this.options.event + 'up', input);
              } else {
                  this._input.timeStamp = now();
                  this.manager.emit(this.options.event, this._input);
              }
          }
      });

      /**
       * Rotate
       * Recognized when two or more pointer are moving in a circular motion.
       * @constructor
       * @extends AttrRecognizer
       */
      function RotateRecognizer() {
          AttrRecognizer.apply(this, arguments);
      }

      inherit(RotateRecognizer, AttrRecognizer, {
          /**
           * @namespace
           * @memberof RotateRecognizer
           */
          defaults: {
              event: 'rotate',
              threshold: 0,
              pointers: 2
          },

          getTouchAction: function getTouchAction() {
              return [TOUCH_ACTION_NONE];
          },

          attrTest: function attrTest(input) {
              return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
          }
      });

      /**
       * Swipe
       * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
       * @constructor
       * @extends AttrRecognizer
       */
      function SwipeRecognizer() {
          AttrRecognizer.apply(this, arguments);
      }

      inherit(SwipeRecognizer, AttrRecognizer, {
          /**
           * @namespace
           * @memberof SwipeRecognizer
           */
          defaults: {
              event: 'swipe',
              threshold: 10,
              velocity: 0.3,
              direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
              pointers: 1
          },

          getTouchAction: function getTouchAction() {
              return PanRecognizer.prototype.getTouchAction.call(this);
          },

          attrTest: function attrTest(input) {
              var direction = this.options.direction;
              var velocity;

              if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                  velocity = input.overallVelocity;
              } else if (direction & DIRECTION_HORIZONTAL) {
                  velocity = input.overallVelocityX;
              } else if (direction & DIRECTION_VERTICAL) {
                  velocity = input.overallVelocityY;
              }

              return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
          },

          emit: function emit(input) {
              var direction = directionStr(input.offsetDirection);
              if (direction) {
                  this.manager.emit(this.options.event + direction, input);
              }

              this.manager.emit(this.options.event, input);
          }
      });

      /**
       * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
       * between the given interval and position. The delay option can be used to recognize multi-taps without firing
       * a single tap.
       *
       * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
       * multi-taps being recognized.
       * @constructor
       * @extends Recognizer
       */
      function TapRecognizer() {
          Recognizer.apply(this, arguments);

          // previous time and center,
          // used for tap counting
          this.pTime = false;
          this.pCenter = false;

          this._timer = null;
          this._input = null;
          this.count = 0;
      }

      inherit(TapRecognizer, Recognizer, {
          /**
           * @namespace
           * @memberof PinchRecognizer
           */
          defaults: {
              event: 'tap',
              pointers: 1,
              taps: 1,
              interval: 300, // max time between the multi-tap taps
              time: 250, // max time of the pointer to be down (like finger on the screen)
              threshold: 9, // a minimal movement is ok, but keep it low
              posThreshold: 10 // a multi-tap can be a bit off the initial position
          },

          getTouchAction: function getTouchAction() {
              return [TOUCH_ACTION_MANIPULATION];
          },

          process: function process(input) {
              var options = this.options;

              var validPointers = input.pointers.length === options.pointers;
              var validMovement = input.distance < options.threshold;
              var validTouchTime = input.deltaTime < options.time;

              this.reset();

              if (input.eventType & INPUT_START && this.count === 0) {
                  return this.failTimeout();
              }

              // we only allow little movement
              // and we've reached an end event, so a tap is possible
              if (validMovement && validTouchTime && validPointers) {
                  if (input.eventType != INPUT_END) {
                      return this.failTimeout();
                  }

                  var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                  var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

                  this.pTime = input.timeStamp;
                  this.pCenter = input.center;

                  if (!validMultiTap || !validInterval) {
                      this.count = 1;
                  } else {
                      this.count += 1;
                  }

                  this._input = input;

                  // if tap count matches we have recognized it,
                  // else it has began recognizing...
                  var tapCount = this.count % options.taps;
                  if (tapCount === 0) {
                      // no failing requirements, immediately trigger the tap event
                      // or wait as long as the multitap interval to trigger
                      if (!this.hasRequireFailures()) {
                          return STATE_RECOGNIZED;
                      } else {
                          this._timer = setTimeoutContext(function () {
                              this.state = STATE_RECOGNIZED;
                              this.tryEmit();
                          }, options.interval, this);
                          return STATE_BEGAN;
                      }
                  }
              }
              return STATE_FAILED;
          },

          failTimeout: function failTimeout() {
              this._timer = setTimeoutContext(function () {
                  this.state = STATE_FAILED;
              }, this.options.interval, this);
              return STATE_FAILED;
          },

          reset: function reset() {
              clearTimeout(this._timer);
          },

          emit: function emit() {
              if (this.state == STATE_RECOGNIZED) {
                  this._input.tapCount = this.count;
                  this.manager.emit(this.options.event, this._input);
              }
          }
      });

      /**
       * Simple way to create a manager with a default set of recognizers.
       * @param {HTMLElement} element
       * @param {Object} [options]
       * @constructor
       */
      function Hammer(element, options) {
          options = options || {};
          options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
          return new Manager(element, options);
      }

      /**
       * @const {string}
       */
      Hammer.VERSION = '2.0.7';

      /**
       * default settings
       * @namespace
       */
      Hammer.defaults = {
          /**
           * set if DOM events are being triggered.
           * But this is slower and unused by simple implementations, so disabled by default.
           * @type {Boolean}
           * @default false
           */
          domEvents: false,

          /**
           * The value for the touchAction property/fallback.
           * When set to `compute` it will magically set the correct value based on the added recognizers.
           * @type {String}
           * @default compute
           */
          touchAction: TOUCH_ACTION_COMPUTE,

          /**
           * @type {Boolean}
           * @default true
           */
          enable: true,

          /**
           * EXPERIMENTAL FEATURE -- can be removed/changed
           * Change the parent input target element.
           * If Null, then it is being set the to main element.
           * @type {Null|EventTarget}
           * @default null
           */
          inputTarget: null,

          /**
           * force an input class
           * @type {Null|Function}
           * @default null
           */
          inputClass: null,

          /**
           * Default recognizer setup when calling `Hammer()`
           * When creating a new Manager these will be skipped.
           * @type {Array}
           */
          preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, { enable: false }], [PinchRecognizer, { enable: false }, ['rotate']], [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }], [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']], [TapRecognizer], [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']], [PressRecognizer]],

          /**
           * Some CSS properties can be used to improve the working of Hammer.
           * Add them to this method and they will be set when creating a new Manager.
           * @namespace
           */
          cssProps: {
              /**
               * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
               * @type {String}
               * @default 'none'
               */
              userSelect: 'none',

              /**
               * Disable the Windows Phone grippers when pressing an element.
               * @type {String}
               * @default 'none'
               */
              touchSelect: 'none',

              /**
               * Disables the default callout shown when you touch and hold a touch target.
               * On iOS, when you touch and hold a touch target such as a link, Safari displays
               * a callout containing information about the link. This property allows you to disable that callout.
               * @type {String}
               * @default 'none'
               */
              touchCallout: 'none',

              /**
               * Specifies whether zooming is enabled. Used by IE10>
               * @type {String}
               * @default 'none'
               */
              contentZooming: 'none',

              /**
               * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
               * @type {String}
               * @default 'none'
               */
              userDrag: 'none',

              /**
               * Overrides the highlight color shown when the user taps a link or a JavaScript
               * clickable element in iOS. This property obeys the alpha value, if specified.
               * @type {String}
               * @default 'rgba(0,0,0,0)'
               */
              tapHighlightColor: 'rgba(0,0,0,0)'
          }
      };

      var STOP = 1;
      var FORCED_STOP = 2;

      /**
       * Manager
       * @param {HTMLElement} element
       * @param {Object} [options]
       * @constructor
       */
      function Manager(element, options) {
          this.options = assign({}, Hammer.defaults, options || {});

          this.options.inputTarget = this.options.inputTarget || element;

          this.handlers = {};
          this.session = {};
          this.recognizers = [];
          this.oldCssProps = {};

          this.element = element;
          this.input = createInputInstance(this);
          this.touchAction = new TouchAction(this, this.options.touchAction);

          toggleCssProps(this, true);

          each(this.options.recognizers, function (item) {
              var recognizer = this.add(new item[0](item[1]));
              item[2] && recognizer.recognizeWith(item[2]);
              item[3] && recognizer.requireFailure(item[3]);
          }, this);
      }

      Manager.prototype = {
          /**
           * set options
           * @param {Object} options
           * @returns {Manager}
           */
          set: function set(options) {
              assign(this.options, options);

              // Options that need a little more setup
              if (options.touchAction) {
                  this.touchAction.update();
              }
              if (options.inputTarget) {
                  // Clean up existing event listeners and reinitialize
                  this.input.destroy();
                  this.input.target = options.inputTarget;
                  this.input.init();
              }
              return this;
          },

          /**
           * stop recognizing for this session.
           * This session will be discarded, when a new [input]start event is fired.
           * When forced, the recognizer cycle is stopped immediately.
           * @param {Boolean} [force]
           */
          stop: function stop(force) {
              this.session.stopped = force ? FORCED_STOP : STOP;
          },

          /**
           * run the recognizers!
           * called by the inputHandler function on every movement of the pointers (touches)
           * it walks through all the recognizers and tries to detect the gesture that is being made
           * @param {Object} inputData
           */
          recognize: function recognize(inputData) {
              var session = this.session;
              if (session.stopped) {
                  return;
              }

              // run the touch-action polyfill
              this.touchAction.preventDefaults(inputData);

              var recognizer;
              var recognizers = this.recognizers;

              // this holds the recognizer that is being recognized.
              // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
              // if no recognizer is detecting a thing, it is set to `null`
              var curRecognizer = session.curRecognizer;

              // reset when the last recognizer is recognized
              // or when we're in a new session
              if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
                  curRecognizer = session.curRecognizer = null;
              }

              var i = 0;
              while (i < recognizers.length) {
                  recognizer = recognizers[i];

                  // find out if we are allowed try to recognize the input for this one.
                  // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                  // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                  //      that is being recognized.
                  // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                  //      this can be setup with the `recognizeWith()` method on the recognizer.
                  if (session.stopped !== FORCED_STOP && ( // 1
                  !curRecognizer || recognizer == curRecognizer || // 2
                  recognizer.canRecognizeWith(curRecognizer))) {
                      // 3
                      recognizer.recognize(inputData);
                  } else {
                      recognizer.reset();
                  }

                  // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                  // current active recognizer. but only if we don't already have an active recognizer
                  if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                      curRecognizer = session.curRecognizer = recognizer;
                  }
                  i++;
              }
          },

          /**
           * get a recognizer by its event name.
           * @param {Recognizer|String} recognizer
           * @returns {Recognizer|Null}
           */
          get: function get(recognizer) {
              if (recognizer instanceof Recognizer) {
                  return recognizer;
              }

              var recognizers = this.recognizers;
              for (var i = 0; i < recognizers.length; i++) {
                  if (recognizers[i].options.event == recognizer) {
                      return recognizers[i];
                  }
              }
              return null;
          },

          /**
           * add a recognizer to the manager
           * existing recognizers with the same event name will be removed
           * @param {Recognizer} recognizer
           * @returns {Recognizer|Manager}
           */
          add: function add(recognizer) {
              if (invokeArrayArg(recognizer, 'add', this)) {
                  return this;
              }

              // remove existing
              var existing = this.get(recognizer.options.event);
              if (existing) {
                  this.remove(existing);
              }

              this.recognizers.push(recognizer);
              recognizer.manager = this;

              this.touchAction.update();
              return recognizer;
          },

          /**
           * remove a recognizer by name or instance
           * @param {Recognizer|String} recognizer
           * @returns {Manager}
           */
          remove: function remove(recognizer) {
              if (invokeArrayArg(recognizer, 'remove', this)) {
                  return this;
              }

              recognizer = this.get(recognizer);

              // let's make sure this recognizer exists
              if (recognizer) {
                  var recognizers = this.recognizers;
                  var index = inArray(recognizers, recognizer);

                  if (index !== -1) {
                      recognizers.splice(index, 1);
                      this.touchAction.update();
                  }
              }

              return this;
          },

          /**
           * bind event
           * @param {String} events
           * @param {Function} handler
           * @returns {EventEmitter} this
           */
          on: function on(events, handler) {
              if (events === undefined) {
                  return;
              }
              if (handler === undefined) {
                  return;
              }

              var handlers = this.handlers;
              each(splitStr(events), function (event) {
                  handlers[event] = handlers[event] || [];
                  handlers[event].push(handler);
              });
              return this;
          },

          /**
           * unbind event, leave emit blank to remove all handlers
           * @param {String} events
           * @param {Function} [handler]
           * @returns {EventEmitter} this
           */
          off: function off(events, handler) {
              if (events === undefined) {
                  return;
              }

              var handlers = this.handlers;
              each(splitStr(events), function (event) {
                  if (!handler) {
                      delete handlers[event];
                  } else {
                      handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
                  }
              });
              return this;
          },

          /**
           * emit event to the listeners
           * @param {String} event
           * @param {Object} data
           */
          emit: function emit(event, data) {
              // we also want to trigger dom events
              if (this.options.domEvents) {
                  triggerDomEvent(event, data);
              }

              // no handlers, so skip it all
              var handlers = this.handlers[event] && this.handlers[event].slice();
              if (!handlers || !handlers.length) {
                  return;
              }

              data.type = event;
              data.preventDefault = function () {
                  data.srcEvent.preventDefault();
              };

              var i = 0;
              while (i < handlers.length) {
                  handlers[i](data);
                  i++;
              }
          },

          /**
           * destroy the manager and unbinds all events
           * it doesn't unbind dom events, that is the user own responsibility
           */
          destroy: function destroy() {
              this.element && toggleCssProps(this, false);

              this.handlers = {};
              this.session = {};
              this.input.destroy();
              this.element = null;
          }
      };

      /**
       * add/remove the css properties as defined in manager.options.cssProps
       * @param {Manager} manager
       * @param {Boolean} add
       */
      function toggleCssProps(manager, add) {
          var element = manager.element;
          if (!element.style) {
              return;
          }
          var prop;
          each(manager.options.cssProps, function (value, name) {
              prop = prefixed(element.style, name);
              if (add) {
                  manager.oldCssProps[prop] = element.style[prop];
                  element.style[prop] = value;
              } else {
                  element.style[prop] = manager.oldCssProps[prop] || '';
              }
          });
          if (!add) {
              manager.oldCssProps = {};
          }
      }

      /**
       * trigger dom event
       * @param {String} event
       * @param {Object} data
       */
      function triggerDomEvent(event, data) {
          var gestureEvent = document.createEvent('Event');
          gestureEvent.initEvent(event, true, true);
          gestureEvent.gesture = data;
          data.target.dispatchEvent(gestureEvent);
      }

      assign(Hammer, {
          INPUT_START: INPUT_START,
          INPUT_MOVE: INPUT_MOVE,
          INPUT_END: INPUT_END,
          INPUT_CANCEL: INPUT_CANCEL,

          STATE_POSSIBLE: STATE_POSSIBLE,
          STATE_BEGAN: STATE_BEGAN,
          STATE_CHANGED: STATE_CHANGED,
          STATE_ENDED: STATE_ENDED,
          STATE_RECOGNIZED: STATE_RECOGNIZED,
          STATE_CANCELLED: STATE_CANCELLED,
          STATE_FAILED: STATE_FAILED,

          DIRECTION_NONE: DIRECTION_NONE,
          DIRECTION_LEFT: DIRECTION_LEFT,
          DIRECTION_RIGHT: DIRECTION_RIGHT,
          DIRECTION_UP: DIRECTION_UP,
          DIRECTION_DOWN: DIRECTION_DOWN,
          DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
          DIRECTION_VERTICAL: DIRECTION_VERTICAL,
          DIRECTION_ALL: DIRECTION_ALL,

          Manager: Manager,
          Input: Input,
          TouchAction: TouchAction,

          TouchInput: TouchInput,
          MouseInput: MouseInput,
          PointerEventInput: PointerEventInput,
          TouchMouseInput: TouchMouseInput,
          SingleTouchInput: SingleTouchInput,

          Recognizer: Recognizer,
          AttrRecognizer: AttrRecognizer,
          Tap: TapRecognizer,
          Pan: PanRecognizer,
          Swipe: SwipeRecognizer,
          Pinch: PinchRecognizer,
          Rotate: RotateRecognizer,
          Press: PressRecognizer,

          on: addEventListeners,
          off: removeEventListeners,
          each: each,
          merge: merge,
          extend: extend,
          assign: assign,
          inherit: inherit,
          bindFn: bindFn,
          prefixed: prefixed
      });

      // this prevents errors when Hammer is loaded in the presence of an AMD
      //  style loader but by script tag, not by the loader.
      var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line
      freeGlobal.Hammer = Hammer;

      if (typeof undefined === 'function' && undefined.amd) {
          undefined(function () {
              return Hammer;
          });
      } else if ('object' != 'undefined' && module.exports) {
          module.exports = Hammer;
      } else {
          window[exportName] = Hammer;
      }
  })(window, document, 'Hammer');
  });

  var MIN_ZOOM = 0.2,
      MAX_ZOOM = 4;

  var mouseEvents = ['mousedown', 'mouseup', 'mouseover', 'mouseout', 'click', 'dblclick'];

  function get$1(service, injector) {
    return injector.get(service, false);
  }

  function stopEvent(event$$1) {

    event$$1.preventDefault();
    event$$1.stopPropagation();

    if (typeof event$$1.stopImmediatePropagation === 'function') {
      event$$1.stopImmediatePropagation();
    }
  }

  function createTouchRecognizer(node) {

    function stopMouse(event$$1) {

      forEach(mouseEvents, function (e) {
        componentEvent.bind(node, e, stopEvent, true);
      });
    }

    function allowMouse(event$$1) {
      setTimeout(function () {
        forEach(mouseEvents, function (e) {
          componentEvent.unbind(node, e, stopEvent, true);
        });
      }, 500);
    }

    componentEvent.bind(node, 'touchstart', stopMouse, true);
    componentEvent.bind(node, 'touchend', allowMouse, true);
    componentEvent.bind(node, 'touchcancel', allowMouse, true);

    // A touch event recognizer that handles
    // touch events only (we know, we can already handle
    // mouse events out of the box)

    var recognizer = new hammer.Manager(node, {
      inputClass: hammer.TouchInput,
      recognizers: []
    });

    var tap = new hammer.Tap();
    var pan = new hammer.Pan({ threshold: 10 });
    var press = new hammer.Press();
    var pinch = new hammer.Pinch();

    var doubleTap = new hammer.Tap({ event: 'doubletap', taps: 2 });

    pinch.requireFailure(pan);
    pinch.requireFailure(press);

    recognizer.add([pan, press, pinch, doubleTap, tap]);

    recognizer.reset = function (force) {
      var recognizers = this.recognizers,
          session = this.session;

      if (session.stopped) {
        return;
      }

      recognizer.stop(force);

      setTimeout(function () {
        var i, r;
        for (i = 0; r = recognizers[i]; i++) {
          r.reset();
          r.state = 8; // FAILED STATE
        }

        session.curRecognizer = null;
      }, 0);
    };

    recognizer.on('hammer.input', function (event$$1) {
      if (event$$1.srcEvent.defaultPrevented) {
        recognizer.reset(true);
      }
    });

    return recognizer;
  }

  /**
   * A plugin that provides touch events for elements.
   *
   * @param {EventBus} eventBus
   * @param {InteractionEvents} interactionEvents
   */
  function TouchInteractionEvents(injector, canvas, eventBus, elementRegistry, interactionEvents) {

    // optional integrations
    var dragging = get$1('dragging', injector),
        move = get$1('move', injector),
        contextPad = get$1('contextPad', injector),
        palette = get$1('palette', injector);

    // the touch recognizer
    var recognizer;

    function handler(type) {

      return function (event$$1) {

        interactionEvents.fire(type, event$$1);
      };
    }

    function getGfx(target) {
      var node = closest(target, 'svg, .djs-element', true);
      return node;
    }

    function initEvents(svg) {

      // touch recognizer
      recognizer = createTouchRecognizer(svg);

      recognizer.on('doubletap', handler('element.dblclick'));

      recognizer.on('tap', handler('element.click'));

      function startGrabCanvas(event$$1) {

        var lx = 0,
            ly = 0;

        function update(e) {

          var dx = e.deltaX - lx,
              dy = e.deltaY - ly;

          canvas.scroll({ dx: dx, dy: dy });

          lx = e.deltaX;
          ly = e.deltaY;
        }

        function end(e) {
          recognizer.off('panmove', update);
          recognizer.off('panend', end);
          recognizer.off('pancancel', end);
        }

        recognizer.on('panmove', update);
        recognizer.on('panend', end);
        recognizer.on('pancancel', end);
      }

      function startGrab(event$$1) {

        var gfx = getGfx(event$$1.target),
            element = gfx && elementRegistry.get(gfx);

        // recognizer
        if (move && canvas.getRootElement() !== element) {
          return move.start(event$$1, element, true);
        } else {
          startGrabCanvas(event$$1);
        }
      }

      function startZoom(e) {

        var zoom = canvas.zoom(),
            mid = e.center;

        function update(e) {

          var ratio = 1 - (1 - e.scale) / 1.50,
              newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, ratio * zoom));

          canvas.zoom(newZoom, mid);

          stopEvent(e);
        }

        function end(e) {
          recognizer.off('pinchmove', update);
          recognizer.off('pinchend', end);
          recognizer.off('pinchcancel', end);

          recognizer.reset(true);
        }

        recognizer.on('pinchmove', update);
        recognizer.on('pinchend', end);
        recognizer.on('pinchcancel', end);
      }

      recognizer.on('panstart', startGrab);
      recognizer.on('press', startGrab);

      recognizer.on('pinchstart', startZoom);
    }

    if (dragging) {

      // simulate hover during dragging
      eventBus.on('drag.move', function (event$$1) {

        var originalEvent = event$$1.originalEvent;

        if (!originalEvent || originalEvent instanceof MouseEvent) {
          return;
        }

        var position = toPoint(originalEvent);

        // this gets really expensive ...
        var node = document.elementFromPoint(position.x, position.y),
            gfx = getGfx(node),
            element = gfx && elementRegistry.get(gfx);

        if (element !== event$$1.hover) {
          if (event$$1.hover) {
            dragging.out(event$$1);
          }

          if (element) {
            dragging.hover({ element: element, gfx: gfx });

            event$$1.hover = element;
            event$$1.hoverGfx = gfx;
          }
        }
      });
    }

    if (contextPad) {

      eventBus.on('contextPad.create', function (event$$1) {
        var node = event$$1.pad.html;

        // touch recognizer
        var padRecognizer = createTouchRecognizer(node);

        padRecognizer.on('panstart', function (event$$1) {
          contextPad.trigger('dragstart', event$$1, true);
        });

        padRecognizer.on('press', function (event$$1) {
          contextPad.trigger('dragstart', event$$1, true);
        });

        padRecognizer.on('tap', function (event$$1) {
          contextPad.trigger('click', event$$1);
        });
      });
    }

    if (palette) {
      eventBus.on('palette.create', function (event$$1) {
        var node = event$$1.container;

        // touch recognizer
        var padRecognizer = createTouchRecognizer(node);

        padRecognizer.on('panstart', function (event$$1) {
          palette.trigger('dragstart', event$$1, true);
        });

        padRecognizer.on('press', function (event$$1) {
          palette.trigger('dragstart', event$$1, true);
        });

        padRecognizer.on('tap', function (event$$1) {
          palette.trigger('click', event$$1);
        });
      });
    }

    eventBus.on('canvas.init', function (event$$1) {
      initEvents(event$$1.svg);
    });
  }

  TouchInteractionEvents.$inject = ['injector', 'canvas', 'eventBus', 'elementRegistry', 'interactionEvents', 'touchFix'];

  function TouchFix(canvas, eventBus) {

    var self = this;

    eventBus.on('canvas.init', function (e) {
      self.addBBoxMarker(e.svg);
    });
  }

  TouchFix.$inject = ['canvas', 'eventBus'];

  /**
   * Safari mobile (iOS 7) does not fire touchstart event in <SVG> element
   * if there is no shape between 0,0 and viewport elements origin.
   *
   * So touchstart event is only fired when the <g class="viewport"> element was hit.
   * Putting an element over and below the 'viewport' fixes that behavior.
   */
  TouchFix.prototype.addBBoxMarker = function (svg) {

    var markerStyle = {
      fill: 'none',
      class: 'outer-bound-marker'
    };

    var rect1 = create('rect');
    attr$1(rect1, {
      x: -10000,
      y: 10000,
      width: 10,
      height: 10
    });
    attr$1(rect1, markerStyle);

    append(svg, rect1);

    var rect2 = create('rect');
    attr$1(rect2, {
      x: 10000,
      y: 10000,
      width: 10,
      height: 10
    });
    attr$1(rect2, markerStyle);

    append(svg, rect2);
  };

  var TouchModule = {
    __depends__: [InteractionEventsModule],
    __init__: ['touchInteractionEvents'],
    touchInteractionEvents: ['type', TouchInteractionEvents],
    touchFix: ['type', TouchFix]
  };

  var TouchModule$1 = {
    __depends__: [TouchModule]
  };

  /**
   * A viewer that includes mouse navigation facilities
   *
   * @param {Object} options
   */
  function NavigatedViewer(options) {
    Viewer.call(this, options);
  }

  inherits_browser(NavigatedViewer, Viewer);

  NavigatedViewer.prototype._navigationModules = [ZoomScrollModule, MoveCanvas$1, TouchModule$1];

  NavigatedViewer.prototype._modules = [].concat(NavigatedViewer.prototype._modules, NavigatedViewer.prototype._navigationModules);

  /**
   * A service that provides rules for certain diagram actions.
   *
   * The default implementation will hook into the {@link CommandStack}
   * to perform the actual rule evaluation. Make sure to provide the
   * `commandStack` service with this module if you plan to use it.
   *
   * Together with this implementation you may use the {@link RuleProvider}
   * to implement your own rule checkers.
   *
   * This module is ment to be easily replaced, thus the tiny foot print.
   *
   * @param {Injector} injector
   */
  function Rules(injector) {
    this._commandStack = injector.get('commandStack', false);
  }

  Rules.$inject = ['injector'];

  /**
   * Returns whether or not a given modeling action can be executed
   * in the specified context.
   *
   * This implementation will respond with allow unless anyone
   * objects.
   *
   * @param {String} action the action to be checked
   * @param {Object} [context] the context to check the action in
   *
   * @return {Boolean} returns true, false or null depending on whether the
   *                   operation is allowed, not allowed or should be ignored.
   */
  Rules.prototype.allowed = function (action, context) {
    var allowed = true;

    var commandStack = this._commandStack;

    if (commandStack) {
      allowed = commandStack.canExecute(action, context);
    }

    // map undefined to true, i.e. no rules
    return allowed === undefined ? true : allowed;
  };

  var Rules$1 = {
    __init__: ['rules'],
    rules: ['type', Rules]
  };

  /* global TouchEvent */

  var round$1 = Math.round;

  var DRAG_ACTIVE_CLS = 'djs-drag-active';

  function preventDefault(event$$1) {
    event$$1.preventDefault();
  }

  function isTouchEvent(event$$1) {
    // check for TouchEvent being available first
    // (i.e. not available on desktop Firefox)
    return typeof TouchEvent !== 'undefined' && event$$1 instanceof TouchEvent;
  }

  function getLength(point) {
    return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
  }

  /**
   * A helper that fires canvas localized drag events and realizes
   * the general "drag-and-drop" look and feel.
   *
   * Calling {@link Dragging#activate} activates dragging on a canvas.
   *
   * It provides the following:
   *
   *   * emits life cycle events, namespaced with a prefix assigned
   *     during dragging activation
   *   * sets and restores the cursor
   *   * sets and restores the selection
   *   * ensures there can be only one drag operation active at a time
   *
   * Dragging may be canceled manually by calling {@link Dragging#cancel}
   * or by pressing ESC.
   *
   *
   * ## Life-cycle events
   *
   * Dragging can be in three different states, off, initialized
   * and active.
   *
   * (1) off: no dragging operation is in progress
   * (2) initialized: a new drag operation got initialized but not yet
   *                  started (i.e. because of no initial move)
   * (3) started: dragging is in progress
   *
   * Eventually dragging will be off again after a drag operation has
   * been ended or canceled via user click or ESC key press.
   *
   * To indicate transitions between these states dragging emits generic
   * life-cycle events with the `drag.` prefix _and_ events namespaced
   * to a prefix choosen by a user during drag initialization.
   *
   * The following events are emitted (appropriately prefixed) via
   * the {@link EventBus}.
   *
   * * `init`
   * * `start`
   * * `move`
   * * `end`
   * * `ended` (dragging already in off state)
   * * `cancel` (only if previously started)
   * * `canceled` (dragging already in off state, only if previously started)
   * * `cleanup`
   *
   *
   * @example
   *
   * function MyDragComponent(eventBus, dragging) {
   *
   *   eventBus.on('mydrag.start', function(event) {
   *     console.log('yes, we start dragging');
   *   });
   *
   *   eventBus.on('mydrag.move', function(event) {
   *     console.log('canvas local coordinates', event.x, event.y, event.dx, event.dy);
   *
   *     // local drag data is passed with the event
   *     event.context.foo; // "BAR"
   *
   *     // the original mouse event, too
   *     event.originalEvent; // MouseEvent(...)
   *   });
   *
   *   eventBus.on('element.click', function(event) {
   *     dragging.init(event, 'mydrag', {
   *       cursor: 'grabbing',
   *       data: {
   *         context: {
   *           foo: "BAR"
   *         }
   *       }
   *     });
   *   });
   * }
   */
  function Dragging(eventBus, canvas, selection) {

    var defaultOptions = {
      threshold: 5,
      trapClick: true
    };

    // the currently active drag operation
    // dragging is active as soon as this context exists.
    //
    // it is visually _active_ only when a context.active flag is set to true.
    var context;

    /* convert a global event into local coordinates */
    function toLocalPoint(globalPosition) {

      var viewbox = canvas.viewbox();

      var clientRect = canvas._container.getBoundingClientRect();

      return {
        x: viewbox.x + (globalPosition.x - clientRect.left) / viewbox.scale,
        y: viewbox.y + (globalPosition.y - clientRect.top) / viewbox.scale
      };
    }

    // helpers

    function fire(type, dragContext) {
      dragContext = dragContext || context;

      var event$$1 = eventBus.createEvent(assign({}, dragContext.payload, dragContext.data, { isTouch: dragContext.isTouch }));

      // default integration
      if (eventBus.fire('drag.' + type, event$$1) === false) {
        return false;
      }

      return eventBus.fire(dragContext.prefix + '.' + type, event$$1);
    }

    // event listeners

    function move(event$$1, activate) {
      var payload = context.payload,
          displacement = context.displacement;

      var globalStart = context.globalStart,
          globalCurrent = toPoint(event$$1),
          globalDelta = delta(globalCurrent, globalStart);

      var localStart = context.localStart,
          localCurrent = toLocalPoint(globalCurrent),
          localDelta = delta(localCurrent, localStart);

      // activate context explicitly or once threshold is reached
      if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {

        // fire start event with original
        // starting coordinates

        assign(payload, {
          x: round$1(localStart.x + displacement.x),
          y: round$1(localStart.y + displacement.y),
          dx: 0,
          dy: 0
        }, { originalEvent: event$$1 });

        if (false === fire('start')) {
          return cancel();
        }

        context.active = true;

        // unset selection and remember old selection
        // the previous (old) selection will always passed
        // with the event via the event.previousSelection property
        if (!context.keepSelection) {
          payload.previousSelection = selection.get();
          selection.select(null);
        }

        // allow custom cursor
        if (context.cursor) {
          set$1(context.cursor);
        }

        // indicate dragging via marker on root element
        canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
      }

      stopPropagation(event$$1);

      if (context.active) {

        // update payload with actual coordinates
        assign(payload, {
          x: round$1(localCurrent.x + displacement.x),
          y: round$1(localCurrent.y + displacement.y),
          dx: round$1(localDelta.x),
          dy: round$1(localDelta.y)
        }, { originalEvent: event$$1 });

        // emit move event
        fire('move');
      }
    }

    function end(event$$1) {
      var previousContext,
          returnValue = true;

      if (context.active) {

        if (event$$1) {
          context.payload.originalEvent = event$$1;

          // suppress original event (click, ...)
          // because we just ended a drag operation
          stopPropagation(event$$1);
        }

        // implementations may stop restoring the
        // original state (selections, ...) by preventing the
        // end events default action
        returnValue = fire('end');
      }

      if (returnValue === false) {
        fire('rejected');
      }

      previousContext = cleanup(returnValue !== true);

      // last event to be fired when all drag operations are done
      // at this point in time no drag operation is in progress anymore
      fire('ended', previousContext);
    }

    // cancel active drag operation if the user presses
    // the ESC key on the keyboard

    function checkCancel(event$$1) {

      if (event$$1.which === 27) {
        preventDefault(event$$1);

        cancel();
      }
    }

    // prevent ghost click that might occur after a finished
    // drag and drop session

    function trapClickAndEnd(event$$1) {

      var untrap;

      // trap the click in case we are part of an active
      // drag operation. This will effectively prevent
      // the ghost click that cannot be canceled otherwise.
      if (context.active) {

        untrap = install(eventBus);

        // remove trap after minimal delay
        setTimeout(untrap, 400);

        // prevent default action (click)
        preventDefault(event$$1);
      }

      end(event$$1);
    }

    function trapTouch(event$$1) {
      move(event$$1);
    }

    // update the drag events hover (djs.model.Base) and hoverGfx (Snap<SVGElement>)
    // properties during hover and out and fire {prefix}.hover and {prefix}.out properties
    // respectively

    function hover(event$$1) {
      var payload = context.payload;

      payload.hoverGfx = event$$1.gfx;
      payload.hover = event$$1.element;

      fire('hover');
    }

    function out(event$$1) {
      fire('out');

      var payload = context.payload;

      payload.hoverGfx = null;
      payload.hover = null;
    }

    // life-cycle methods

    function cancel(restore) {
      var previousContext;

      if (!context) {
        return;
      }

      var wasActive = context.active;

      if (wasActive) {
        fire('cancel');
      }

      previousContext = cleanup(restore);

      if (wasActive) {
        // last event to be fired when all drag operations are done
        // at this point in time no drag operation is in progress anymore
        fire('canceled', previousContext);
      }
    }

    function cleanup(restore) {
      var previousContext, endDrag;

      fire('cleanup');

      // reset cursor
      unset();

      if (context.trapClick) {
        endDrag = trapClickAndEnd;
      } else {
        endDrag = end;
      }

      // reset dom listeners
      componentEvent.unbind(document, 'mousemove', move);

      componentEvent.unbind(document, 'dragstart', preventDefault);
      componentEvent.unbind(document, 'selectstart', preventDefault);

      componentEvent.unbind(document, 'mousedown', endDrag, true);
      componentEvent.unbind(document, 'mouseup', endDrag, true);

      componentEvent.unbind(document, 'keyup', checkCancel);

      componentEvent.unbind(document, 'touchstart', trapTouch, true);
      componentEvent.unbind(document, 'touchcancel', cancel, true);
      componentEvent.unbind(document, 'touchmove', move, true);
      componentEvent.unbind(document, 'touchend', end, true);

      eventBus.off('element.hover', hover);
      eventBus.off('element.out', out);

      // remove drag marker on root element
      canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);

      // restore selection, unless it has changed
      var previousSelection = context.payload.previousSelection;

      if (restore !== false && previousSelection && !selection.get().length) {
        selection.select(previousSelection);
      }

      previousContext = context;

      context = null;

      return previousContext;
    }

    /**
     * Initialize a drag operation.
     *
     * If `localPosition` is given, drag events will be emitted
     * relative to it.
     *
     * @param {MouseEvent|TouchEvent} [event]
     * @param {Point} [localPosition] actual diagram local position this drag operation should start at
     * @param {String} prefix
     * @param {Object} [options]
     */
    function init(event$$1, relativeTo, prefix, options) {

      // only one drag operation may be active, at a time
      if (context) {
        cancel(false);
      }

      if (typeof relativeTo === 'string') {
        options = prefix;
        prefix = relativeTo;
        relativeTo = null;
      }

      options = assign({}, defaultOptions, options || {});

      var data = options.data || {},
          originalEvent,
          globalStart,
          localStart,
          endDrag,
          isTouch;

      if (options.trapClick) {
        endDrag = trapClickAndEnd;
      } else {
        endDrag = end;
      }

      if (event$$1) {
        originalEvent = getOriginal(event$$1) || event$$1;
        globalStart = toPoint(event$$1);

        stopPropagation(event$$1);

        // prevent default browser dragging behavior
        if (originalEvent.type === 'dragstart') {
          preventDefault(originalEvent);
        }
      } else {
        originalEvent = null;
        globalStart = { x: 0, y: 0 };
      }

      localStart = toLocalPoint(globalStart);

      if (!relativeTo) {
        relativeTo = localStart;
      }

      isTouch = isTouchEvent(originalEvent);

      context = assign({
        prefix: prefix,
        data: data,
        payload: {},
        globalStart: globalStart,
        displacement: delta(relativeTo, localStart),
        localStart: localStart,
        isTouch: isTouch
      }, options);

      // skip dom registration if trigger
      // is set to manual (during testing)
      if (!options.manual) {

        // add dom listeners

        if (isTouch) {
          componentEvent.bind(document, 'touchstart', trapTouch, true);
          componentEvent.bind(document, 'touchcancel', cancel, true);
          componentEvent.bind(document, 'touchmove', move, true);
          componentEvent.bind(document, 'touchend', end, true);
        } else {
          // assume we use the mouse to interact per default
          componentEvent.bind(document, 'mousemove', move);

          // prevent default browser drag and text selection behavior
          componentEvent.bind(document, 'dragstart', preventDefault);
          componentEvent.bind(document, 'selectstart', preventDefault);

          componentEvent.bind(document, 'mousedown', endDrag, true);
          componentEvent.bind(document, 'mouseup', endDrag, true);
        }

        componentEvent.bind(document, 'keyup', checkCancel);

        eventBus.on('element.hover', hover);
        eventBus.on('element.out', out);
      }

      fire('init');

      if (options.autoActivate) {
        move(event$$1, true);
      }
    }

    // cancel on diagram destruction
    eventBus.on('diagram.destroy', cancel);

    // API

    this.init = init;
    this.move = move;
    this.hover = hover;
    this.out = out;
    this.end = end;

    this.cancel = cancel;

    // for introspection

    this.context = function () {
      return context;
    };

    this.setOptions = function (options) {
      assign(defaultOptions, options);
    };
  }

  Dragging.$inject = ['eventBus', 'canvas', 'selection'];

  function getGfx(target) {
    var node = closest(target, 'svg, .djs-element', true);
    return node;
  }

  /**
   * Browsers may swallow the hover event if users are to
   * fast with the mouse.
   *
   * @see http://stackoverflow.com/questions/7448468/why-cant-i-reliably-capture-a-mouseout-event
   *
   * The fix implemented in this component ensure that we
   * have a hover state after a successive drag.move event.
   *
   * @param {EventBus} eventBus
   * @param {Dragging} dragging
   * @param {ElementRegistry} elementRegistry
   */
  function HoverFix(eventBus, dragging, elementRegistry) {

    var self = this;

    // we wait for a specific sequence of events before
    // emitting a fake drag.hover event.
    //
    // Event Sequence:
    //
    // drag.start
    // drag.move
    // drag.move >> ensure we are hovering
    //
    eventBus.on('drag.start', function (event) {

      eventBus.once('drag.move', function () {

        eventBus.once('drag.move', function (event) {

          self.ensureHover(event);
        });
      });
    });

    /**
     * Make sure we are god damn hovering!
     *
     * @param {Event} dragging event
     */
    this.ensureHover = function (event) {

      if (event.hover) {
        return;
      }

      var originalEvent = event.originalEvent,
          position,
          target,
          element,
          gfx;

      if (!(originalEvent instanceof MouseEvent)) {
        return;
      }

      position = toPoint(originalEvent);

      // damn expensive operation, ouch!
      target = document.elementFromPoint(position.x, position.y);

      gfx = getGfx(target);

      if (gfx) {
        element = elementRegistry.get(gfx);

        dragging.hover({ element: element, gfx: gfx });
      }
    };
  }

  HoverFix.$inject = ['eventBus', 'dragging', 'elementRegistry'];

  var DraggingModule = {
    __init__: ['hoverFix'],
    __depends__: [DiagramSelection],
    dragging: ['type', Dragging],
    hoverFix: ['type', HoverFix]
  };

  /**
   * Adds support for previews of moving/resizing elements.
   */
  function PreviewSupport(elementRegistry, canvas, styles) {
    this._elementRegistry = elementRegistry;
    this._canvas = canvas;
    this._styles = styles;
  }

  PreviewSupport.$inject = ['elementRegistry', 'canvas', 'styles'];

  /**
   * Returns graphics of an element.
   *
   * @param {djs.model.Base} element
   *
   * @return {SVGElement}
   */
  PreviewSupport.prototype.getGfx = function (element) {
    return this._elementRegistry.getGraphics(element);
  };

  /**
   * Adds a move preview of a given shape to a given svg group.
   *
   * @param {djs.model.Base} element
   * @param {SVGElement} group
   *
   * @return {SVGElement} dragger
   */
  PreviewSupport.prototype.addDragger = function (shape, group) {
    var gfx = this.getGfx(shape);

    // clone is not included in tsvg for some reason
    var dragger = clone(gfx);
    var bbox = gfx.getBoundingClientRect();

    // remove markers from connections
    if (isConnection(shape)) {
      removeMarkers(dragger);
    }

    attr$1(dragger, this._styles.cls('djs-dragger', [], {
      x: bbox.top,
      y: bbox.left
    }));

    append(group, dragger);

    return dragger;
  };

  /**
   * Adds a resize preview of a given shape to a given svg group.
   *
   * @param {djs.model.Base} element
   * @param {SVGElement} group
   *
   * @return {SVGElement} frame
   */
  PreviewSupport.prototype.addFrame = function (shape, group) {

    var frame = create('rect', {
      class: 'djs-resize-overlay',
      width: shape.width,
      height: shape.height,
      x: shape.x,
      y: shape.y
    });

    append(group, frame);

    return frame;
  };

  // helpers //////////////////////

  /**
   * Removes all svg marker references from an SVG.
   *
   * @param {SVGElement} gfx
   */
  function removeMarkers(gfx) {

    if (gfx.children) {

      forEach(gfx.children, function (child) {

        // recursion
        removeMarkers(child);
      });
    }

    gfx.style.markerStart = '';
    gfx.style.markerEnd = '';
  }

  /**
   * Checks if an element is a connection.
   */
  function isConnection(element) {
    return element.waypoints;
  }

  var PreviewSupportModule = {
    __init__: ['previewSupport'],
    previewSupport: ['type', PreviewSupport]
  };

  var LOW_PRIORITY$3 = 500,
      MEDIUM_PRIORITY = 1250,
      HIGH_PRIORITY = 1500;

  var round$2 = Math.round;

  function mid(element) {
    return {
      x: element.x + round$2(element.width / 2),
      y: element.y + round$2(element.height / 2)
    };
  }

  /**
   * A plugin that makes shapes draggable / droppable.
   *
   * @param {EventBus} eventBus
   * @param {Dragging} dragging
   * @param {Modeling} modeling
   * @param {Selection} selection
   * @param {Rules} rules
   */
  function MoveEvents(eventBus, dragging, modeling, selection, rules) {

    // rules

    function canMove(shapes, delta, position, target) {

      return rules.allowed('elements.move', {
        shapes: shapes,
        delta: delta,
        position: position,
        target: target
      });
    }

    // move events

    // assign a high priority to this handler to setup the environment
    // others may hook up later, e.g. at default priority and modify
    // the move environment.
    //
    // This sets up the context with
    //
    // * shape: the primary shape being moved
    // * shapes: a list of shapes to be moved
    // * validatedShapes: a list of shapes that are being checked
    //                    against the rules before and during move
    //
    eventBus.on('shape.move.start', HIGH_PRIORITY, function (event) {

      var context = event.context,
          shape = event.shape,
          shapes = selection.get().slice();

      // move only single shape if the dragged element
      // is not part of the current selection
      if (shapes.indexOf(shape) === -1) {
        shapes = [shape];
      }

      // ensure we remove nested elements in the collection
      // and add attachers for a proper dragger
      shapes = removeNested(shapes);

      // attach shapes to drag context
      assign(context, {
        shapes: shapes,
        validatedShapes: shapes,
        shape: shape
      });
    });

    // assign a high priority to this handler to setup the environment
    // others may hook up later, e.g. at default priority and modify
    // the move environment
    //
    eventBus.on('shape.move.start', MEDIUM_PRIORITY, function (event) {

      var context = event.context,
          validatedShapes = context.validatedShapes,
          canExecute;

      canExecute = context.canExecute = canMove(validatedShapes);

      // check if we can move the elements
      if (!canExecute) {
        return false;
      }
    });

    // assign a low priority to this handler
    // to let others modify the move event before we update
    // the context
    //
    eventBus.on('shape.move.move', LOW_PRIORITY$3, function (event) {

      var context = event.context,
          validatedShapes = context.validatedShapes,
          hover = event.hover,
          delta = { x: event.dx, y: event.dy },
          position = { x: event.x, y: event.y },
          canExecute;

      // check if we can move the elements
      canExecute = canMove(validatedShapes, delta, position, hover);

      context.delta = delta;
      context.canExecute = canExecute;

      // simply ignore move over
      if (canExecute === null) {
        context.target = null;

        return;
      }

      context.target = hover;
    });

    eventBus.on('shape.move.end', function (event) {

      var context = event.context;

      var delta = context.delta,
          canExecute = context.canExecute,
          isAttach = canExecute === 'attach',
          shapes = context.shapes;

      if (!canExecute) {
        return false;
      }

      // ensure we have actual pixel values deltas
      // (important when zoom level was > 1 during move)
      delta.x = round$2(delta.x);
      delta.y = round$2(delta.y);

      modeling.moveElements(shapes, delta, context.target, {
        primaryShape: context.shape,
        attach: isAttach
      });
    });

    // move activation

    eventBus.on('element.mousedown', function (event) {

      var originalEvent = getOriginal(event);

      if (!originalEvent) {
        throw new Error('must supply DOM mousedown event');
      }

      return start(originalEvent, event.element);
    });

    function start(event, element, activate) {

      // do not move connections or the root element
      if (element.waypoints || !element.parent) {
        return;
      }

      var referencePoint = mid(element);

      dragging.init(event, referencePoint, 'shape.move', {
        cursor: 'grabbing',
        autoActivate: activate,
        data: {
          shape: element,
          context: {}
        }
      });

      // we've handled the event
      return true;
    }

    // API

    this.start = start;
  }

  MoveEvents.$inject = ['eventBus', 'dragging', 'modeling', 'selection', 'rules'];

  /**
   * Return a filtered list of elements that do not contain
   * those nested into others.
   *
   * @param  {Array<djs.model.Base>} elements
   *
   * @return {Array<djs.model.Base>} filtered
   */
  function removeNested(elements) {

    var ids = groupBy(elements, 'id');

    return filter(elements, function (element) {
      while (element = element.parent) {

        // parent in selection
        if (ids[element.id]) {
          return false;
        }
      }

      return true;
    });
  }

  var LOW_PRIORITY$4 = 499;

  var MARKER_DRAGGING = 'djs-dragging',
      MARKER_OK = 'drop-ok',
      MARKER_NOT_OK = 'drop-not-ok',
      MARKER_NEW_PARENT = 'new-parent',
      MARKER_ATTACH = 'attach-ok';

  /**
   * Provides previews for moving shapes when moving.
   *
   * @param {EventBus} eventBus
   * @param {ElementRegistry} elementRegistry
   * @param {Canvas} canvas
   * @param {Styles} styles
   */
  function MovePreview(eventBus, elementRegistry, canvas, styles, previewSupport) {

    function getVisualDragShapes(shapes) {
      var elements = getAllDraggedElements(shapes);

      var filteredElements = removeEdges(elements);

      return filteredElements;
    }

    function getAllDraggedElements(shapes) {
      var allShapes = selfAndAllChildren(shapes, true);

      var allConnections = map(allShapes, function (shape) {
        return (shape.incoming || []).concat(shape.outgoing || []);
      });

      return flatten(allShapes.concat(allConnections));
    }

    /**
     * Sets drop marker on an element.
     */
    function setMarker(element, marker) {

      [MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT].forEach(function (m) {

        if (m === marker) {
          canvas.addMarker(element, m);
        } else {
          canvas.removeMarker(element, m);
        }
      });
    }

    /**
     * Make an element draggable.
     *
     * @param {Object} context
     * @param {djs.model.Base} element
     * @param {Boolean} addMarker
     */
    function makeDraggable(context, element, addMarker) {

      previewSupport.addDragger(element, context.dragGroup);

      if (addMarker) {
        canvas.addMarker(element, MARKER_DRAGGING);
      }

      if (context.allDraggedElements) {
        context.allDraggedElements.push(element);
      } else {
        context.allDraggedElements = [element];
      }
    }

    // assign a low priority to this handler
    // to let others modify the move context before
    // we draw things
    eventBus.on('shape.move.start', LOW_PRIORITY$4, function (event) {

      var context = event.context,
          dragShapes = context.shapes,
          allDraggedElements = context.allDraggedElements;

      var visuallyDraggedShapes = getVisualDragShapes(dragShapes);

      if (!context.dragGroup) {
        var dragGroup = create('g');
        attr$1(dragGroup, styles.cls('djs-drag-group', ['no-events']));

        var defaultLayer = canvas.getDefaultLayer();

        append(defaultLayer, dragGroup);

        context.dragGroup = dragGroup;
      }

      // add previews
      visuallyDraggedShapes.forEach(function (shape) {
        previewSupport.addDragger(shape, context.dragGroup);
      });

      // cache all dragged elements / gfx
      // so that we can quickly undo their state changes later
      if (!allDraggedElements) {
        allDraggedElements = getAllDraggedElements(dragShapes);
      } else {
        allDraggedElements = flatten([allDraggedElements, getAllDraggedElements(dragShapes)]);
      }

      // add dragging marker
      forEach(allDraggedElements, function (e) {
        canvas.addMarker(e, MARKER_DRAGGING);
      });

      context.allDraggedElements = allDraggedElements;

      // determine, if any of the dragged elements have different parents
      context.differentParents = haveDifferentParents(dragShapes);
    });

    // update previews
    eventBus.on('shape.move.move', LOW_PRIORITY$4, function (event) {

      var context = event.context,
          dragGroup = context.dragGroup,
          target = context.target,
          parent = context.shape.parent,
          canExecute = context.canExecute;

      if (target) {
        if (canExecute === 'attach') {
          setMarker(target, MARKER_ATTACH);
        } else if (context.canExecute && target && target.id !== parent.id) {
          setMarker(target, MARKER_NEW_PARENT);
        } else {
          setMarker(target, context.canExecute ? MARKER_OK : MARKER_NOT_OK);
        }
      }

      translate(dragGroup, event.dx, event.dy);
    });

    eventBus.on(['shape.move.out', 'shape.move.cleanup'], function (event) {
      var context = event.context,
          target = context.target;

      if (target) {
        setMarker(target, null);
      }
    });

    // remove previews
    eventBus.on('shape.move.cleanup', function (event) {

      var context = event.context,
          allDraggedElements = context.allDraggedElements,
          dragGroup = context.dragGroup;

      // remove dragging marker
      forEach(allDraggedElements, function (e) {
        canvas.removeMarker(e, MARKER_DRAGGING);
      });

      if (dragGroup) {
        clear$1(dragGroup);
      }
    });

    // API //////////////////////

    /**
     * Make an element draggable.
     *
     * @param {Object} context
     * @param {djs.model.Base} element
     * @param {Boolean} addMarker
     */
    this.makeDraggable = makeDraggable;
  }

  MovePreview.$inject = ['eventBus', 'elementRegistry', 'canvas', 'styles', 'previewSupport'];

  // helpers //////////////////////

  /**
   * returns elements minus all connections
   * where source or target is not elements
   */
  function removeEdges(elements) {

    var filteredElements = filter(elements, function (element) {

      if (!isConnection$1(element)) {
        return true;
      } else {

        return find(elements, matchPattern({ id: element.source.id })) && find(elements, matchPattern({ id: element.target.id }));
      }
    });

    return filteredElements;
  }

  function haveDifferentParents(elements) {
    return size(groupBy(elements, function (e) {
      return e.parent && e.parent.id;
    })) !== 1;
  }

  /**
   * Checks if an element is a connection.
   */
  function isConnection$1(element) {
    return element.waypoints;
  }

  var MoveModule = {
    __depends__: [InteractionEventsModule, DiagramSelection, OutlineModule, Rules$1, DraggingModule, PreviewSupportModule],
    __init__: ['move', 'movePreview'],
    move: ['type', MoveEvents],
    movePreview: ['type', MovePreview]
  };

  /**
   * Computes the distance between two points
   *
   * @param  {Point}  p
   * @param  {Point}  q
   *
   * @return {Number}  distance
   */
  function pointDistance(a, b) {
    if (!a || !b) {
      return -1;
    }

    return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
  }

  /**
   * Returns true if the point r is on the line between p and q
   *
   * @param  {Point}  p
   * @param  {Point}  q
   * @param  {Point}  r
   * @param  {Number} [accuracy=5] accuracy for points on line check (lower is better)
   *
   * @return {Boolean}
   */
  function pointsOnLine(p, q, r, accuracy) {

    if (typeof accuracy === 'undefined') {
      accuracy = 5;
    }

    if (!p || !q || !r) {
      return false;
    }

    var val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x),
        dist = pointDistance(p, q);

    // @see http://stackoverflow.com/a/907491/412190
    return Math.abs(val / dist) <= accuracy;
  }

  var ALIGNED_THRESHOLD = 2;

  /**
   * Returns whether two points are in a horizontal or vertical line.
   *
   * @param {Point} a
   * @param {Point} b
   *
   * @return {String|Boolean} returns false if the points are not
   *                          aligned or 'h|v' if they are aligned
   *                          horizontally / vertically.
   */
  function pointsAligned(a, b) {
    if (Math.abs(a.x - b.x) <= ALIGNED_THRESHOLD) {
      return 'h';
    }

    if (Math.abs(a.y - b.y) <= ALIGNED_THRESHOLD) {
      return 'v';
    }

    return false;
  }

  /**
   * Returns a point in the middle of points p and q
   *
   * @param  {Point}  p
   * @param  {Point}  q
   *
   * @return {Point} middle point
   */
  function getMidPoint(p, q) {
    return {
      x: Math.round(p.x + (q.x - p.x) / 2.0),
      y: Math.round(p.y + (q.y - p.y) / 2.0)
    };
  }

  var BENDPOINT_CLS = 'djs-bendpoint';
  var SEGMENT_DRAGGER_CLS = 'djs-segment-dragger';

  function toCanvasCoordinates(canvas, event) {

    var position = toPoint(event),
        clientRect = canvas._container.getBoundingClientRect(),
        offset;

    // canvas relative position

    offset = {
      x: clientRect.left,
      y: clientRect.top
    };

    // update actual event payload with canvas relative measures

    var viewbox = canvas.viewbox();

    return {
      x: viewbox.x + (position.x - offset.x) / viewbox.scale,
      y: viewbox.y + (position.y - offset.y) / viewbox.scale
    };
  }

  function addBendpoint(parentGfx, cls) {
    var groupGfx = create('g');
    classes$1(groupGfx).add(BENDPOINT_CLS);

    append(parentGfx, groupGfx);

    var visual = create('circle');
    attr$1(visual, {
      cx: 0,
      cy: 0,
      r: 4
    });
    classes$1(visual).add('djs-visual');

    append(groupGfx, visual);

    var hit = create('circle');
    attr$1(hit, {
      cx: 0,
      cy: 0,
      r: 10
    });
    classes$1(hit).add('djs-hit');

    append(groupGfx, hit);

    if (cls) {
      classes$1(groupGfx).add(cls);
    }

    return groupGfx;
  }

  function createParallelDragger(parentGfx, position, alignment) {
    var draggerGfx = create('g');

    append(parentGfx, draggerGfx);

    var width = 14,
        height = 3,
        padding = 6,
        hitWidth = width + padding,
        hitHeight = height + padding;

    var visual = create('rect');
    attr$1(visual, {
      x: -width / 2,
      y: -height / 2,
      width: width,
      height: height
    });
    classes$1(visual).add('djs-visual');

    append(draggerGfx, visual);

    var hit = create('rect');
    attr$1(hit, {
      x: -hitWidth / 2,
      y: -hitHeight / 2,
      width: hitWidth,
      height: hitHeight
    });
    classes$1(hit).add('djs-hit');

    append(draggerGfx, hit);

    rotate(draggerGfx, alignment === 'h' ? 90 : 0, 0, 0);

    return draggerGfx;
  }

  function addSegmentDragger(parentGfx, segmentStart, segmentEnd) {

    var groupGfx = create('g'),
        mid = getMidPoint(segmentStart, segmentEnd),
        alignment = pointsAligned(segmentStart, segmentEnd);

    append(parentGfx, groupGfx);

    createParallelDragger(groupGfx, mid, alignment);

    classes$1(groupGfx).add(SEGMENT_DRAGGER_CLS);
    classes$1(groupGfx).add(alignment === 'h' ? 'vertical' : 'horizontal');

    translate(groupGfx, mid.x, mid.y);

    return groupGfx;
  }

  var css_escape = createCommonjsModule(function (module, exports) {
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
  (function (root, factory) {
  	// https://github.com/umdjs/umd/blob/master/returnExports.js
  	if ((_typeof(exports)) == 'object') {
  		// For Node.js.
  		module.exports = factory(root);
  	} else if (typeof undefined == 'function' && undefined.amd) {
  		// For AMD. Register as an anonymous module.
  		undefined([], factory.bind(root, root));
  	} else {
  		// For browser globals (not exposing the function separately).
  		factory(root);
  	}
  })(typeof commonjsGlobal != 'undefined' ? commonjsGlobal : commonjsGlobal, function (root) {

  	if (root.CSS && root.CSS.escape) {
  		return root.CSS.escape;
  	}

  	// https://drafts.csswg.org/cssom/#serialize-an-identifier
  	var cssEscape = function cssEscape(value) {
  		if (arguments.length == 0) {
  			throw new TypeError('`CSS.escape` requires an argument.');
  		}
  		var string = String(value);
  		var length = string.length;
  		var index = -1;
  		var codeUnit;
  		var result = '';
  		var firstCodeUnit = string.charCodeAt(0);
  		while (++index < length) {
  			codeUnit = string.charCodeAt(index);
  			// Note: there’s no need to special-case astral symbols, surrogate
  			// pairs, or lone surrogates.

  			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
  			// (U+FFFD).
  			if (codeUnit == 0x0000) {
  				result += '\uFFFD';
  				continue;
  			}

  			if (
  			// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
  			// U+007F, […]
  			codeUnit >= 0x0001 && codeUnit <= 0x001F || codeUnit == 0x007F ||
  			// If the character is the first character and is in the range [0-9]
  			// (U+0030 to U+0039), […]
  			index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
  			// If the character is the second character and is in the range [0-9]
  			// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
  			index == 1 && codeUnit >= 0x0030 && codeUnit <= 0x0039 && firstCodeUnit == 0x002D) {
  				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
  				result += '\\' + codeUnit.toString(16) + ' ';
  				continue;
  			}

  			if (
  			// If the character is the first character and is a `-` (U+002D), and
  			// there is no second character, […]
  			index == 0 && length == 1 && codeUnit == 0x002D) {
  				result += '\\' + string.charAt(index);
  				continue;
  			}

  			// If the character is not handled by one of the above rules and is
  			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
  			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
  			// U+005A), or [a-z] (U+0061 to U+007A), […]
  			if (codeUnit >= 0x0080 || codeUnit == 0x002D || codeUnit == 0x005F || codeUnit >= 0x0030 && codeUnit <= 0x0039 || codeUnit >= 0x0041 && codeUnit <= 0x005A || codeUnit >= 0x0061 && codeUnit <= 0x007A) {
  				// the character itself
  				result += string.charAt(index);
  				continue;
  			}

  			// Otherwise, the escaped character.
  			// https://drafts.csswg.org/cssom/#escape-a-character
  			result += '\\' + string.charAt(index);
  		}
  		return result;
  	};

  	if (!root.CSS) {
  		root.CSS = {};
  	}

  	root.CSS.escape = cssEscape;
  	return cssEscape;
  });
  });

  /**
   * This file contains portions that got extraced from Snap.svg (licensed Apache-2.0).
   *
   * @see https://github.com/adobe-webplatform/Snap.svg/blob/master/src/path.js
   */

  /* eslint no-fallthrough: "off" */

  var _typeof$6 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var has$2 = 'hasOwnProperty',
      p2s = /,?([a-z]),?/gi,
      toFloat = parseFloat,
      math = Math,
      PI = math.PI,
      mmin = math.min,
      mmax = math.max,
      pow = math.pow,
      abs = math.abs,
      pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?[\s]*,?[\s]*)+)/ig,
      pathValues = /(-?\d*\.?\d*(?:e[-+]?\\d+)?)[\s]*,?[\s]*/ig;

  function is$1(o, type) {
    type = String.prototype.toLowerCase.call(type);

    if (type == 'finite') {
      return isFinite(o);
    }

    if (type == 'array' && (o instanceof Array || Array.isArray && Array.isArray(o))) {
      return true;
    }

    return type == 'null' && o === null || type == (typeof o === 'undefined' ? 'undefined' : _typeof$6(o)) && o !== null || type == 'object' && o === Object(o) || Object.prototype.toString.call(o).slice(8, -1).toLowerCase() == type;
  }

  function clone$1(obj) {

    if (typeof obj == 'function' || Object(obj) !== obj) {
      return obj;
    }

    var res = new obj.constructor();

    for (var key in obj) {
      if (obj[has$2](key)) {
        res[key] = clone$1(obj[key]);
      }
    }return res;
  }

  function repush(array, item) {
    for (var i = 0, ii = array.length; i < ii; i++) {
      if (array[i] === item) {
        return array.push(array.splice(i, 1)[0]);
      }
    }
  }

  function cacher(f, scope, postprocessor) {

    function newf() {

      var arg = Array.prototype.slice.call(arguments, 0),
          args = arg.join('\u2400'),
          cache = newf.cache = newf.cache || {},
          count = newf.count = newf.count || [];

      if (cache[has$2](args)) {
        repush(count, args);
        return postprocessor ? postprocessor(cache[args]) : cache[args];
      }

      count.length >= 1e3 && delete cache[count.shift()];
      count.push(args);
      cache[args] = f.apply(scope, arg);

      return postprocessor ? postprocessor(cache[args]) : cache[args];
    }
    return newf;
  }

  function parsePathString(pathString) {

    if (!pathString) {
      return null;
    }

    var pth = paths(pathString);

    if (pth.arr) {
      return clone$1(pth.arr);
    }

    var paramCounts = { a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0 },
        data = [];

    if (is$1(pathString, 'array') && is$1(pathString[0], 'array')) {
      // rough assumption
      data = clone$1(pathString);
    }

    if (!data.length) {

      String(pathString).replace(pathCommand, function (a, b, c) {
        var params = [],
            name = b.toLowerCase();

        c.replace(pathValues, function (a, b) {
          b && params.push(+b);
        });

        if (name == 'm' && params.length > 2) {
          data.push([b].concat(params.splice(0, 2)));
          name = 'l';
          b = b == 'm' ? 'l' : 'L';
        }

        if (name == 'o' && params.length == 1) {
          data.push([b, params[0]]);
        }

        if (name == 'r') {
          data.push([b].concat(params));
        } else while (params.length >= paramCounts[name]) {
          data.push([b].concat(params.splice(0, paramCounts[name])));
          if (!paramCounts[name]) {
            break;
          }
        }
      });
    }

    data.toString = paths.toString;
    pth.arr = clone$1(data);

    return data;
  }

  function paths(ps) {
    var p = paths.ps = paths.ps || {};

    if (p[ps]) {
      p[ps].sleep = 100;
    } else {
      p[ps] = {
        sleep: 100
      };
    }

    setTimeout(function () {
      for (var key in p) {
        if (p[has$2](key) && key != ps) {
          p[key].sleep--;
          !p[key].sleep && delete p[key];
        }
      }
    });

    return p[ps];
  }

  function box(x, y, width, height) {
    if (x == null) {
      x = y = width = height = 0;
    }

    if (y == null) {
      y = x.y;
      width = x.width;
      height = x.height;
      x = x.x;
    }

    return {
      x: x,
      y: y,
      width: width,
      w: width,
      height: height,
      h: height,
      x2: x + width,
      y2: y + height,
      cx: x + width / 2,
      cy: y + height / 2,
      r1: math.min(width, height) / 2,
      r2: math.max(width, height) / 2,
      r0: math.sqrt(width * width + height * height) / 2,
      path: rectPath(x, y, width, height),
      vb: [x, y, width, height].join(' ')
    };
  }

  function pathToString() {
    return this.join(',').replace(p2s, '$1');
  }

  function pathClone(pathArray) {
    var res = clone$1(pathArray);
    res.toString = pathToString;
    return res;
  }

  function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t,
        t13 = pow(t1, 3),
        t12 = pow(t1, 2),
        t2 = t * t,
        t3 = t2 * t,
        x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
        y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
        mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
        my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
        nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
        ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
        ax = t1 * p1x + t * c1x,
        ay = t1 * p1y + t * c1y,
        cx = t1 * c2x + t * p2x,
        cy = t1 * c2y + t * p2y,
        alpha = 90 - math.atan2(mx - nx, my - ny) * 180 / PI;

    return {
      x: x,
      y: y,
      m: { x: mx, y: my },
      n: { x: nx, y: ny },
      start: { x: ax, y: ay },
      end: { x: cx, y: cy },
      alpha: alpha
    };
  }

  function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {

    if (!is$1(p1x, 'array')) {
      p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
    }

    var bbox = curveBBox.apply(null, p1x);

    return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
  }

  function isPointInsideBBox(bbox, x, y) {
    return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
  }

  function isBBoxIntersect(bbox1, bbox2) {
    bbox1 = box(bbox1);
    bbox2 = box(bbox2);
    return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
  }

  function base3(t, p1, p2, p3, p4) {
    var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
        t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
    return t * t2 - 3 * p1 + 3 * p2;
  }

  function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {

    if (z == null) {
      z = 1;
    }

    z = z > 1 ? 1 : z < 0 ? 0 : z;

    var z2 = z / 2,
        n = 12,
        Tvalues = [-.1252, .1252, -.3678, .3678, -.5873, .5873, -.7699, .7699, -.9041, .9041, -.9816, .9816],
        Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],
        sum = 0;

    for (var i = 0; i < n; i++) {
      var ct = z2 * Tvalues[i] + z2,
          xbase = base3(ct, x1, x2, x3, x4),
          ybase = base3(ct, y1, y2, y3, y4),
          comb = xbase * xbase + ybase * ybase;

      sum += Cvalues[i] * math.sqrt(comb);
    }

    return z2 * sum;
  }

  function intersectLines(x1, y1, x2, y2, x3, y3, x4, y4) {

    if (mmax(x1, x2) < mmin(x3, x4) || mmin(x1, x2) > mmax(x3, x4) || mmax(y1, y2) < mmin(y3, y4) || mmin(y1, y2) > mmax(y3, y4)) {
      return;
    }

    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
        ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
        denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

    if (!denominator) {
      return;
    }

    var px = nx / denominator,
        py = ny / denominator,
        px2 = +px.toFixed(2),
        py2 = +py.toFixed(2);

    if (px2 < +mmin(x1, x2).toFixed(2) || px2 > +mmax(x1, x2).toFixed(2) || px2 < +mmin(x3, x4).toFixed(2) || px2 > +mmax(x3, x4).toFixed(2) || py2 < +mmin(y1, y2).toFixed(2) || py2 > +mmax(y1, y2).toFixed(2) || py2 < +mmin(y3, y4).toFixed(2) || py2 > +mmax(y3, y4).toFixed(2)) {
      return;
    }

    return { x: px, y: py };
  }

  function findBezierIntersections(bez1, bez2, justCount) {
    var bbox1 = bezierBBox(bez1),
        bbox2 = bezierBBox(bez2);

    if (!isBBoxIntersect(bbox1, bbox2)) {
      return justCount ? 0 : [];
    }

    var l1 = bezlen.apply(0, bez1),
        l2 = bezlen.apply(0, bez2),
        n1 = ~~(l1 / 5),
        n2 = ~~(l2 / 5),
        dots1 = [],
        dots2 = [],
        xy = {},
        res = justCount ? 0 : [];

    for (var i = 0; i < n1 + 1; i++) {
      var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
      dots1.push({ x: p.x, y: p.y, t: i / n1 });
    }

    for (i = 0; i < n2 + 1; i++) {
      p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
      dots2.push({ x: p.x, y: p.y, t: i / n2 });
    }

    for (i = 0; i < n1; i++) {

      for (var j = 0; j < n2; j++) {
        var di = dots1[i],
            di1 = dots1[i + 1],
            dj = dots2[j],
            dj1 = dots2[j + 1],
            ci = abs(di1.x - di.x) < .01 ? 'y' : 'x',
            cj = abs(dj1.x - dj.x) < .01 ? 'y' : 'x',
            is = intersectLines(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);

        if (is) {

          if (xy[is.x.toFixed(0)] == is.y.toFixed(0)) {
            continue;
          }

          xy[is.x.toFixed(0)] = is.y.toFixed(0);

          var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
              t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);

          if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {

            if (justCount) {
              res++;
            } else {
              res.push({
                x: is.x,
                y: is.y,
                t1: t1,
                t2: t2
              });
            }
          }
        }
      }
    }

    return res;
  }

  /**
   * Find or counts the intersections between two SVG paths.
   *
   * Returns a number in counting mode and a list of intersections otherwise.
   *
   * A single intersection entry contains the intersection coordinates (x, y)
   * as well as additional information regarding the intersecting segments
   * on each path (segment1, segment2) and the relative location of the
   * intersection on these segments (t1, t2).
   *
   * The path may be an SVG path string or a list of path components
   * such as `[ [ 'M', 0, 10 ], [ 'L', 20, 0 ] ]`.
   *
   * @example
   *
   * var intersections = findPathIntersections(
   *   'M0,0L100,100',
   *   [ [ 'M', 0, 100 ], [ 'L', 100, 0 ] ]
   * );
   *
   * // intersections = [
   * //   { x: 50, y: 50, segment1: 1, segment2: 1, t1: 0.5, t2: 0.5 }
   * //
   *
   * @param {String|Array<PathDef>} path1
   * @param {String|Array<PathDef>} path2
   * @param {Boolean} [justCount=false]
   *
   * @return {Array<Intersection>|Number}
   */
  function findPathIntersections(path1, path2, justCount) {
    path1 = pathToCurve(path1);
    path2 = pathToCurve(path2);

    var x1,
        y1,
        x2,
        y2,
        x1m,
        y1m,
        x2m,
        y2m,
        bez1,
        bez2,
        res = justCount ? 0 : [];

    for (var i = 0, ii = path1.length; i < ii; i++) {
      var pi = path1[i];

      if (pi[0] == 'M') {
        x1 = x1m = pi[1];
        y1 = y1m = pi[2];
      } else {

        if (pi[0] == 'C') {
          bez1 = [x1, y1].concat(pi.slice(1));
          x1 = bez1[6];
          y1 = bez1[7];
        } else {
          bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
          x1 = x1m;
          y1 = y1m;
        }

        for (var j = 0, jj = path2.length; j < jj; j++) {
          var pj = path2[j];

          if (pj[0] == 'M') {
            x2 = x2m = pj[1];
            y2 = y2m = pj[2];
          } else {

            if (pj[0] == 'C') {
              bez2 = [x2, y2].concat(pj.slice(1));
              x2 = bez2[6];
              y2 = bez2[7];
            } else {
              bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
              x2 = x2m;
              y2 = y2m;
            }

            var intr = findBezierIntersections(bez1, bez2, justCount);

            if (justCount) {
              res += intr;
            } else {

              for (var k = 0, kk = intr.length; k < kk; k++) {
                intr[k].segment1 = i;
                intr[k].segment2 = j;
                intr[k].bez1 = bez1;
                intr[k].bez2 = bez2;
              }

              res = res.concat(intr);
            }
          }
        }
      }
    }

    return res;
  }

  function rectPath(x, y, w, h, r) {
    if (r) {
      return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];
    }

    var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];
    res.toString = pathToString;

    return res;
  }

  function ellipsePath(x, y, rx, ry, a) {
    if (a == null && ry == null) {
      ry = rx;
    }

    x = +x;
    y = +y;
    rx = +rx;
    ry = +ry;

    if (a != null) {
      var rad = Math.PI / 180,
          x1 = x + rx * Math.cos(-ry * rad),
          x2 = x + rx * Math.cos(-a * rad),
          y1 = y + rx * Math.sin(-ry * rad),
          y2 = y + rx * Math.sin(-a * rad),
          res = [['M', x1, y1], ['A', rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
    } else {
      res = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];
    }

    res.toString = pathToString;

    return res;
  }

  function pathToAbsolute(pathArray) {
    var pth = paths(pathArray);

    if (pth.abs) {
      return pathClone(pth.abs);
    }

    if (!is$1(pathArray, 'array') || !is$1(pathArray && pathArray[0], 'array')) {
      // rough assumption
      pathArray = parsePathString(pathArray);
    }

    if (!pathArray || !pathArray.length) {
      return [['M', 0, 0]];
    }

    var res = [],
        x = 0,
        y = 0,
        mx = 0,
        my = 0,
        start = 0,
        pa0;

    if (pathArray[0][0] == 'M') {
      x = +pathArray[0][1];
      y = +pathArray[0][2];
      mx = x;
      my = y;
      start++;
      res[0] = ['M', x, y];
    }

    var crz = pathArray.length == 3 && pathArray[0][0] == 'M' && pathArray[1][0].toUpperCase() == 'R' && pathArray[2][0].toUpperCase() == 'Z';

    for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
      res.push(r = []);
      pa = pathArray[i];
      pa0 = pa[0];

      if (pa0 != pa0.toUpperCase()) {
        r[0] = pa0.toUpperCase();

        switch (r[0]) {
          case 'A':
            r[1] = pa[1];
            r[2] = pa[2];
            r[3] = pa[3];
            r[4] = pa[4];
            r[5] = pa[5];
            r[6] = +pa[6] + x;
            r[7] = +pa[7] + y;
            break;
          case 'V':
            r[1] = +pa[1] + y;
            break;
          case 'H':
            r[1] = +pa[1] + x;
            break;
          case 'R':
            var dots = [x, y].concat(pa.slice(1));

            for (var j = 2, jj = dots.length; j < jj; j++) {
              dots[j] = +dots[j] + x;
              dots[++j] = +dots[j] + y;
            }

            res.pop();
            res = res.concat(catmulRomToBezier(dots, crz));
            break;
          case 'O':
            res.pop();
            dots = ellipsePath(x, y, pa[1], pa[2]);
            dots.push(dots[0]);
            res = res.concat(dots);
            break;
          case 'U':
            res.pop();
            res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
            r = ['U'].concat(res[res.length - 1].slice(-2));
            break;
          case 'M':
            mx = +pa[1] + x;
            my = +pa[2] + y;
          default:

            for (j = 1, jj = pa.length; j < jj; j++) {
              r[j] = +pa[j] + (j % 2 ? x : y);
            }
        }
      } else if (pa0 == 'R') {
        dots = [x, y].concat(pa.slice(1));
        res.pop();
        res = res.concat(catmulRomToBezier(dots, crz));
        r = ['R'].concat(pa.slice(-2));
      } else if (pa0 == 'O') {
        res.pop();
        dots = ellipsePath(x, y, pa[1], pa[2]);
        dots.push(dots[0]);
        res = res.concat(dots);
      } else if (pa0 == 'U') {
        res.pop();
        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
        r = ['U'].concat(res[res.length - 1].slice(-2));
      } else {

        for (var k = 0, kk = pa.length; k < kk; k++) {
          r[k] = pa[k];
        }
      }
      pa0 = pa0.toUpperCase();

      if (pa0 != 'O') {
        switch (r[0]) {
          case 'Z':
            x = +mx;
            y = +my;
            break;
          case 'H':
            x = r[1];
            break;
          case 'V':
            y = r[1];
            break;
          case 'M':
            mx = r[r.length - 2];
            my = r[r.length - 1];
          default:
            x = r[r.length - 2];
            y = r[r.length - 1];
        }
      }
    }

    res.toString = pathToString;
    pth.abs = pathClone(res);

    return res;
  }

  function lineToCurve(x1, y1, x2, y2) {
    return [x1, y1, x2, y2, x2, y2];
  }

  function qubicToCurve(x1, y1, ax, ay, x2, y2) {
    var _13 = 1 / 3,
        _23 = 2 / 3;

    return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
  }

  function arcToCurve(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {

    // for more information of where this math came from visit:
    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
    var _120 = PI * 120 / 180,
        rad = PI / 180 * (+angle || 0),
        res = [],
        xy,
        rotate = cacher(function (x, y, rad) {
      var X = x * math.cos(rad) - y * math.sin(rad),
          Y = x * math.sin(rad) + y * math.cos(rad);

      return { x: X, y: Y };
    });

    if (!recursive) {
      xy = rotate(x1, y1, -rad);
      x1 = xy.x;
      y1 = xy.y;
      xy = rotate(x2, y2, -rad);
      x2 = xy.x;
      y2 = xy.y;

      var x = (x1 - x2) / 2,
          y = (y1 - y2) / 2;

      var h = x * x / (rx * rx) + y * y / (ry * ry);

      if (h > 1) {
        h = math.sqrt(h);
        rx = h * rx;
        ry = h * ry;
      }

      var rx2 = rx * rx,
          ry2 = ry * ry,
          k = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
          cx = k * rx * y / ry + (x1 + x2) / 2,
          cy = k * -ry * x / rx + (y1 + y2) / 2,
          f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
          f2 = math.asin(((y2 - cy) / ry).toFixed(9));

      f1 = x1 < cx ? PI - f1 : f1;
      f2 = x2 < cx ? PI - f2 : f2;
      f1 < 0 && (f1 = PI * 2 + f1);
      f2 < 0 && (f2 = PI * 2 + f2);

      if (sweep_flag && f1 > f2) {
        f1 = f1 - PI * 2;
      }
      if (!sweep_flag && f2 > f1) {
        f2 = f2 - PI * 2;
      }
    } else {
      f1 = recursive[0];
      f2 = recursive[1];
      cx = recursive[2];
      cy = recursive[3];
    }

    var df = f2 - f1;

    if (abs(df) > _120) {
      var f2old = f2,
          x2old = x2,
          y2old = y2;

      f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
      x2 = cx + rx * math.cos(f2);
      y2 = cy + ry * math.sin(f2);
      res = arcToCurve(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
    }

    df = f2 - f1;

    var c1 = math.cos(f1),
        s1 = math.sin(f1),
        c2 = math.cos(f2),
        s2 = math.sin(f2),
        t = math.tan(df / 4),
        hx = 4 / 3 * rx * t,
        hy = 4 / 3 * ry * t,
        m1 = [x1, y1],
        m2 = [x1 + hx * s1, y1 - hy * c1],
        m3 = [x2 + hx * s2, y2 - hy * c2],
        m4 = [x2, y2];

    m2[0] = 2 * m1[0] - m2[0];
    m2[1] = 2 * m1[1] - m2[1];

    if (recursive) {
      return [m2, m3, m4].concat(res);
    } else {
      res = [m2, m3, m4].concat(res).join().split(',');
      var newres = [];

      for (var i = 0, ii = res.length; i < ii; i++) {
        newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
      }

      return newres;
    }
  }

  // http://schepers.cc/getting-to-the-point
  function catmulRomToBezier(crp, z) {
    var d = [];

    for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
      var p = [{ x: +crp[i - 2], y: +crp[i - 1] }, { x: +crp[i], y: +crp[i + 1] }, { x: +crp[i + 2], y: +crp[i + 3] }, { x: +crp[i + 4], y: +crp[i + 5] }];

      if (z) {

        if (!i) {
          p[0] = { x: +crp[iLen - 2], y: +crp[iLen - 1] };
        } else if (iLen - 4 == i) {
          p[3] = { x: +crp[0], y: +crp[1] };
        } else if (iLen - 2 == i) {
          p[2] = { x: +crp[0], y: +crp[1] };
          p[3] = { x: +crp[2], y: +crp[3] };
        }
      } else {

        if (iLen - 4 == i) {
          p[3] = p[2];
        } else if (!i) {
          p[0] = { x: +crp[i], y: +crp[i + 1] };
        }
      }

      d.push(['C', (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);
    }

    return d;
  }

  // Returns bounding box of cubic bezier curve.
  // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
  // Original version: NISHIO Hirokazu
  // Modifications: https://github.com/timo22345
  function curveBBox(x0, y0, x1, y1, x2, y2, x3, y3) {
    var tvalues = [],
        bounds = [[], []],
        a,
        b,
        c,
        t,
        t1,
        t2,
        b2ac,
        sqrtb2ac;

    for (var i = 0; i < 2; ++i) {

      if (i == 0) {
        b = 6 * x0 - 12 * x1 + 6 * x2;
        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
        c = 3 * x1 - 3 * x0;
      } else {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }

      if (abs(a) < 1e-12) {

        if (abs(b) < 1e-12) {
          continue;
        }

        t = -c / b;

        if (0 < t && t < 1) {
          tvalues.push(t);
        }

        continue;
      }

      b2ac = b * b - 4 * c * a;
      sqrtb2ac = math.sqrt(b2ac);

      if (b2ac < 0) {
        continue;
      }

      t1 = (-b + sqrtb2ac) / (2 * a);

      if (0 < t1 && t1 < 1) {
        tvalues.push(t1);
      }

      t2 = (-b - sqrtb2ac) / (2 * a);

      if (0 < t2 && t2 < 1) {
        tvalues.push(t2);
      }
    }

    var j = tvalues.length,
        jlen = j,
        mt;

    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
    }

    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    bounds[0].length = bounds[1].length = jlen + 2;

    return {
      min: { x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1]) },
      max: { x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1]) }
    };
  }

  function pathToCurve(path, path2) {
    var pth = !path2 && paths(path);

    if (!path2 && pth.curve) {
      return pathClone(pth.curve);
    }

    var p = pathToAbsolute(path),
        p2 = path2 && pathToAbsolute(path2),
        attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
        attrs2 = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
        processPath = function processPath(path, d, pcom) {
      var nx, ny;

      if (!path) {
        return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
      }

      !(path[0] in { T: 1, Q: 1 }) && (d.qx = d.qy = null);

      switch (path[0]) {
        case 'M':
          d.X = path[1];
          d.Y = path[2];
          break;
        case 'A':
          path = ['C'].concat(arcToCurve.apply(0, [d.x, d.y].concat(path.slice(1))));
          break;
        case 'S':
          if (pcom == 'C' || pcom == 'S') {
            // In 'S' case we have to take into account, if the previous command is C/S.
            nx = d.x * 2 - d.bx;
            // And reflect the previous
            ny = d.y * 2 - d.by;
            // command's control point relative to the current point.
          } else {
            // or some else or nothing
            nx = d.x;
            ny = d.y;
          }
          path = ['C', nx, ny].concat(path.slice(1));
          break;
        case 'T':
          if (pcom == 'Q' || pcom == 'T') {
            // In 'T' case we have to take into account, if the previous command is Q/T.
            d.qx = d.x * 2 - d.qx;
            // And make a reflection similar
            d.qy = d.y * 2 - d.qy;
            // to case 'S'.
          } else {
            // or something else or nothing
            d.qx = d.x;
            d.qy = d.y;
          }
          path = ['C'].concat(qubicToCurve(d.x, d.y, d.qx, d.qy, path[1], path[2]));
          break;
        case 'Q':
          d.qx = path[1];
          d.qy = path[2];
          path = ['C'].concat(qubicToCurve(d.x, d.y, path[1], path[2], path[3], path[4]));
          break;
        case 'L':
          path = ['C'].concat(lineToCurve(d.x, d.y, path[1], path[2]));
          break;
        case 'H':
          path = ['C'].concat(lineToCurve(d.x, d.y, path[1], d.y));
          break;
        case 'V':
          path = ['C'].concat(lineToCurve(d.x, d.y, d.x, path[1]));
          break;
        case 'Z':
          path = ['C'].concat(lineToCurve(d.x, d.y, d.X, d.Y));
          break;
      }

      return path;
    },
        fixArc = function fixArc(pp, i) {

      if (pp[i].length > 7) {
        pp[i].shift();
        var pi = pp[i];

        while (pi.length) {
          pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved
          p2 && (pcoms2[i] = 'A'); // the same as above
          pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
        }

        pp.splice(i, 1);
        ii = mmax(p.length, p2 && p2.length || 0);
      }
    },
        fixM = function fixM(path1, path2, a1, a2, i) {

      if (path1 && path2 && path1[i][0] == 'M' && path2[i][0] != 'M') {
        path2.splice(i, 0, ['M', a2.x, a2.y]);
        a1.bx = 0;
        a1.by = 0;
        a1.x = path1[i][1];
        a1.y = path1[i][2];
        ii = mmax(p.length, p2 && p2.length || 0);
      }
    },
        pcoms1 = [],
        // path commands of original path p
    pcoms2 = [],
        // path commands of original path p2
    pfirst = '',
        // temporary holder for original path command
    pcom = ''; // holder for previous path command of original path

    for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
      p[i] && (pfirst = p[i][0]); // save current path command

      if (pfirst != 'C') // C is not saved yet, because it may be result of conversion
        {
          pcoms1[i] = pfirst; // Save current path command
          i && (pcom = pcoms1[i - 1]); // Get previous path command pcom
        }
      p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

      if (pcoms1[i] != 'A' && pfirst == 'C') pcoms1[i] = 'C'; // A is the only command
      // which may produce multiple C:s
      // so we have to make sure that C is also C in original path

      fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

      if (p2) {
        // the same procedures is done to p2
        p2[i] && (pfirst = p2[i][0]);

        if (pfirst != 'C') {
          pcoms2[i] = pfirst;
          i && (pcom = pcoms2[i - 1]);
        }

        p2[i] = processPath(p2[i], attrs2, pcom);

        if (pcoms2[i] != 'A' && pfirst == 'C') {
          pcoms2[i] = 'C';
        }

        fixArc(p2, i);
      }

      fixM(p, p2, attrs, attrs2, i);
      fixM(p2, p, attrs2, attrs, i);

      var seg = p[i],
          seg2 = p2 && p2[i],
          seglen = seg.length,
          seg2len = p2 && seg2.length;

      attrs.x = seg[seglen - 2];
      attrs.y = seg[seglen - 1];
      attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
      attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
      attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
      attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
      attrs2.x = p2 && seg2[seg2len - 2];
      attrs2.y = p2 && seg2[seg2len - 1];
    }

    if (!p2) {
      pth.curve = pathClone(p);
    }

    return p2 ? [p, p2] : p;
  }

  var intersect = findPathIntersections;

  var round$3 = Math.round,
      max = Math.max;

  function circlePath(center, r) {
    var x = center.x,
        y = center.y;

    return [['M', x, y], ['m', 0, -r], ['a', r, r, 0, 1, 1, 0, 2 * r], ['a', r, r, 0, 1, 1, 0, -2 * r], ['z']];
  }

  function linePath(points) {
    var segments = [];

    points.forEach(function (p, idx) {
      segments.push([idx === 0 ? 'M' : 'L', p.x, p.y]);
    });

    return segments;
  }

  var INTERSECTION_THRESHOLD = 10;

  function getBendpointIntersection(waypoints, reference) {

    var i, w;

    for (i = 0; w = waypoints[i]; i++) {

      if (pointDistance(w, reference) <= INTERSECTION_THRESHOLD) {
        return {
          point: waypoints[i],
          bendpoint: true,
          index: i
        };
      }
    }

    return null;
  }

  function getPathIntersection(waypoints, reference) {

    var intersections = intersect(circlePath(reference, INTERSECTION_THRESHOLD), linePath(waypoints));

    var a = intersections[0],
        b = intersections[intersections.length - 1],
        idx;

    if (!a) {
      // no intersection
      return null;
    }

    if (a !== b) {

      if (a.segment2 !== b.segment2) {
        // we use the bendpoint in between both segments
        // as the intersection point

        idx = max(a.segment2, b.segment2) - 1;

        return {
          point: waypoints[idx],
          bendpoint: true,
          index: idx
        };
      }

      return {
        point: {
          x: round$3(a.x + b.x) / 2,
          y: round$3(a.y + b.y) / 2
        },
        index: a.segment2
      };
    }

    return {
      point: {
        x: round$3(a.x),
        y: round$3(a.y)
      },
      index: a.segment2
    };
  }

  /**
   * Returns the closest point on the connection towards a given reference point.
   *
   * @param  {Array<Point>} waypoints
   * @param  {Point} reference
   *
   * @return {Object} intersection data (segment, point)
   */
  function getApproxIntersection(waypoints, reference) {
    return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);
  }

  /**
   * A service that adds editable bendpoints to connections.
   */
  function Bendpoints(eventBus, canvas, interactionEvents, bendpointMove, connectionSegmentMove) {

    function getConnectionIntersection(waypoints, event$$1) {
      var localPosition = toCanvasCoordinates(canvas, event$$1),
          intersection = getApproxIntersection(waypoints, localPosition);

      return intersection;
    }

    function isIntersectionMiddle(intersection, waypoints, treshold) {
      var idx = intersection.index,
          p = intersection.point,
          p0,
          p1,
          mid,
          aligned,
          xDelta,
          yDelta;

      if (idx <= 0 || intersection.bendpoint) {
        return false;
      }

      p0 = waypoints[idx - 1];
      p1 = waypoints[idx];
      mid = getMidPoint(p0, p1), aligned = pointsAligned(p0, p1);
      xDelta = Math.abs(p.x - mid.x);
      yDelta = Math.abs(p.y - mid.y);

      return aligned && xDelta <= treshold && yDelta <= treshold;
    }

    function activateBendpointMove(event$$1, connection) {
      var waypoints = connection.waypoints,
          intersection = getConnectionIntersection(waypoints, event$$1);

      if (!intersection) {
        return;
      }

      if (isIntersectionMiddle(intersection, waypoints, 10)) {
        connectionSegmentMove.start(event$$1, connection, intersection.index);
      } else {
        bendpointMove.start(event$$1, connection, intersection.index, !intersection.bendpoint);
      }

      // we've handled the event
      return true;
    }

    function bindInteractionEvents(node, eventName, element) {

      componentEvent.bind(node, eventName, function (event$$1) {
        interactionEvents.triggerMouseEvent(eventName, event$$1, element);
        event$$1.stopPropagation();
      });
    }

    function getBendpointsContainer(element, create$$1) {

      var layer = canvas.getLayer('overlays'),
          gfx = query('.djs-bendpoints[data-element-id="' + css_escape(element.id) + '"]', layer);

      if (!gfx && create$$1) {
        gfx = create('g');
        attr$1(gfx, { 'data-element-id': element.id });
        classes$1(gfx).add('djs-bendpoints');

        append(layer, gfx);

        bindInteractionEvents(gfx, 'mousedown', element);
        bindInteractionEvents(gfx, 'click', element);
        bindInteractionEvents(gfx, 'dblclick', element);
      }

      return gfx;
    }

    function createBendpoints(gfx, connection) {
      connection.waypoints.forEach(function (p, idx) {
        var bendpoint = addBendpoint(gfx);

        append(gfx, bendpoint);

        translate(bendpoint, p.x, p.y);
      });

      // add floating bendpoint
      addBendpoint(gfx, 'floating');
    }

    function createSegmentDraggers(gfx, connection) {

      var waypoints = connection.waypoints;

      var segmentStart, segmentEnd;

      for (var i = 1; i < waypoints.length; i++) {

        segmentStart = waypoints[i - 1];
        segmentEnd = waypoints[i];

        if (pointsAligned(segmentStart, segmentEnd)) {
          addSegmentDragger(gfx, segmentStart, segmentEnd);
        }
      }
    }

    function clearBendpoints(gfx) {
      forEach(all('.' + BENDPOINT_CLS, gfx), function (node) {
        remove$1(node);
      });
    }

    function clearSegmentDraggers(gfx) {
      forEach(all('.' + SEGMENT_DRAGGER_CLS, gfx), function (node) {
        remove$1(node);
      });
    }

    function addHandles(connection) {

      var gfx = getBendpointsContainer(connection);

      if (!gfx) {
        gfx = getBendpointsContainer(connection, true);

        createBendpoints(gfx, connection);
        createSegmentDraggers(gfx, connection);
      }

      return gfx;
    }

    function updateHandles(connection) {

      var gfx = getBendpointsContainer(connection);

      if (gfx) {
        clearSegmentDraggers(gfx);
        clearBendpoints(gfx);
        createSegmentDraggers(gfx, connection);
        createBendpoints(gfx, connection);
      }
    }

    eventBus.on('connection.changed', function (event$$1) {
      updateHandles(event$$1.element);
    });

    eventBus.on('connection.remove', function (event$$1) {
      var gfx = getBendpointsContainer(event$$1.element);

      if (gfx) {
        remove$1(gfx);
      }
    });

    eventBus.on('element.marker.update', function (event$$1) {

      var element = event$$1.element,
          bendpointsGfx;

      if (!element.waypoints) {
        return;
      }

      bendpointsGfx = addHandles(element);

      if (event$$1.add) {
        classes$1(bendpointsGfx).add(event$$1.marker);
      } else {
        classes$1(bendpointsGfx).remove(event$$1.marker);
      }
    });

    eventBus.on('element.mousemove', function (event$$1) {

      var element = event$$1.element,
          waypoints = element.waypoints,
          bendpointsGfx,
          floating,
          intersection;

      if (waypoints) {
        bendpointsGfx = getBendpointsContainer(element, true);
        floating = query('.floating', bendpointsGfx);

        if (!floating) {
          return;
        }

        intersection = getConnectionIntersection(waypoints, event$$1.originalEvent);

        if (intersection) {
          translate(floating, intersection.point.x, intersection.point.y);
        }
      }
    });

    eventBus.on('element.mousedown', function (event$$1) {

      var originalEvent = event$$1.originalEvent,
          element = event$$1.element,
          waypoints = element.waypoints;

      if (!waypoints) {
        return;
      }

      return activateBendpointMove(originalEvent, element, waypoints);
    });

    eventBus.on('selection.changed', function (event$$1) {
      var newSelection = event$$1.newSelection,
          primary = newSelection[0];

      if (primary && primary.waypoints) {
        addHandles(primary);
      }
    });

    eventBus.on('element.hover', function (event$$1) {
      var element = event$$1.element;

      if (element.waypoints) {
        addHandles(element);
        interactionEvents.registerEvent(event$$1.gfx, 'mousemove', 'element.mousemove');
      }
    });

    eventBus.on('element.out', function (event$$1) {
      interactionEvents.unregisterEvent(event$$1.gfx, 'mousemove', 'element.mousemove');
    });

    // update bendpoint container data attribute on element ID change
    eventBus.on('element.updateId', function (context) {
      var element = context.element,
          newId = context.newId;

      if (element.waypoints) {
        var bendpointContainer = getBendpointsContainer(element);

        if (bendpointContainer) {
          attr$1(bendpointContainer, { 'data-element-id': newId });
        }
      }
    });

    // API

    this.addHandles = addHandles;
    this.updateHandles = updateHandles;
    this.getBendpointsContainer = getBendpointsContainer;
  }

  Bendpoints.$inject = ['eventBus', 'canvas', 'interactionEvents', 'bendpointMove', 'connectionSegmentMove'];

  var MARKER_OK$1 = 'connect-ok',
      MARKER_NOT_OK$1 = 'connect-not-ok',
      MARKER_CONNECT_HOVER = 'connect-hover',
      MARKER_CONNECT_UPDATING = 'djs-updating';

  var COMMAND_BENDPOINT_UPDATE = 'connection.updateWaypoints',
      COMMAND_RECONNECT_START = 'connection.reconnectStart',
      COMMAND_RECONNECT_END = 'connection.reconnectEnd';

  var round$4 = Math.round;

  /**
   * A component that implements moving of bendpoints
   */
  function BendpointMove(injector, eventBus, canvas, dragging, graphicsFactory, rules, modeling) {

    // optional connection docking integration
    var connectionDocking = injector.get('connectionDocking', false);

    // API

    this.start = function (event, connection, bendpointIndex, insert) {

      var type,
          context,
          waypoints = connection.waypoints,
          gfx = canvas.getGraphics(connection);

      if (!insert && bendpointIndex === 0) {
        type = COMMAND_RECONNECT_START;
      } else if (!insert && bendpointIndex === waypoints.length - 1) {
        type = COMMAND_RECONNECT_END;
      } else {
        type = COMMAND_BENDPOINT_UPDATE;
      }

      context = {
        connection: connection,
        bendpointIndex: bendpointIndex,
        insert: insert,
        type: type
      };

      dragging.init(event, 'bendpoint.move', {
        data: {
          connection: connection,
          connectionGfx: gfx,
          context: context
        }
      });
    };

    // DRAGGING IMPLEMENTATION


    function redrawConnection(data) {
      graphicsFactory.update('connection', data.connection, data.connectionGfx);
    }

    function filterRedundantWaypoints(waypoints) {

      // alter copy of waypoints, not original
      waypoints = waypoints.slice();

      var idx = 0,
          point,
          previousPoint,
          nextPoint;

      while (waypoints[idx]) {
        point = waypoints[idx];
        previousPoint = waypoints[idx - 1];
        nextPoint = waypoints[idx + 1];

        if (pointDistance(point, nextPoint) === 0 || pointsOnLine(previousPoint, nextPoint, point)) {

          // remove point, if overlapping with {nextPoint}
          // or on line with {previousPoint} -> {point} -> {nextPoint}
          waypoints.splice(idx, 1);
        } else {
          idx++;
        }
      }

      return waypoints;
    }

    eventBus.on('bendpoint.move.start', function (e) {

      var context = e.context,
          connection = context.connection,
          originalWaypoints = connection.waypoints,
          waypoints = originalWaypoints.slice(),
          insert = context.insert,
          idx = context.bendpointIndex;

      context.originalWaypoints = originalWaypoints;

      if (insert) {
        // insert placeholder for bendpoint to-be-added
        waypoints.splice(idx, 0, null);
      }

      connection.waypoints = waypoints;

      // add dragger gfx
      context.draggerGfx = addBendpoint(canvas.getLayer('overlays'));
      classes$1(context.draggerGfx).add('djs-dragging');

      canvas.addMarker(connection, MARKER_CONNECT_UPDATING);
    });

    eventBus.on('bendpoint.move.hover', function (e) {
      var context = e.context;

      context.hover = e.hover;

      if (e.hover) {
        canvas.addMarker(e.hover, MARKER_CONNECT_HOVER);

        // asks whether reconnect / bendpoint move / bendpoint add
        // is allowed at the given position
        var allowed = context.allowed = rules.allowed(context.type, context);

        if (allowed) {
          canvas.removeMarker(context.hover, MARKER_NOT_OK$1);
          canvas.addMarker(context.hover, MARKER_OK$1);

          context.target = context.hover;
        } else if (allowed === false) {
          canvas.removeMarker(context.hover, MARKER_OK$1);
          canvas.addMarker(context.hover, MARKER_NOT_OK$1);

          context.target = null;
        }
      }
    });

    eventBus.on(['bendpoint.move.out', 'bendpoint.move.cleanup'], function (e) {

      // remove connect marker
      // if it was added
      var hover = e.context.hover;

      if (hover) {
        canvas.removeMarker(hover, MARKER_CONNECT_HOVER);
        canvas.removeMarker(hover, e.context.target ? MARKER_OK$1 : MARKER_NOT_OK$1);
      }
    });

    eventBus.on('bendpoint.move.move', function (e) {

      var context = e.context,
          moveType = context.type,
          connection = e.connection,
          source,
          target;

      connection.waypoints[context.bendpointIndex] = { x: e.x, y: e.y };

      if (connectionDocking) {

        if (context.hover) {
          if (moveType === COMMAND_RECONNECT_START) {
            source = context.hover;
          }

          if (moveType === COMMAND_RECONNECT_END) {
            target = context.hover;
          }
        }

        connection.waypoints = connectionDocking.getCroppedWaypoints(connection, source, target);
      }

      // add dragger gfx
      translate(context.draggerGfx, e.x, e.y);

      redrawConnection(e);
    });

    eventBus.on(['bendpoint.move.end', 'bendpoint.move.cancel'], function (e) {

      var context = e.context,
          hover = context.hover,
          connection = context.connection;

      // remove dragger gfx
      remove$1(context.draggerGfx);
      context.newWaypoints = connection.waypoints.slice();
      connection.waypoints = context.originalWaypoints;
      canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);

      if (hover) {
        canvas.removeMarker(hover, MARKER_OK$1);
        canvas.removeMarker(hover, MARKER_NOT_OK$1);
      }
    });

    eventBus.on('bendpoint.move.end', function (e) {

      var context = e.context,
          waypoints = context.newWaypoints,
          bendpointIndex = context.bendpointIndex,
          bendpoint = waypoints[bendpointIndex],
          allowed = context.allowed,
          hints;

      // ensure we have actual pixel values bendpoint
      // coordinates (important when zoom level was > 1 during move)
      bendpoint.x = round$4(bendpoint.x);
      bendpoint.y = round$4(bendpoint.y);

      if (allowed && context.type === COMMAND_RECONNECT_START) {
        modeling.reconnectStart(context.connection, context.target, bendpoint);
      } else if (allowed && context.type === COMMAND_RECONNECT_END) {
        modeling.reconnectEnd(context.connection, context.target, bendpoint);
      } else if (allowed !== false && context.type === COMMAND_BENDPOINT_UPDATE) {

        // pass hints on the actual moved bendpoint
        // this is useful for connection and label layouting
        hints = {
          bendpointMove: {
            insert: e.context.insert,
            bendpointIndex: bendpointIndex
          }
        };

        modeling.updateWaypoints(context.connection, filterRedundantWaypoints(waypoints), hints);
      } else {
        redrawConnection(e);

        return false;
      }
    });

    eventBus.on('bendpoint.move.cancel', function (e) {
      redrawConnection(e);
    });
  }

  BendpointMove.$inject = ['injector', 'eventBus', 'canvas', 'dragging', 'graphicsFactory', 'rules', 'modeling'];

  function roundPoint(point) {

    return {
      x: Math.round(point.x),
      y: Math.round(point.y)
    };
  }

  /**
   * Convert the given bounds to a { top, left, bottom, right } descriptor.
   *
   * @param {Bounds|Point} bounds
   *
   * @return {Object}
   */
  function asTRBL(bounds) {
    return {
      top: bounds.y,
      right: bounds.x + (bounds.width || 0),
      bottom: bounds.y + (bounds.height || 0),
      left: bounds.x
    };
  }

  /**
   * Get the mid of the given bounds or point.
   *
   * @param {Bounds|Point} bounds
   *
   * @return {Point}
   */
  function getMid(bounds) {
    return roundPoint({
      x: bounds.x + (bounds.width || 0) / 2,
      y: bounds.y + (bounds.height || 0) / 2
    });
  }

  // orientation utils //////////////////////

  /**
   * Get orientation of the given rectangle with respect to
   * the reference rectangle.
   *
   * A padding (positive or negative) may be passed to influence
   * horizontal / vertical orientation and intersection.
   *
   * @param {Bounds} rect
   * @param {Bounds} reference
   * @param {Point|Number} padding
   *
   * @return {String} the orientation; one of top, top-left, left, ..., bottom, right or intersect.
   */
  function getOrientation(rect, reference, padding) {

    padding = padding || 0;

    // make sure we can use an object, too
    // for individual { x, y } padding
    if (!isObject(padding)) {
      padding = { x: padding, y: padding };
    }

    var rectOrientation = asTRBL(rect),
        referenceOrientation = asTRBL(reference);

    var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,
        right = rectOrientation.left - padding.x >= referenceOrientation.right,
        bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,
        left = rectOrientation.right + padding.x <= referenceOrientation.left;

    var vertical = top ? 'top' : bottom ? 'bottom' : null,
        horizontal = left ? 'left' : right ? 'right' : null;

    if (horizontal && vertical) {
      return vertical + '-' + horizontal;
    } else {
      return horizontal || vertical || 'intersect';
    }
  }

  // intersection utils //////////////////////

  /**
   * Get intersection between an element and a line path.
   *
   * @param {PathDef} elementPath
   * @param {PathDef} linePath
   * @param {Boolean} cropStart crop from start or end
   *
   * @return {Point}
   */
  function getElementLineIntersection(elementPath, linePath, cropStart) {

    var intersections = getIntersections(elementPath, linePath);

    // recognize intersections
    // only one -> choose
    // two close together -> choose first
    // two or more distinct -> pull out appropriate one
    // none -> ok (fallback to point itself)
    if (intersections.length === 1) {
      return roundPoint(intersections[0]);
    } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {
      return roundPoint(intersections[0]);
    } else if (intersections.length > 1) {

      // sort by intersections based on connection segment +
      // distance from start
      intersections = sortBy(intersections, function (i) {
        var distance = Math.floor(i.t2 * 100) || 1;

        distance = 100 - distance;

        distance = (distance < 10 ? '0' : '') + distance;

        // create a sort string that makes sure we sort
        // line segment ASC + line segment position DESC (for cropStart)
        // line segment ASC + line segment position ASC (for cropEnd)
        return i.segment2 + '#' + distance;
      });

      return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);
    }

    return null;
  }

  function getIntersections(a, b) {
    return intersect(a, b);
  }

  var MARKER_CONNECT_HOVER$1 = 'connect-hover',
      MARKER_CONNECT_UPDATING$1 = 'djs-updating';

  function axisAdd(point, axis, delta) {
    return axisSet(point, axis, point[axis] + delta);
  }

  function axisSet(point, axis, value) {
    return {
      x: axis === 'x' ? value : point.x,
      y: axis === 'y' ? value : point.y
    };
  }

  function axisFenced(position, segmentStart, segmentEnd, axis) {

    var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]),
        minValue = Math.min(segmentStart[axis], segmentEnd[axis]);

    var padding = 20;

    var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);

    return axisSet(segmentStart, axis, fencedValue);
  }

  function flipAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
  }

  /**
   * Get the docking point on the given element.
   *
   * Compute a reasonable docking, if non exists.
   *
   * @param  {Point} point
   * @param  {djs.model.Shape} referenceElement
   * @param  {String} moveAxis (x|y)
   *
   * @return {Point}
   */
  function getDocking(point, referenceElement, moveAxis) {

    var referenceMid, inverseAxis;

    if (point.original) {
      return point.original;
    } else {
      referenceMid = getMid(referenceElement);
      inverseAxis = flipAxis(moveAxis);

      return axisSet(point, inverseAxis, referenceMid[inverseAxis]);
    }
  }

  /**
   * A component that implements moving of bendpoints
   */
  function ConnectionSegmentMove(injector, eventBus, canvas, dragging, graphicsFactory, rules, modeling) {

    // optional connection docking integration
    var connectionDocking = injector.get('connectionDocking', false);

    // API

    this.start = function (event, connection, idx) {

      var context,
          gfx = canvas.getGraphics(connection),
          segmentStartIndex = idx - 1,
          segmentEndIndex = idx,
          waypoints = connection.waypoints,
          segmentStart = waypoints[segmentStartIndex],
          segmentEnd = waypoints[segmentEndIndex],
          direction,
          axis;

      direction = pointsAligned(segmentStart, segmentEnd);

      // do not move diagonal connection
      if (!direction) {
        return;
      }

      // the axis where we are going to move things
      axis = direction === 'v' ? 'y' : 'x';

      if (segmentStartIndex === 0) {
        segmentStart = getDocking(segmentStart, connection.source, axis);
      }

      if (segmentEndIndex === waypoints.length - 1) {
        segmentEnd = getDocking(segmentEnd, connection.target, axis);
      }

      context = {
        connection: connection,
        segmentStartIndex: segmentStartIndex,
        segmentEndIndex: segmentEndIndex,
        segmentStart: segmentStart,
        segmentEnd: segmentEnd,
        axis: axis
      };

      dragging.init(event, {
        x: (segmentStart.x + segmentEnd.x) / 2,
        y: (segmentStart.y + segmentEnd.y) / 2
      }, 'connectionSegment.move', {
        cursor: axis === 'x' ? 'resize-ew' : 'resize-ns',
        data: {
          connection: connection,
          connectionGfx: gfx,
          context: context
        }
      });
    };

    /**
     * Crop connection if connection cropping is provided.
     *
     * @param {Connection} connection
     * @param {Array<Point>} newWaypoints
     *
     * @return {Array<Point>} cropped connection waypoints
     */
    function cropConnection(connection, newWaypoints) {

      // crop connection, if docking service is provided only
      if (!connectionDocking) {
        return newWaypoints;
      }

      var oldWaypoints = connection.waypoints,
          croppedWaypoints;

      // temporary set new waypoints
      connection.waypoints = newWaypoints;

      croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);

      // restore old waypoints
      connection.waypoints = oldWaypoints;

      return croppedWaypoints;
    }

    // DRAGGING IMPLEMENTATION

    function redrawConnection(data) {
      graphicsFactory.update('connection', data.connection, data.connectionGfx);
    }

    function updateDragger(context, segmentOffset, event) {

      var newWaypoints = context.newWaypoints,
          segmentStartIndex = context.segmentStartIndex + segmentOffset,
          segmentStart = newWaypoints[segmentStartIndex],
          segmentEndIndex = context.segmentEndIndex + segmentOffset,
          segmentEnd = newWaypoints[segmentEndIndex],
          axis = flipAxis(context.axis);

      // make sure the dragger does not move
      // outside the connection
      var draggerPosition = axisFenced(event, segmentStart, segmentEnd, axis);

      // update dragger
      translate(context.draggerGfx, draggerPosition.x, draggerPosition.y);
    }

    /**
     * Filter waypoints for redundant ones (i.e. on the same axis).
     * Returns the filtered waypoints and the offset related to the segment move.
     *
     * @param {Array<Point>} waypoints
     * @param {Integer} segmentStartIndex of moved segment start
     *
     * @return {Object} { filteredWaypoints, segmentOffset }
     */
    function filterRedundantWaypoints(waypoints, segmentStartIndex) {

      var segmentOffset = 0;

      var filteredWaypoints = waypoints.filter(function (r, idx) {
        if (pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r)) {

          // remove point and increment offset
          segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;
          return false;
        }

        // dont remove point
        return true;
      });

      return {
        waypoints: filteredWaypoints,
        segmentOffset: segmentOffset
      };
    }

    eventBus.on('connectionSegment.move.start', function (e) {

      var context = e.context,
          connection = e.connection,
          layer = canvas.getLayer('overlays');

      context.originalWaypoints = connection.waypoints.slice();

      // add dragger gfx
      context.draggerGfx = addSegmentDragger(layer, context.segmentStart, context.segmentEnd);
      classes$1(context.draggerGfx).add('djs-dragging');

      canvas.addMarker(connection, MARKER_CONNECT_UPDATING$1);
    });

    eventBus.on('connectionSegment.move.move', function (e) {

      var context = e.context,
          connection = context.connection,
          segmentStartIndex = context.segmentStartIndex,
          segmentEndIndex = context.segmentEndIndex,
          segmentStart = context.segmentStart,
          segmentEnd = context.segmentEnd,
          axis = context.axis;

      var newWaypoints = context.originalWaypoints.slice(),
          newSegmentStart = axisAdd(segmentStart, axis, e['d' + axis]),
          newSegmentEnd = axisAdd(segmentEnd, axis, e['d' + axis]);

      // original waypoint count and added / removed
      // from start waypoint delta. We use the later
      // to retrieve the updated segmentStartIndex / segmentEndIndex
      var waypointCount = newWaypoints.length,
          segmentOffset = 0;

      // move segment start / end by axis delta
      newWaypoints[segmentStartIndex] = newSegmentStart;
      newWaypoints[segmentEndIndex] = newSegmentEnd;

      var sourceToSegmentOrientation, targetToSegmentOrientation;

      // handle first segment
      if (segmentStartIndex < 2) {
        sourceToSegmentOrientation = getOrientation(connection.source, newSegmentStart);

        // first bendpoint, remove first segment if intersecting
        if (segmentStartIndex === 1) {

          if (sourceToSegmentOrientation === 'intersect') {
            newWaypoints.shift();
            newWaypoints[0] = newSegmentStart;
            segmentOffset--;
          }
        }

        // docking point, add segment if not intersecting anymore
        else {
            if (sourceToSegmentOrientation !== 'intersect') {
              newWaypoints.unshift(segmentStart);
              segmentOffset++;
            }
          }
      }

      // handle last segment
      if (segmentEndIndex > waypointCount - 3) {
        targetToSegmentOrientation = getOrientation(connection.target, newSegmentEnd);

        // last bendpoint, remove last segment if intersecting
        if (segmentEndIndex === waypointCount - 2) {

          if (targetToSegmentOrientation === 'intersect') {
            newWaypoints.pop();
            newWaypoints[newWaypoints.length - 1] = newSegmentEnd;
          }
        }

        // last bendpoint, remove last segment if intersecting
        else {
            if (targetToSegmentOrientation !== 'intersect') {
              newWaypoints.push(segmentEnd);
            }
          }
      }

      // update connection waypoints
      context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);

      // update dragger position
      updateDragger(context, segmentOffset, e);

      // save segmentOffset in context
      context.newSegmentStartIndex = segmentStartIndex + segmentOffset;

      // redraw connection
      redrawConnection(e);
    });

    eventBus.on('connectionSegment.move.hover', function (e) {

      e.context.hover = e.hover;
      canvas.addMarker(e.hover, MARKER_CONNECT_HOVER$1);
    });

    eventBus.on(['connectionSegment.move.out', 'connectionSegment.move.cleanup'], function (e) {

      // remove connect marker
      // if it was added
      var hover = e.context.hover;

      if (hover) {
        canvas.removeMarker(hover, MARKER_CONNECT_HOVER$1);
      }
    });

    eventBus.on('connectionSegment.move.cleanup', function (e) {

      var context = e.context,
          connection = context.connection;

      // remove dragger gfx
      if (context.draggerGfx) {
        remove$1(context.draggerGfx);
      }

      canvas.removeMarker(connection, MARKER_CONNECT_UPDATING$1);
    });

    eventBus.on(['connectionSegment.move.cancel', 'connectionSegment.move.end'], function (e) {
      var context = e.context,
          connection = context.connection;

      connection.waypoints = context.originalWaypoints;

      redrawConnection(e);
    });

    eventBus.on('connectionSegment.move.end', function (e) {

      var context = e.context,
          connection = context.connection,
          newWaypoints = context.newWaypoints,
          newSegmentStartIndex = context.newSegmentStartIndex;

      // ensure we have actual pixel values bendpoint
      // coordinates (important when zoom level was > 1 during move)
      newWaypoints = newWaypoints.map(function (p) {
        return {
          original: p.original,
          x: Math.round(p.x),
          y: Math.round(p.y)
        };
      });

      // apply filter redunant waypoints
      var filtered = filterRedundantWaypoints(newWaypoints, newSegmentStartIndex);

      // get filtered waypoints
      var filteredWaypoints = filtered.waypoints,
          croppedWaypoints = cropConnection(connection, filteredWaypoints),
          segmentOffset = filtered.segmentOffset;

      var hints = {
        segmentMove: {
          segmentStartIndex: context.segmentStartIndex,
          newSegmentStartIndex: newSegmentStartIndex + segmentOffset
        }
      };

      modeling.updateWaypoints(connection, croppedWaypoints, hints);
    });
  }

  ConnectionSegmentMove.$inject = ['injector', 'eventBus', 'canvas', 'dragging', 'graphicsFactory', 'rules', 'modeling'];

  var abs$1 = Math.abs,
      round$5 = Math.round;

  var TOLERANCE = 10;

  function BendpointSnapping(eventBus) {

    function snapTo(values$$1, value) {

      if (isArray(values$$1)) {
        var i = values$$1.length;

        while (i--) {
          if (abs$1(values$$1[i] - value) <= TOLERANCE) {
            return values$$1[i];
          }
        }
      } else {
        values$$1 = +values$$1;
        var rem = value % values$$1;

        if (rem < TOLERANCE) {
          return value - rem;
        }

        if (rem > values$$1 - TOLERANCE) {
          return value - rem + values$$1;
        }
      }

      return value;
    }

    function mid(element) {
      if (element.width) {
        return {
          x: round$5(element.width / 2 + element.x),
          y: round$5(element.height / 2 + element.y)
        };
      }
    }

    // connection segment snapping //////////////////////

    function getConnectionSegmentSnaps(context) {

      var snapPoints = context.snapPoints,
          connection = context.connection,
          waypoints = connection.waypoints,
          segmentStart = context.segmentStart,
          segmentStartIndex = context.segmentStartIndex,
          segmentEnd = context.segmentEnd,
          segmentEndIndex = context.segmentEndIndex,
          axis = context.axis;

      if (snapPoints) {
        return snapPoints;
      }

      var referenceWaypoints = [waypoints[segmentStartIndex - 1], segmentStart, segmentEnd, waypoints[segmentEndIndex + 1]];

      if (segmentStartIndex < 2) {
        referenceWaypoints.unshift(mid(connection.source));
      }

      if (segmentEndIndex > waypoints.length - 3) {
        referenceWaypoints.unshift(mid(connection.target));
      }

      context.snapPoints = snapPoints = { horizontal: [], vertical: [] };

      forEach(referenceWaypoints, function (p) {
        // we snap on existing bendpoints only,
        // not placeholders that are inserted during add
        if (p) {
          p = p.original || p;

          if (axis === 'y') {
            snapPoints.horizontal.push(p.y);
          }

          if (axis === 'x') {
            snapPoints.vertical.push(p.x);
          }
        }
      });

      return snapPoints;
    }

    eventBus.on('connectionSegment.move.move', 1500, function (event) {
      var context = event.context,
          snapPoints = getConnectionSegmentSnaps(context),
          x = event.x,
          y = event.y,
          sx,
          sy;

      if (!snapPoints) {
        return;
      }

      // snap
      sx = snapTo(snapPoints.vertical, x);
      sy = snapTo(snapPoints.horizontal, y);

      // correction x/y
      var cx = x - sx,
          cy = y - sy;

      // update delta
      assign(event, {
        dx: event.dx - cx,
        dy: event.dy - cy,
        x: sx,
        y: sy
      });
    });

    // bendpoint snapping //////////////////////

    function getBendpointSnaps(context) {

      var snapPoints = context.snapPoints,
          waypoints = context.connection.waypoints,
          bendpointIndex = context.bendpointIndex;

      if (snapPoints) {
        return snapPoints;
      }

      var referenceWaypoints = [waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1]];

      context.snapPoints = snapPoints = { horizontal: [], vertical: [] };

      forEach(referenceWaypoints, function (p) {
        // we snap on existing bendpoints only,
        // not placeholders that are inserted during add
        if (p) {
          p = p.original || p;

          snapPoints.horizontal.push(p.y);
          snapPoints.vertical.push(p.x);
        }
      });

      return snapPoints;
    }

    eventBus.on('bendpoint.move.move', 1500, function (event) {

      var context = event.context,
          snapPoints = getBendpointSnaps(context),
          target = context.target,
          targetMid = target && mid(target),
          x = event.x,
          y = event.y,
          sx,
          sy;

      if (!snapPoints) {
        return;
      }

      // snap
      sx = snapTo(targetMid ? snapPoints.vertical.concat([targetMid.x]) : snapPoints.vertical, x);
      sy = snapTo(targetMid ? snapPoints.horizontal.concat([targetMid.y]) : snapPoints.horizontal, y);

      // correction x/y
      var cx = x - sx,
          cy = y - sy;

      // update delta
      assign(event, {
        dx: event.dx - cx,
        dy: event.dy - cy,
        x: event.x - cx,
        y: event.y - cy
      });
    });
  }

  BendpointSnapping.$inject = ['eventBus'];

  var BendpointsModule = {
    __depends__: [DraggingModule, Rules$1],
    __init__: ['bendpoints', 'bendpointSnapping'],
    bendpoints: ['type', Bendpoints],
    bendpointMove: ['type', BendpointMove],
    connectionSegmentMove: ['type', ConnectionSegmentMove],
    bendpointSnapping: ['type', BendpointSnapping]
  };

  /**
   * Does the definitions element contain graphical information?
   *
   * @param  {ModdleElement} definitions
   *
   * @return {Boolean} true, if the definitions contains graphical information
   */
  function containsDi(definitions) {
    return some(definitions.drgElements, hasDi);
  }

  function hasDi(element) {

    var extensions = element.extensionElements;

    var values$$1 = extensions && extensions.values;

    return values$$1 && find(values$$1, function (v) {
      return is(v, 'biodi:Bounds');
    });
  }

  /**
   * A component that generated basic DI, if graphical
   * information is missing on a dmn:Definitions element
   * to be imported.
   *
   * @param {EventBus} eventBus
   * @param {DrdFactory} drdFactory
   * @param {ElementFactory} elementFactory
   */
  function DiGenerator(eventBus, drdFactory, elementFactory) {

    // ensure the definitions contains DI information
    eventBus.on('import.start', function (_ref) {
      var definitions = _ref.definitions;

      if (!containsDi(definitions)) {
        createDi(definitions);
      }
    });

    /**
     * Create basic DI for given dmn:Definitions element
     */
    function createDi(definitions) {

      var idx = 0;

      forEach(definitions.drgElements, function (element) {

        var bounds, extensionElements, dimensions;

        // only create DI for decision elements;
        // we're not a full fledged layouter (!)
        if (!is(element, 'dmn:Decision')) {
          return;
        }

        extensionElements = element.extensionElements;

        if (!extensionElements) {
          extensionElements = element.extensionElements = drdFactory.createDi();
          extensionElements.$parent = element;
        }

        dimensions = elementFactory._getDefaultSize(element);

        bounds = drdFactory.createDiBounds({
          x: 150 + idx * 30,
          y: 150 + idx * 30,
          width: dimensions.width,
          height: dimensions.height
        });

        // add bounds
        extensionElements.get('values').push(bounds);
        bounds.$parent = extensionElements;

        // stacking elements nicely on top of each other
        idx++;
      });
    }
  }

  DiGenerator.$inject = ['eventBus', 'drdFactory', 'elementFactory'];

  var GenerateDiModule = {
    __init__: ['diGenerator'],
    diGenerator: ['type', DiGenerator]
  };

  /**
   * A clip board stub
   */
  function Clipboard() {}

  Clipboard.prototype.get = function () {
    return this._data;
  };

  Clipboard.prototype.set = function (data) {
    this._data = data;
  };

  Clipboard.prototype.clear = function () {
    var data = this._data;

    delete this._data;

    return data;
  };

  Clipboard.prototype.isEmpty = function () {
    return !this._data;
  };

  var ClipboardModule = {
    clipboard: ['type', Clipboard]
  };

  function MouseTracking(eventBus, canvas) {
    this._eventBus = eventBus;
    this._canvas = canvas;

    this._init();
  }

  MouseTracking.$inject = ['eventBus', 'canvas'];

  MouseTracking.prototype.getHoverContext = function () {
    var viewbox = this._canvas.viewbox();

    return {
      element: this._hoverElement,
      point: {
        x: viewbox.x + Math.round(this._mouseX / viewbox.scale),
        y: viewbox.y + Math.round(this._mouseY / viewbox.scale)
      }
    };
  };

  MouseTracking.prototype._init = function () {
    var eventBus = this._eventBus,
        canvas = this._canvas;

    var container = canvas.getContainer();

    this._setMousePosition = bind(this._setMousePosition, this);

    container.addEventListener('mousemove', this._setMousePosition);

    eventBus.on('diagram.destroy', function () {
      container.removeEventListener('mousemove', this._setMousePosition);
    }, this);

    eventBus.on('element.hover', this._setHoverElement, this);
  };

  MouseTracking.prototype._setHoverElement = function (event) {
    this._hoverElement = event.element;
  };

  MouseTracking.prototype._setMousePosition = function (event) {
    this._mouseX = event.layerX;
    this._mouseY = event.layerY;
  };

  var MouseTrackingModule = {
    __init__: ['mouseTracking'],
    mouseTracking: ['type', MouseTracking]
  };

  function getTopLevel(elements) {
    var topLevel = {},
        parents = [],
        result = [],
        clearedParents = [];

    forEach(elements, function (element) {
      var parent = element.parent;

      if (!topLevel[parent.id]) {
        topLevel[parent.id] = [];
      }

      if (parents.indexOf(parent.id) === -1) {
        parents.push(parent.id);
      }

      topLevel[parent.id].push(element);
    });

    forEach(parents, function (parent) {
      forEach(topLevel[parent], function (element) {
        if (topLevel[element.id]) {
          clearedParents.push(element.id);
        }
      });
    });

    forEach(parents, function (parent) {
      var idx = clearedParents.indexOf(parent);

      if (idx === -1) {
        result = result.concat(topLevel[parent]);
      }
    });

    return result;
  }

  function CopyPaste(eventBus, modeling, elementFactory, rules, clipboard, canvas) {

    this._eventBus = eventBus;
    this._modeling = modeling;
    this._elementFactory = elementFactory;
    this._rules = rules;
    this._canvas = canvas;

    this._clipboard = clipboard;

    this._descriptors = [];

    // Element creation priorities:
    // - 1: Independent shapes
    // - 2: Attached shapes
    // - 3: Connections
    // - 4: labels
    this.registerDescriptor(function (element, descriptor) {
      // Base priority
      descriptor.priority = 1;

      descriptor.id = element.id;

      if (element.parent) {
        descriptor.parent = element.parent.id;
      }

      if (element.labelTarget) {
        // Labels priority
        descriptor.priority = 4;
        descriptor.labelTarget = element.labelTarget.id;
      }

      if (element.host) {
        // Attached shapes priority
        descriptor.priority = 2;
        descriptor.host = element.host.id;
      }

      if (typeof element.x === 'number') {
        descriptor.x = element.x;
        descriptor.y = element.y;
      }

      if (element.width) {
        descriptor.width = element.width;
        descriptor.height = element.height;
      }

      if (element.waypoints) {
        // Connections priority
        descriptor.priority = 3;
        descriptor.waypoints = [];

        forEach(element.waypoints, function (waypoint) {
          var wp = {
            x: waypoint.x,
            y: waypoint.y
          };

          if (waypoint.original) {
            wp.original = {
              x: waypoint.original.x,
              y: waypoint.original.y
            };
          }

          descriptor.waypoints.push(wp);
        });
      }

      if (element.source && element.target) {
        descriptor.source = element.source.id;
        descriptor.target = element.target.id;
      }

      return descriptor;
    });
  }

  CopyPaste.$inject = ['eventBus', 'modeling', 'elementFactory', 'rules', 'clipboard', 'canvas'];

  /**
   * Copy a number of elements.
   *
   * @param {djs.model.Base} selectedElements
   *
   * @return {Object} the copied tree
   */
  CopyPaste.prototype.copy = function (selectedElements) {
    var clipboard = this._clipboard,
        tree,
        bbox;

    if (!isArray(selectedElements)) {
      selectedElements = selectedElements ? [selectedElements] : [];
    }

    if (!selectedElements.length) {
      return;
    }

    tree = this.createTree(selectedElements);

    bbox = this._bbox = center(getBBox(tree.allShapes));

    // not needed after computing the center position of the copied elements
    delete tree.allShapes;

    forEach(tree, function (elements) {

      forEach(elements, function (element) {
        var delta$$1, labelTarget;

        // set label's relative position to their label target
        if (element.labelTarget) {
          labelTarget = find(elements, matchPattern({ id: element.labelTarget }));

          // just grab the delta from the first waypoint
          if (labelTarget.waypoints) {
            delta$$1 = delta(element, labelTarget.waypoints[0]);
          } else {
            delta$$1 = delta(element, labelTarget);
          }
        } else if (element.priority === 3) {
          // connections have priority 3
          delta$$1 = [];

          forEach(element.waypoints, function (waypoint) {
            var waypointDelta = delta(waypoint, bbox);

            delta$$1.push(waypointDelta);
          });
        } else {
          delta$$1 = delta(element, bbox);
        }

        element.delta = delta$$1;
      });
    });

    this._eventBus.fire('elements.copy', { context: { tree: tree } });

    // if tree is empty, means that nothing can be or is allowed to be copied
    if (Object.keys(tree).length === 0) {
      clipboard.clear();
    } else {
      clipboard.set(tree);
    }

    this._eventBus.fire('elements.copied', { context: { tree: tree } });

    return tree;
  };

  // Allow pasting under the cursor
  CopyPaste.prototype.paste = function (context) {
    var clipboard = this._clipboard,
        modeling = this._modeling,
        eventBus = this._eventBus,
        rules = this._rules;

    var tree = clipboard.get(),
        topParent = context.element,
        position = context.point,
        newTree,
        canPaste;

    if (clipboard.isEmpty()) {
      return;
    }

    newTree = reduce(tree, function (pasteTree, elements, depthStr) {
      var depth = parseInt(depthStr, 10);

      if (isNaN(depth)) {
        return pasteTree;
      }

      pasteTree[depth] = elements;

      return pasteTree;
    }, {});

    canPaste = rules.allowed('elements.paste', {
      tree: newTree,
      target: topParent
    });

    if (!canPaste) {
      eventBus.fire('elements.paste.rejected', {
        context: {
          tree: newTree,
          position: position,
          target: topParent
        }
      });

      return;
    }

    modeling.pasteElements(newTree, topParent, position);
  };

  CopyPaste.prototype._computeDelta = function (elements, element) {
    var bbox = this._bbox,
        delta$$1 = {};

    // set label's relative position to their label target
    if (element.labelTarget) {
      return delta(element, element.labelTarget);
    }

    // connections have prority 3
    if (element.priority === 3) {
      delta$$1 = [];

      forEach(element.waypoints, function (waypoint) {
        var waypointDelta = delta(waypoint, bbox);

        delta$$1.push(waypointDelta);
      });
    } else {
      delta$$1 = delta(element, bbox);
    }

    return delta$$1;
  };

  /**
   * Checks if the element in question has a relations to other elements.
   * Possible dependants: connections, labels, attachers
   *
   * @param  {Array} elements
   * @param  {Object} element
   *
   * @return {Boolean}
   */
  CopyPaste.prototype.hasRelations = function (elements, element) {
    var source, target, labelTarget;

    if (element.waypoints) {
      source = find(elements, matchPattern({ id: element.source.id }));
      target = find(elements, matchPattern({ id: element.target.id }));

      if (!source || !target) {
        return false;
      }
    }

    if (element.labelTarget) {
      labelTarget = find(elements, matchPattern({ id: element.labelTarget.id }));

      if (!labelTarget) {
        return false;
      }
    }

    return true;
  };

  CopyPaste.prototype.registerDescriptor = function (descriptor) {
    if (typeof descriptor !== 'function') {
      throw new Error('the descriptor must be a function');
    }

    if (this._descriptors.indexOf(descriptor) !== -1) {
      throw new Error('this descriptor is already registered');
    }

    this._descriptors.push(descriptor);
  };

  CopyPaste.prototype._executeDescriptors = function (data) {
    if (!data.descriptor) {
      data.descriptor = {};
    }

    forEach(this._descriptors, function (descriptor) {
      data.descriptor = descriptor(data.element, data.descriptor);
    });

    return data;
  };

  /**
   * Creates a tree like structure from an arbitrary collection of elements
   *
   * @example
   * tree: {
   *	0: [
   *		{ id: 'shape_12da', priority: 1, ... },
   *		{ id: 'shape_01bj', priority: 1, ... },
   *		{ id: 'connection_79fa', source: 'shape_12da', target: 'shape_01bj', priority: 3, ... },
   *	],
   *	1: [ ... ]
   * };
   *
   * @param  {Array} elements
   * @return {Object}
   */
  CopyPaste.prototype.createTree = function (elements) {
    var rules = this._rules,
        self = this;

    var tree = {},
        includedElements = [],
        _elements;

    var topLevel = getTopLevel(elements);

    tree.allShapes = [];

    function canCopy(collection, element) {
      return rules.allowed('element.copy', {
        collection: collection,
        element: element
      });
    }

    function includeElement(data) {
      var idx = findIndex(includedElements, matchPattern({ element: data.element })),
          element;

      if (idx !== -1) {
        element = includedElements[idx];
      } else {
        return includedElements.push(data);
      }

      // makes sure that it has the correct depth
      if (element.depth < data.depth) {
        includedElements.splice(idx, 1);

        includedElements.push(data);
      }
    }

    eachElement(topLevel, function (element, i, depth) {
      var nestedChildren = element.children;

      // don't add labels directly
      if (element.labelTarget) {
        return;
      }

      function getNested(lists) {
        forEach(lists, function (list) {
          if (list && list.length) {

            forEach(list, function (elem) {

              forEach(elem.labels, function (label) {
                includeElement({
                  element: label,
                  depth: depth
                });
              });

              includeElement({
                element: elem,
                depth: depth
              });
            });
          }
        });
      }

      // fetch element's labels
      forEach(element.labels, function (label) {

        includeElement({
          element: label,
          depth: depth
        });
      });

      getNested([element.attachers, element.incoming, element.outgoing]);

      includeElement({
        element: element,
        depth: depth
      });

      if (nestedChildren) {
        return nestedChildren;
      }
    });

    includedElements = map(includedElements, function (data) {
      // this is where other registered descriptors hook in
      return self._executeDescriptors(data);
    });

    // order the elements to check if the ones dependant on others (by relationship)
    // can be copied. f.ex: label needs it's label target
    includedElements = sortBy(includedElements, function (data) {
      return data.descriptor.priority;
    });

    _elements = map(includedElements, function (data) {
      return data.element;
    });

    forEach(includedElements, function (data) {
      var depth = data.depth;

      if (!self.hasRelations(tree.allShapes, data.element)) {
        return;
      }

      if (!canCopy(_elements, data.element)) {
        return;
      }

      tree.allShapes.push(data.element);

      // create depth branches
      if (!tree[depth]) {
        tree[depth] = [];
      }

      tree[depth].push(data.descriptor);
    });

    return tree;
  };

  var CopyPasteModule = {
    __depends__: [ClipboardModule, Rules$1, MouseTrackingModule],
    __init__: ['copyPaste'],
    copyPaste: ['type', CopyPaste]
  };

  var NOT_REGISTERED_ERROR = 'is not a registered action',
      IS_REGISTERED_ERROR = 'is already registered';

  /**
   * An interface that provides access to modeling actions by decoupling
   * the one who requests the action to be triggered and the trigger itself.
   *
   * It's possible to add new actions by registering them with ´registerAction´ and likewise
   * unregister existing ones with ´unregisterAction´.
   *
   */
  function EditorActions(eventBus, commandStack, modeling, selection, zoomScroll, copyPaste, canvas, rules, mouseTracking) {

    this._actions = {
      undo: function undo() {
        commandStack.undo();
      },
      redo: function redo() {
        commandStack.redo();
      },
      copy: function copy() {
        var selectedElements = selection.get();

        copyPaste.copy(selectedElements);
      },
      paste: function paste() {
        var context = mouseTracking.getHoverContext();

        copyPaste.paste(context);
      },
      stepZoom: function stepZoom(opts) {
        zoomScroll.stepZoom(opts.value);
      },
      zoom: function zoom(opts) {
        canvas.zoom(opts.value);
      },
      removeSelection: function removeSelection() {
        var selectedElements = selection.get();

        if (selectedElements.length) {
          var allowed = rules.allowed('elements.delete', { elements: selectedElements }),
              removableElements;

          if (allowed === false) {
            return;
          } else if (isArray(allowed)) {
            removableElements = allowed;
          } else {
            removableElements = selectedElements;
          }

          if (removableElements.length) {
            modeling.removeElements(removableElements.slice());
          }
        }
      },
      moveCanvas: function moveCanvas(opts) {
        var dx = 0,
            dy = 0,
            invertY = opts.invertY,
            speed = opts.speed;

        var actualSpeed = speed / Math.min(Math.sqrt(canvas.viewbox().scale), 1);

        switch (opts.direction) {
          case 'left':
            // Left
            dx = actualSpeed;
            break;
          case 'up':
            // Up
            dy = actualSpeed;
            break;
          case 'right':
            // Right
            dx = -actualSpeed;
            break;
          case 'down':
            // Down
            dy = -actualSpeed;
            break;
        }

        if (dy && invertY) {
          dy = -dy;
        }

        canvas.scroll({ dx: dx, dy: dy });
      }
    };
  }

  EditorActions.$inject = ['eventBus', 'commandStack', 'modeling', 'selection', 'zoomScroll', 'copyPaste', 'canvas', 'rules', 'mouseTracking'];

  /**
   * Triggers a registered action
   *
   * @param  {String} action
   * @param  {Object} opts
   *
   * @return {Unknown} Returns what the registered listener returns
   */
  EditorActions.prototype.trigger = function (action, opts) {
    if (!this._actions[action]) {
      throw error$2(action, NOT_REGISTERED_ERROR);
    }

    return this._actions[action](opts);
  };

  /**
   * Registers a collections of actions.
   * The key of the object will be the name of the action.
   *
   * @example
   * ´´´
   * var actions = {
   *   spaceTool: function() {
   *     spaceTool.activateSelection();
   *   },
   *   lassoTool: function() {
   *     lassoTool.activateSelection();
   *   }
   * ];
   *
   * editorActions.register(actions);
   *
   * editorActions.isRegistered('spaceTool'); // true
   * ´´´
   *
   * @param  {Object} actions
   */
  EditorActions.prototype.register = function (actions, listener) {
    var self = this;

    if (typeof actions === 'string') {
      return this._registerAction(actions, listener);
    }

    forEach(actions, function (listener, action) {
      self._registerAction(action, listener);
    });
  };

  /**
   * Registers a listener to an action key
   *
   * @param  {String} action
   * @param  {Function} listener
   */
  EditorActions.prototype._registerAction = function (action, listener) {
    if (this.isRegistered(action)) {
      throw error$2(action, IS_REGISTERED_ERROR);
    }

    this._actions[action] = listener;
  };

  /**
   * Unregister an existing action
   *
   * @param {String} action
   */
  EditorActions.prototype.unregister = function (action) {
    if (!this.isRegistered(action)) {
      throw error$2(action, NOT_REGISTERED_ERROR);
    }

    this._actions[action] = undefined;
  };

  /**
   * Returns the number of actions that are currently registered
   *
   * @return {Number}
   */
  EditorActions.prototype.length = function () {
    return Object.keys(this._actions).length;
  };

  /**
   * Checks wether the given action is registered
   *
   * @param {String} action
   *
   * @return {Boolean}
   */
  EditorActions.prototype.isRegistered = function (action) {
    return !!this._actions[action];
  };

  function error$2(action, message) {
    return new Error(action + ' ' + message);
  }

  var DiagramEditorActions = {
    __depends__: [DiagramSelection, CopyPasteModule, ZoomScrollModule],
    __init__: ['editorActions'],
    editorActions: ['type', EditorActions]
  };

  var LOW_PRIORITY$5 = 250;

  /**
   * The tool manager acts as middle-man between the available tool's and the Palette,
   * it takes care of making sure that the correct active state is set.
   *
   * @param  {Object}    eventBus
   * @param  {Object}    dragging
   */
  function ToolManager(eventBus, dragging) {
    this._eventBus = eventBus;
    this._dragging = dragging;

    this._tools = [];
    this._active = null;
  }

  ToolManager.$inject = ['eventBus', 'dragging'];

  ToolManager.prototype.registerTool = function (name, events) {
    var tools = this._tools;

    if (!events) {
      throw new Error('A tool has to be registered with it\'s "events"');
    }

    tools.push(name);

    this.bindEvents(name, events);
  };

  ToolManager.prototype.isActive = function (tool) {
    return tool && this._active === tool;
  };

  ToolManager.prototype.length = function (tool) {
    return this._tools.length;
  };

  ToolManager.prototype.setActive = function (tool) {
    var eventBus = this._eventBus;

    if (this._active !== tool) {
      this._active = tool;

      eventBus.fire('tool-manager.update', { tool: tool });
    }
  };

  ToolManager.prototype.bindEvents = function (name, events) {
    var eventBus = this._eventBus,
        dragging = this._dragging;

    var eventsToRegister = [];

    eventBus.on(events.tool + '.init', function (event) {
      var context = event.context;

      // Active tools that want to reactivate themselves must do this explicitly
      if (!context.reactivate && this.isActive(name)) {
        this.setActive(null);

        dragging.cancel();
        return;
      }

      this.setActive(name);
    }, this);

    // Todo[ricardo]: add test cases
    forEach(events, function (event) {
      eventsToRegister.push(event + '.ended');
      eventsToRegister.push(event + '.canceled');
    });

    eventBus.on(eventsToRegister, LOW_PRIORITY$5, function (event) {
      var originalEvent = event.originalEvent;

      // We defer the de-activation of the tool to the .activate phase,
      // so we're able to check if we want to toggle off the current
      // active tool or switch to a new one
      if (!this._active) {
        return;
      }

      if (originalEvent && closest(originalEvent.target, '.group[data-group="tools"]')) {
        return;
      }

      this.setActive(null);
    }, this);
  };

  var ToolManagerModule = {
    __depends__: [DraggingModule],
    __init__: ['toolManager'],
    toolManager: ['type', ToolManager]
  };

  var LASSO_TOOL_CURSOR = 'crosshair';

  function LassoTool(eventBus, canvas, dragging, elementRegistry, selection, toolManager) {

    this._selection = selection;
    this._dragging = dragging;

    var self = this;

    // lasso visuals implementation

    /**
    * A helper that realizes the selection box visual
    */
    var visuals = {

      create: function create$$1(context) {
        var container = canvas.getDefaultLayer(),
            frame;

        frame = context.frame = create('rect');
        attr$1(frame, {
          class: 'djs-lasso-overlay',
          width: 1,
          height: 1,
          x: 0,
          y: 0
        });

        append(container, frame);
      },

      update: function update(context) {
        var frame = context.frame,
            bbox = context.bbox;

        attr$1(frame, {
          x: bbox.x,
          y: bbox.y,
          width: bbox.width,
          height: bbox.height
        });
      },

      remove: function remove$$1(context) {

        if (context.frame) {
          remove$1(context.frame);
        }
      }
    };

    toolManager.registerTool('lasso', {
      tool: 'lasso.selection',
      dragging: 'lasso'
    });

    eventBus.on('lasso.selection.end', function (event) {
      var target = event.originalEvent.target;

      // only reactive on diagram click
      // on some occasions, event.hover is not set and we have to check if the target is an svg
      if (!event.hover && !(target instanceof SVGElement)) {
        return;
      }

      eventBus.once('lasso.selection.ended', function () {
        self.activateLasso(event.originalEvent, true);
      });
    });

    // lasso interaction implementation

    eventBus.on('lasso.end', function (event) {

      var bbox = toBBox(event);

      var elements = elementRegistry.filter(function (element) {
        return element;
      });

      self.select(elements, bbox);
    });

    eventBus.on('lasso.start', function (event) {

      var context = event.context;

      context.bbox = toBBox(event);
      visuals.create(context);
    });

    eventBus.on('lasso.move', function (event) {

      var context = event.context;

      context.bbox = toBBox(event);
      visuals.update(context);
    });

    eventBus.on('lasso.cleanup', function (event) {

      var context = event.context;

      visuals.remove(context);
    });

    // event integration

    eventBus.on('element.mousedown', 1500, function (event) {

      if (hasSecondaryModifier(event)) {
        self.activateLasso(event.originalEvent);

        // we've handled the event
        return true;
      }
    });
  }

  LassoTool.$inject = ['eventBus', 'canvas', 'dragging', 'elementRegistry', 'selection', 'toolManager'];

  LassoTool.prototype.activateLasso = function (event, autoActivate) {

    this._dragging.init(event, 'lasso', {
      autoActivate: autoActivate,
      cursor: LASSO_TOOL_CURSOR,
      data: {
        context: {}
      }
    });
  };

  LassoTool.prototype.activateSelection = function (event) {

    this._dragging.init(event, 'lasso.selection', {
      trapClick: false,
      cursor: LASSO_TOOL_CURSOR,
      data: {
        context: {}
      }
    });
  };

  LassoTool.prototype.select = function (elements, bbox) {
    var selectedElements = getEnclosedElements(elements, bbox);

    this._selection.select(values(selectedElements));
  };

  LassoTool.prototype.toggle = function () {
    if (this.isActive()) {
      this._dragging.cancel();
    } else {
      this.activateSelection();
    }
  };

  LassoTool.prototype.isActive = function () {
    var context = this._dragging.context();

    return context && /^lasso/.test(context.prefix);
  };

  function toBBox(event) {

    var start = {

      x: event.x - event.dx,
      y: event.y - event.dy
    };

    var end = {
      x: event.x,
      y: event.y
    };

    var bbox;

    if (start.x <= end.x && start.y < end.y || start.x < end.x && start.y <= end.y) {

      bbox = {
        x: start.x,
        y: start.y,
        width: end.x - start.x,
        height: end.y - start.y
      };
    } else if (start.x >= end.x && start.y < end.y || start.x > end.x && start.y <= end.y) {

      bbox = {
        x: end.x,
        y: start.y,
        width: start.x - end.x,
        height: end.y - start.y
      };
    } else if (start.x <= end.x && start.y > end.y || start.x < end.x && start.y >= end.y) {

      bbox = {
        x: start.x,
        y: end.y,
        width: end.x - start.x,
        height: start.y - end.y
      };
    } else if (start.x >= end.x && start.y > end.y || start.x > end.x && start.y >= end.y) {

      bbox = {
        x: end.x,
        y: end.y,
        width: start.x - end.x,
        height: start.y - end.y
      };
    } else {

      bbox = {
        x: end.x,
        y: end.y,
        width: 0,
        height: 0
      };
    }
    return bbox;
  }

  var DiagramLasso = {
    __depends__: [ToolManagerModule],
    __init__: ['lassoTool'],
    lassoTool: ['type', LassoTool]
  };

  function DrdEditorActions(injector, canvas, elementRegistry, selection, _lassoTool, _directEditing) {

    injector.invoke(EditorActions, this);

    this.register({
      selectElements: function selectElements() {
        // select all elements except for the invisible
        // root element
        var rootElement = canvas.getRootElement();

        var elements = elementRegistry.filter(function (element) {
          return element !== rootElement;
        });

        selection.select(elements);

        return elements;
      },
      lassoTool: function lassoTool() {
        _lassoTool.toggle();
      },
      directEditing: function directEditing() {
        var currentSelection = selection.get();

        if (currentSelection.length) {
          _directEditing.activate(currentSelection[0]);
        }
      }
    });
  }

  inherits_browser(DrdEditorActions, EditorActions);

  DrdEditorActions.$inject = ['injector', 'canvas', 'elementRegistry', 'selection', 'lassoTool', 'directEditing'];

  var EditorActionsModule = {
    __depends__: [DiagramEditorActions, DiagramLasso],
    editorActions: ['type', DrdEditorActions]
  };

  var entrySelector = '.entry';

  /**
   * A context pad that displays element specific, contextual actions next
   * to a diagram element.
   *
   * @param {EventBus} eventBus
   * @param {Overlays} overlays
   */
  function ContextPad(eventBus, overlays) {

    this._providers = [];

    this._eventBus = eventBus;
    this._overlays = overlays;

    this._current = null;

    this._init();
  }

  ContextPad.$inject = ['eventBus', 'overlays'];

  /**
   * Registers events needed for interaction with other components
   */
  ContextPad.prototype._init = function () {

    var eventBus = this._eventBus;

    var self = this;

    eventBus.on('selection.changed', function (e) {

      var selection = e.newSelection;

      if (selection.length === 1) {
        self.open(selection[0]);
      } else {
        self.close();
      }
    });

    eventBus.on('elements.delete', function (event$$1) {
      var elements = event$$1.elements;

      forEach(elements, function (e) {
        if (self.isOpen(e)) {
          self.close();
        }
      });
    });

    eventBus.on('element.changed', function (event$$1) {
      var element = event$$1.element,
          current = self._current;

      // force reopen if element for which we are currently opened changed
      if (current && current.element === element) {
        self.open(element, true);
      }
    });
  };

  /**
   * Register a provider with the context pad
   *
   * @param  {ContextPadProvider} provider
   */
  ContextPad.prototype.registerProvider = function (provider) {
    this._providers.push(provider);
  };

  /**
   * Returns the context pad entries for a given element
   *
   * @param {djs.element.Base} element
   *
   * @return {Array<ContextPadEntryDescriptor>} list of entries
   */
  ContextPad.prototype.getEntries = function (element) {
    var entries = {};

    // loop through all providers and their entries.
    // group entries by id so that overriding an entry is possible
    forEach(this._providers, function (provider) {
      var e = provider.getContextPadEntries(element);

      forEach(e, function (entry, id) {
        entries[id] = entry;
      });
    });

    return entries;
  };

  /**
   * Trigger an action available on the opened context pad
   *
   * @param  {String} action
   * @param  {Event} event
   * @param  {Boolean} [autoActivate=false]
   */
  ContextPad.prototype.trigger = function (action, event$$1, autoActivate) {

    var element = this._current.element,
        entries = this._current.entries,
        entry,
        handler,
        originalEvent,
        button = event$$1.delegateTarget || event$$1.target;

    if (!button) {
      return event$$1.preventDefault();
    }

    entry = entries[attr(button, 'data-action')];
    handler = entry.action;

    originalEvent = event$$1.originalEvent || event$$1;

    // simple action (via callback function)
    if (isFunction(handler)) {
      if (action === 'click') {
        return handler(originalEvent, element, autoActivate);
      }
    } else {
      if (handler[action]) {
        return handler[action](originalEvent, element, autoActivate);
      }
    }

    // silence other actions
    event$$1.preventDefault();
  };

  /**
   * Open the context pad for the given element
   *
   * @param {djs.model.Base} element
   * @param {Boolean} force if true, force reopening the context pad
   */
  ContextPad.prototype.open = function (element, force) {
    if (!force && this.isOpen(element)) {
      return;
    }

    this.close();
    this._updateAndOpen(element);
  };

  ContextPad.prototype._updateAndOpen = function (element) {

    var entries = this.getEntries(element),
        pad = this.getPad(element),
        html = pad.html;

    forEach(entries, function (entry, id) {
      var grouping = entry.group || 'default',
          control = domify(entry.html || '<div class="entry" draggable="true"></div>'),
          container;

      attr(control, 'data-action', id);

      container = query('[data-group=' + grouping + ']', html);
      if (!container) {
        container = domify('<div class="group" data-group="' + grouping + '"></div>');
        html.appendChild(container);
      }

      container.appendChild(control);

      if (entry.className) {
        addClasses(control, entry.className);
      }

      if (entry.title) {
        attr(control, 'title', entry.title);
      }

      if (entry.imageUrl) {
        control.appendChild(domify('<img src="' + entry.imageUrl + '">'));
      }
    });

    classes(html).add('open');

    this._current = {
      element: element,
      pad: pad,
      entries: entries
    };

    this._eventBus.fire('contextPad.open', { current: this._current });
  };

  ContextPad.prototype.getPad = function (element) {
    if (this.isOpen()) {
      return this._current.pad;
    }

    var self = this;

    var overlays = this._overlays;

    var html = domify('<div class="djs-context-pad"></div>');

    delegateEvents.bind(html, entrySelector, 'click', function (event$$1) {
      self.trigger('click', event$$1);
    });

    delegateEvents.bind(html, entrySelector, 'dragstart', function (event$$1) {
      self.trigger('dragstart', event$$1);
    });

    // stop propagation of mouse events
    componentEvent.bind(html, 'mousedown', function (event$$1) {
      event$$1.stopPropagation();
    });

    this._overlayId = overlays.add(element, 'context-pad', {
      position: {
        right: -9,
        top: -6
      },
      html: html
    });

    var pad = overlays.get(this._overlayId);

    this._eventBus.fire('contextPad.create', { element: element, pad: pad });

    return pad;
  };

  /**
   * Close the context pad
   */
  ContextPad.prototype.close = function () {
    if (!this.isOpen()) {
      return;
    }

    this._overlays.remove(this._overlayId);

    this._overlayId = null;

    this._eventBus.fire('contextPad.close', { current: this._current });

    this._current = null;
  };

  /**
   * Check if pad is open. If element is given, will check
   * if pad is opened with given element.
   *
   * @param {Element} element
   * @return {Boolean}
   */
  ContextPad.prototype.isOpen = function (element) {
    return !!this._current && (!element ? true : this._current.element === element);
  };

  // helpers //////////////////////

  function addClasses(element, classNames) {

    var classes$$1 = classes(element);

    var actualClassNames = isArray(classNames) ? classNames : classNames.split(/\s+/g);
    actualClassNames.forEach(function (cls) {
      classes$$1.add(cls);
    });
  }

  var DiagramContextPad = {
    __depends__: [InteractionEventsModule, OverlaysModule],
    contextPad: ['type', ContextPad]
  };

  var _typeof$7 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var MARKER_OK$2 = 'connect-ok',
      MARKER_NOT_OK$2 = 'connect-not-ok';

  function Connect(eventBus, dragging, modeling, rules, canvas, graphicsFactory) {

    // TODO(nre): separate UI and events

    // rules

    function canConnect(source, target) {
      return rules.allowed('connection.create', {
        source: source,
        target: target
      });
    }

    // layouting

    function crop(start, end, source, target) {

      var sourcePath = graphicsFactory.getShapePath(source),
          targetPath = target && graphicsFactory.getShapePath(target),
          connectionPath = graphicsFactory.getConnectionPath({ waypoints: [start, end] });

      start = getElementLineIntersection(sourcePath, connectionPath, true) || start;
      end = target && getElementLineIntersection(targetPath, connectionPath, false) || end;

      return [start, end];
    }

    // event handlers

    eventBus.on('connect.move', function (event) {

      var context = event.context,
          source = context.source,
          target = context.target,
          visual = context.visual,
          sourcePosition = context.sourcePosition,
          endPosition,
          waypoints;

      // update connection visuals during drag

      endPosition = {
        x: event.x,
        y: event.y
      };

      waypoints = crop(sourcePosition, endPosition, source, target);

      attr$1(visual, { 'points': [waypoints[0].x, waypoints[0].y, waypoints[1].x, waypoints[1].y] });
    });

    eventBus.on('connect.hover', function (event) {
      var context = event.context,
          source = context.source,
          hover = event.hover,
          canExecute;

      canExecute = context.canExecute = canConnect(source, hover);

      // simply ignore hover
      if (canExecute === null) {
        return;
      }

      context.target = hover;

      canvas.addMarker(hover, canExecute ? MARKER_OK$2 : MARKER_NOT_OK$2);
    });

    eventBus.on(['connect.out', 'connect.cleanup'], function (event) {
      var context = event.context;

      if (context.target) {
        canvas.removeMarker(context.target, context.canExecute ? MARKER_OK$2 : MARKER_NOT_OK$2);
      }

      context.target = null;
      context.canExecute = false;
    });

    eventBus.on('connect.cleanup', function (event) {
      var context = event.context;

      if (context.visual) {
        remove$1(context.visual);
      }
    });

    eventBus.on('connect.start', function (event) {
      var context = event.context,
          visual;

      visual = create('polyline');
      attr$1(visual, {
        'stroke': '#333',
        'strokeDasharray': [1],
        'strokeWidth': 2,
        'pointer-events': 'none'
      });

      append(canvas.getDefaultLayer(), visual);

      context.visual = visual;
    });

    eventBus.on('connect.end', function (event) {

      var context = event.context,
          source = context.source,
          sourcePosition = context.sourcePosition,
          target = context.target,
          targetPosition = {
        x: event.x,
        y: event.y
      },
          canExecute = context.canExecute || canConnect(source, target);

      if (!canExecute) {
        return false;
      }

      var attrs = null,
          hints = {
        connectionStart: sourcePosition,
        connectionEnd: targetPosition
      };

      if ((typeof canExecute === 'undefined' ? 'undefined' : _typeof$7(canExecute)) === 'object') {
        attrs = canExecute;
      }

      modeling.connect(source, target, attrs, hints);
    });

    // API

    /**
     * Start connect operation.
     *
     * @param {DOMEvent} event
     * @param {djs.model.Base} source
     * @param {Point} [sourcePosition]
     * @param {Boolean} [autoActivate=false]
     */
    this.start = function (event, source, sourcePosition, autoActivate) {

      if ((typeof sourcePosition === 'undefined' ? 'undefined' : _typeof$7(sourcePosition)) !== 'object') {
        autoActivate = sourcePosition;
        sourcePosition = getMid(source);
      }

      dragging.init(event, 'connect', {
        autoActivate: autoActivate,
        data: {
          shape: source,
          context: {
            source: source,
            sourcePosition: sourcePosition
          }
        }
      });
    };
  }

  Connect.$inject = ['eventBus', 'dragging', 'modeling', 'rules', 'canvas', 'graphicsFactory'];

  var DiagramConnect = {
    __depends__: [DiagramSelection, Rules$1, DraggingModule],
    connect: ['type', Connect]
  };

  var LOW_PRIORITY$6 = 750;

  var MARKER_OK$3 = 'drop-ok',
      MARKER_NOT_OK$3 = 'drop-not-ok',
      MARKER_ATTACH$1 = 'attach-ok',
      MARKER_NEW_PARENT$1 = 'new-parent';

  /**
   * Adds the ability to create new shapes via drag and drop.
   *
   * Create must be activated via {@link Create#start}. From that
   * point on, create will invoke `shape.create` and `shape.attach`
   * rules to query whether or not creation or attachment on a certain
   * position is allowed.
   *
   * If create or attach is allowed and a source is given, Create it
   * will invoke `connection.create` rules to query whether a connection
   * can be drawn between source and new shape. During rule evaluation
   * the target is not attached yet, however
   *
   *   hints = { targetParent, targetAttach }
   *
   * are passed to the evaluating rules.
   *
   *
   * ## Rule Return Values
   *
   * Return values interpreted from  `shape.create`:
   *
   *   * `true`: create is allowed
   *   * `false`: create is disallowed
   *   * `null`: create is not allowed but should be ignored visually
   *
   * Return values interpreted from `shape.attach`:
   *
   *   * `true`: attach is allowed
   *   * `Any`: attach is allowed with the constraints
   *   * `false`: attach is disallowed
   *
   * Return values interpreted from `connection.create`:
   *
   *   * `true`: connection can be created
   *   * `Any`: connection with the given attributes can be created
   *   * `false`: connection can't be created
   *
   *
   * @param {EventBus} eventBus
   * @param {Dragging} dragging
   * @param {Rules} rules
   * @param {Modeling} modeling
   * @param {Canvas} canvas
   * @param {Styles} styles
   * @param {GraphicsFactory} graphicsFactory
   */
  function Create(eventBus, dragging, rules, modeling, canvas, styles, graphicsFactory) {

    // rules

    function canCreate(shape, target, source, position) {

      if (!target) {
        return false;
      }

      var ctx = {
        source: source,
        shape: shape,
        target: target,
        position: position
      };

      var create$$1, attach, connect;

      attach = rules.allowed('shape.attach', ctx);

      if (!attach) {
        create$$1 = rules.allowed('shape.create', ctx);
      }

      if (create$$1 || attach) {

        connect = source && rules.allowed('connection.create', {
          source: source,
          target: shape,
          hints: {
            targetParent: target,
            targetAttach: attach
          }
        });
      }

      if (create$$1 || attach) {
        return {
          attach: attach,
          connect: connect
        };
      }

      return false;
    }

    /** set drop marker on an element */
    function setMarker(element, marker) {

      [MARKER_ATTACH$1, MARKER_OK$3, MARKER_NOT_OK$3, MARKER_NEW_PARENT$1].forEach(function (m) {

        if (m === marker) {
          canvas.addMarker(element, m);
        } else {
          canvas.removeMarker(element, m);
        }
      });
    }

    // visual helpers

    function createVisual(shape) {
      var group, preview, visual;

      group = create('g');
      attr$1(group, styles.cls('djs-drag-group', ['no-events']));

      append(canvas.getDefaultLayer(), group);

      preview = create('g');
      classes$1(preview).add('djs-dragger');

      append(group, preview);

      translate(preview, shape.width / -2, shape.height / -2);

      var visualGroup = create('g');
      classes$1(visualGroup).add('djs-visual');

      append(preview, visualGroup);

      visual = visualGroup;

      // hijack renderer to draw preview
      graphicsFactory.drawShape(visual, shape);

      return group;
    }

    // event handlers

    eventBus.on('create.move', function (event) {

      var context = event.context,
          hover = event.hover,
          shape = context.shape,
          source = context.source,
          canExecute;

      var position = {
        x: event.x,
        y: event.y
      };

      canExecute = context.canExecute = hover && canCreate(shape, hover, source, position);

      // ignore hover visually if canExecute is null
      if (hover && canExecute !== null) {
        context.target = hover;

        if (canExecute && canExecute.attach) {
          setMarker(hover, MARKER_ATTACH$1);
        } else {
          setMarker(hover, canExecute ? MARKER_NEW_PARENT$1 : MARKER_NOT_OK$3);
        }
      }
    });

    eventBus.on('create.move', LOW_PRIORITY$6, function (event) {

      var context = event.context,
          shape = context.shape,
          visual = context.visual;

      // lazy init drag visual once we received the first real
      // drag move event (this allows us to get the proper canvas local coordinates)
      if (!visual) {
        visual = context.visual = createVisual(shape);
      }

      translate(visual, event.x, event.y);
    });

    eventBus.on(['create.end', 'create.out', 'create.cleanup'], function (event) {
      var context = event.context,
          target = context.target;

      if (target) {
        setMarker(target, null);
      }
    });

    eventBus.on('create.end', function (event) {
      var context = event.context,
          source = context.source,
          shape = context.shape,
          target = context.target,
          canExecute = context.canExecute,
          attach = canExecute && canExecute.attach,
          connect = canExecute && canExecute.connect,
          position = {
        x: event.x,
        y: event.y
      };

      if (!canExecute) {
        return false;
      }

      if (connect) {
        // invoke append if connect is set via rules
        shape = modeling.appendShape(source, shape, position, target, {
          attach: attach,
          connection: connect === true ? {} : connect
        });
      } else {
        // invoke create, if connect is not set
        shape = modeling.createShape(shape, position, target, {
          attach: attach
        });
      }

      // make sure we provide the actual attached
      // shape with the context so that selection and
      // other components can use it right after the create
      // operation ends
      context.shape = shape;
    });

    eventBus.on('create.cleanup', function (event) {
      var context = event.context;

      if (context.visual) {
        remove$1(context.visual);
      }
    });

    // API

    this.start = function (event, shape, source) {

      dragging.init(event, 'create', {
        cursor: 'grabbing',
        autoActivate: true,
        data: {
          shape: shape,
          context: {
            shape: shape,
            source: source
          }
        }
      });
    };
  }

  Create.$inject = ['eventBus', 'dragging', 'rules', 'modeling', 'canvas', 'styles', 'graphicsFactory'];

  var DiagramCreate = {
    __depends__: [DraggingModule, DiagramSelection, Rules$1],
    create: ['type', Create]
  };

  var DATA_REF = 'data-id';

  /**
   * A popup menu that can be used to display a list of actions anywhere in the canvas.
   *
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   *
   * @class
   * @constructor
   */
  function PopupMenu(eventBus, canvas) {

    this._eventBus = eventBus;
    this._canvas = canvas;
    this._providers = {};
    this._current = {};
  }

  PopupMenu.$inject = ['eventBus', 'canvas'];

  /**
   * Registers a popup menu provider
   *
   * @param  {String} id
   * @param  {Object} provider
   *
   * @example
   *
   * popupMenu.registerProvider('myMenuID', {
   *   getEntries: function(element) {
   *     return [
   *       {
   *         id: 'entry-1',
   *         label: 'My Entry',
   *         action: 'alert("I have been clicked!")'
   *       }
   *     ];
   *   }
   * });
   */
  PopupMenu.prototype.registerProvider = function (id, provider) {
    this._providers[id] = provider;
  };

  /**
   * Determine if the popup menu has entries.
   *
   * @return {Boolean} true if empty
   */
  PopupMenu.prototype.isEmpty = function (element, providerId) {
    if (!element) {
      throw new Error('element parameter is missing');
    }

    if (!providerId) {
      throw new Error('providerId parameter is missing');
    }

    var provider = this._providers[providerId];

    var entries = provider.getEntries(element),
        headerEntries = provider.getHeaderEntries && provider.getHeaderEntries(element);

    var hasEntries = entries.length > 0,
        hasHeaderEntries = headerEntries && headerEntries.length > 0;

    return !hasEntries && !hasHeaderEntries;
  };

  /**
   * Create entries and open popup menu at given position
   *
   * @param  {Object} element
   * @param  {String} id provider id
   * @param  {Object} position
   *
   * @return {Object} popup menu instance
   */
  PopupMenu.prototype.open = function (element, id, position) {

    var provider = this._providers[id];

    if (!element) {
      throw new Error('Element is missing');
    }

    if (!provider) {
      throw new Error('Provider is not registered: ' + id);
    }

    if (!position) {
      throw new Error('the position argument is missing');
    }

    if (this.isOpen()) {
      this.close();
    }

    this._emit('open');

    var current = this._current = {
      provider: provider,
      className: id,
      element: element,
      position: position
    };

    if (provider.getHeaderEntries) {
      current.headerEntries = provider.getHeaderEntries(element);
    }

    current.entries = provider.getEntries(element);

    current.container = this._createContainer();

    var headerEntries = current.headerEntries || [],
        entries = current.entries || [];

    if (headerEntries.length) {
      current.container.appendChild(this._createEntries(current.headerEntries, 'djs-popup-header'));
    }

    if (entries.length) {
      current.container.appendChild(this._createEntries(current.entries, 'djs-popup-body'));
    }

    var canvas = this._canvas,
        parent = canvas.getContainer();

    this._attachContainer(current.container, parent, position.cursor);
  };

  /**
   * Removes the popup menu and unbinds the event handlers.
   */
  PopupMenu.prototype.close = function () {

    if (!this.isOpen()) {
      return;
    }

    this._emit('close');

    this._unbindHandlers();
    remove(this._current.container);
    this._current.container = null;
  };

  /**
   * Determine if an open popup menu exist.
   *
   * @return {Boolean} true if open
   */
  PopupMenu.prototype.isOpen = function () {
    return !!this._current.container;
  };

  /**
   * Trigger an action associated with an entry.
   *
   * @param {Object} event
   *
   * @return the result of the action callback, if any
   */
  PopupMenu.prototype.trigger = function (event) {

    // silence other actions
    event.preventDefault();

    var element = event.delegateTarget || event.target,
        entryId = attr(element, DATA_REF);

    var entry = this._getEntry(entryId);

    if (entry.action) {
      return entry.action.call(null, event, entry);
    }
  };

  /**
   * Gets an entry instance (either entry or headerEntry) by id.
   *
   * @param  {String} entryId
   *
   * @return {Object} entry instance
   */
  PopupMenu.prototype._getEntry = function (entryId) {

    var search = matchPattern({ id: entryId });

    var entry = find(this._current.entries, search) || find(this._current.headerEntries, search);

    if (!entry) {
      throw new Error('entry not found');
    }

    return entry;
  };

  PopupMenu.prototype._emit = function (eventName) {
    this._eventBus.fire('popupMenu.' + eventName);
  };

  /**
   * Creates the popup menu container.
   *
   * @return {Object} a DOM container
   */
  PopupMenu.prototype._createContainer = function () {
    var container = domify('<div class="djs-popup">'),
        position = this._current.position,
        className = this._current.className;

    assign(container.style, {
      position: 'absolute',
      left: position.x + 'px',
      top: position.y + 'px',
      visibility: 'hidden'
    });

    classes(container).add(className);

    return container;
  };

  /**
   * Attaches the container to the DOM and binds the event handlers.
   *
   * @param {Object} container
   * @param {Object} parent
   */
  PopupMenu.prototype._attachContainer = function (container, parent, cursor) {
    var self = this;

    // Event handler
    delegateEvents.bind(container, '.entry', 'click', function (event) {
      self.trigger(event);
    });

    // apply canvas zoom level
    var zoom = this._canvas.zoom();

    container.style.transformOrigin = 'top left';
    container.style.transform = 'scale(' + zoom + ')';

    // Attach to DOM
    parent.appendChild(container);

    if (cursor) {
      this._assureIsInbounds(container, cursor);
    }

    // Add Handler
    this._bindHandlers();
  };

  /**
   * Make sure that the menu is always fully shown
   *
   * @method function
   *
   * @param  {Object} container
   * @param  {Position} cursor {x, y}
   */
  PopupMenu.prototype._assureIsInbounds = function (container, cursor) {
    var canvas = this._canvas,
        clientRect = canvas._container.getBoundingClientRect();

    var containerX = container.offsetLeft,
        containerY = container.offsetTop,
        containerWidth = container.scrollWidth,
        containerHeight = container.scrollHeight,
        overAxis = {},
        left,
        top;

    var cursorPosition = {
      x: cursor.x - clientRect.left,
      y: cursor.y - clientRect.top
    };

    if (containerX + containerWidth > clientRect.width) {
      overAxis.x = true;
    }

    if (containerY + containerHeight > clientRect.height) {
      overAxis.y = true;
    }

    if (overAxis.x && overAxis.y) {
      left = cursorPosition.x - containerWidth + 'px';
      top = cursorPosition.y - containerHeight + 'px';
    } else if (overAxis.x) {
      left = cursorPosition.x - containerWidth + 'px';
      top = cursorPosition.y + 'px';
    } else if (overAxis.y && cursorPosition.y < containerHeight) {
      left = cursorPosition.x + 'px';
      top = 10 + 'px';
    } else if (overAxis.y) {
      left = cursorPosition.x + 'px';
      top = cursorPosition.y - containerHeight + 'px';
    }

    assign(container.style, { left: left, top: top }, { visibility: 'visible', 'z-index': 1000 });
  };

  /**
   * Creates a list of entries and returns them as a DOM container.
   *
   * @param {Array<Object>} entries an array of entry objects
   * @param {String} className the class name of the entry container
   *
   * @return {Object} a DOM container
   */
  PopupMenu.prototype._createEntries = function (entries, className) {

    var entriesContainer = domify('<div>'),
        self = this;

    classes(entriesContainer).add(className);

    forEach(entries, function (entry) {
      var entryContainer = self._createEntry(entry, entriesContainer);
      entriesContainer.appendChild(entryContainer);
    });

    return entriesContainer;
  };

  /**
   * Creates a single entry and returns it as a DOM container.
   *
   * @param  {Object} entry
   *
   * @return {Object} a DOM container
   */
  PopupMenu.prototype._createEntry = function (entry) {

    if (!entry.id) {
      throw new Error('every entry must have the id property set');
    }

    var entryContainer = domify('<div>'),
        entryClasses = classes(entryContainer);

    entryClasses.add('entry');

    if (entry.className) {
      entry.className.split(' ').forEach(function (className) {
        entryClasses.add(className);
      });
    }

    attr(entryContainer, DATA_REF, entry.id);

    if (entry.label) {
      var label = domify('<span>');
      label.textContent = entry.label;
      entryContainer.appendChild(label);
    }

    if (entry.imageUrl) {
      entryContainer.appendChild(domify('<img src="' + entry.imageUrl + '" />'));
    }

    if (entry.active === true) {
      entryClasses.add('active');
    }

    if (entry.disabled === true) {
      entryClasses.add('disabled');
    }

    if (entry.title) {
      entryContainer.title = entry.title;
    }

    return entryContainer;
  };

  /**
   * Binds the `close` method to 'contextPad.close' & 'canvas.viewbox.changed'.
   */
  PopupMenu.prototype._bindHandlers = function () {

    var eventBus = this._eventBus,
        self = this;

    function close() {
      self.close();
    }

    eventBus.once('contextPad.close', close);
    eventBus.once('canvas.viewbox.changing', close);
    eventBus.once('commandStack.changed', close);
  };

  /**
   * Unbinds the `close` method to 'contextPad.close' & 'canvas.viewbox.changing'.
   */
  PopupMenu.prototype._unbindHandlers = function () {

    var eventBus = this._eventBus,
        self = this;

    function close() {
      self.close();
    }

    eventBus.off('contextPad.close', close);
    eventBus.off('canvas.viewbox.changed', close);
    eventBus.off('commandStack.changed', close);
  };

  var DiagramPopupMenu = {
    __init__: ['popupMenu'],
    popupMenu: ['type', PopupMenu]
  };

  var round$6 = Math.round;

  /**
   * Service that allow replacing of elements.
   */
  function Replace(modeling) {

    this._modeling = modeling;
  }

  Replace.$inject = ['modeling'];

  /**
   * @param {Element} oldElement - Element to be replaced
   * @param {Object}  newElementData - Containing information about the new Element, for example height, width, type.
   * @param {Object}  options - Custom options that will be attached to the context. It can be used to inject data
   *                            that is needed in the command chain. For example it could be used in
   *                            eventbus.on('commandStack.shape.replace.postExecute') to change shape attributes after
   *                            shape creation.
   */
  Replace.prototype.replaceElement = function (oldElement, newElementData, options) {

    var modeling = this._modeling;

    var newElement = null;

    if (oldElement.waypoints) {
      // TODO
      // modeling.replaceConnection
    } else {
      // set center of element for modeling API
      // if no new width / height is given use old elements size
      newElementData.x = round$6(oldElement.x + (newElementData.width || oldElement.width) / 2);
      newElementData.y = round$6(oldElement.y + (newElementData.height || oldElement.height) / 2);

      newElement = modeling.replaceShape(oldElement, newElementData, options);
    }

    return newElement;
  };

  var DiagramReplace = {
    __init__: ['replace'],
    replace: ['type', Replace]
  };

  /**
   * This module takes care of replacing DRD elements
   */
  function DrdReplace(drdFactory, replace, selection, modeling) {

    /**
     * Prepares a new business object for the replacement element
     * and triggers the replace operation.
     *
     * @param  {djs.model.Base} element
     * @param  {Object} target
     * @param  {Object} [hints]
     *
     * @return {djs.model.Base} the newly created element
     */
    function replaceElement(element, target, hints) {

      hints = hints || {};

      var type = target.type,
          oldBusinessObject = element.businessObject;

      var newBusinessObject = drdFactory.create(type);

      var newElement = {
        type: type,
        businessObject: newBusinessObject
      };

      newElement.width = element.width;
      newElement.height = element.height;

      newBusinessObject.name = oldBusinessObject.name;

      if (target.table) {
        var table = drdFactory.create('dmn:DecisionTable');
        newBusinessObject.decisionTable = table;
        table.$parent = newBusinessObject;

        var output = drdFactory.create('dmn:OutputClause');
        output.typeRef = 'string';
        output.$parent = table;
        table.output = [output];

        var input = drdFactory.create('dmn:InputClause');
        input.$parent = table;

        var inputExpression = drdFactory.create('dmn:LiteralExpression', {
          typeRef: 'string'
        });

        input.inputExpression = inputExpression;
        inputExpression.$parent = input;

        table.input = [input];
      }

      if (target.expression) {
        newBusinessObject.literalExpression = drdFactory.create('dmn:LiteralExpression');
        newBusinessObject.variable = drdFactory.create('dmn:InformationItem');
      }

      return replace.replaceElement(element, newElement, hints);
    }

    this.replaceElement = replaceElement;
  }

  DrdReplace.$inject = ['drdFactory', 'replace', 'selection', 'modeling'];

  var Replace$1 = {
    __depends__: [DiagramReplace, DiagramSelection],
    drdReplace: ['type', DrdReplace]
  };

  var replaceOptions = {
    DECISION: [{
      label: 'Empty',
      actionName: 'replace-with-empty-decision',
      className: 'dmn-icon-clear',
      target: {
        type: 'dmn:Decision',
        table: false,
        expression: false
      }
    }, {
      label: 'Decision Table',
      actionName: 'replace-with-decision-table',
      className: 'dmn-icon-decision-table',
      target: {
        type: 'dmn:Decision',
        table: true,
        expression: false
      }
    }, {
      label: 'Literal Expression',
      actionName: 'replace-with-literal-expression',
      className: 'dmn-icon-literal-expression',
      target: {
        type: 'dmn:Decision',
        table: false,
        expression: true
      }
    }]
  };

  /**
   * This module is an element agnostic replace menu provider for the popup menu.
   */
  function ReplaceMenuProvider(popupMenu, modeling, moddle, drdReplace, rules, translate) {

    this._popupMenu = popupMenu;
    this._modeling = modeling;
    this._moddle = moddle;
    this._drdReplace = drdReplace;
    this._rules = rules;
    this._translate = translate;

    this.register();
  }

  ReplaceMenuProvider.$inject = ['popupMenu', 'modeling', 'moddle', 'drdReplace', 'rules', 'translate'];

  /**
   * Register replace menu provider in the popup menu
   */
  ReplaceMenuProvider.prototype.register = function () {
    this._popupMenu.registerProvider('dmn-replace', this);
  };

  /**
   * Get all entries from replaceOptions for the given element.
   *
   * @param {djs.model.Base} element
   *
   * @return {Array<Object>} a list of menu entry items
   */
  ReplaceMenuProvider.prototype.getEntries = function (element) {

    var businessObject = element.businessObject;

    var rules = this._rules;

    if (!rules.allowed('shape.replace', { element: element })) {
      return [];
    }

    if (is(businessObject, 'dmn:Decision')) {

      var options = filter(replaceOptions.DECISION, function (option) {
        var notEmpty = option.actionName === 'replace-with-empty-decision' && (businessObject.decisionTable || businessObject.literalExpression);
        var notTable = option.actionName === 'replace-with-decision-table' && !businessObject.decisionTable;
        var notExp = option.actionName === 'replace-with-literal-expression' && !businessObject.literalExpression;

        return notEmpty || notTable || notExp;
      });

      return this._createEntries(element, options);
    }

    return [];
  };

  /**
   * Creates an array of menu entry objects for a given element.
   *
   * @param  {djs.model.Base} element
   * @param  {Object} replaceOptions
   *
   * @return {Array<Object>} a list of menu items
   */
  ReplaceMenuProvider.prototype._createEntries = function (element, replaceOptions$$1) {
    var menuEntries = [];

    var self = this;

    forEach(replaceOptions$$1, function (definition) {
      var entry = self._createMenuEntry(definition, element);

      menuEntries.push(entry);
    });

    return menuEntries;
  };

  /**
   * Creates and returns a single menu entry item.
   *
   * @param  {Object} definition a single replace options definition object
   * @param  {djs.model.Base} element
   * @param  {Function} [action] an action callback function which gets called when
   *                             the menu entry is being triggered.
   *
   * @return {Object} menu entry item
   */
  ReplaceMenuProvider.prototype._createMenuEntry = function (definition, element, action) {
    var replaceElement = this._drdReplace.replaceElement;
    var translate = this._translate;

    var replaceAction = function replaceAction() {
      return replaceElement(element, definition.target);
    };

    action = action || replaceAction;

    var menuEntry = {
      label: translate(definition.label),
      className: definition.className,
      id: definition.actionName,
      action: action
    };

    return menuEntry;
  };

  ReplaceMenuProvider.prototype.getHeaderEntries = function (element) {
    return [];
  };

  var PopupMenu$1 = {
    __depends__: [DiagramTranslate, DiagramPopupMenu, Replace$1],
    __init__: ['replaceMenuProvider'],
    replaceMenuProvider: ['type', ReplaceMenuProvider]
  };

  /**
  * A provider for DMN 1.1 elements context pad
  */
  function ContextPadProvider(eventBus, contextPad, modeling, elementFactory, connect, create, rules, popupMenu, canvas, translate) {

    contextPad.registerProvider(this);

    this._contextPad = contextPad;

    this._modeling = modeling;

    this._elementFactory = elementFactory;
    this._connect = connect;
    this._create = create;
    this._rules = rules;
    this._popupMenu = popupMenu;
    this._canvas = canvas;
    this._translate = translate;

    eventBus.on('create.end', 250, function (event) {
      var shape = event.context.shape;

      if (!hasPrimaryModifier(event)) {
        return;
      }

      var entries = contextPad.getEntries(shape);

      if (entries.replace) {
        entries.replace.action.click(event, shape);
      }
    });
  }

  ContextPadProvider.$inject = ['eventBus', 'contextPad', 'modeling', 'elementFactory', 'connect', 'create', 'rules', 'popupMenu', 'canvas', 'translate'];

  ContextPadProvider.prototype.getContextPadEntries = function (element) {

    var modeling = this._modeling,
        elementFactory = this._elementFactory,
        connect = this._connect,
        create = this._create,
        popupMenu = this._popupMenu,
        canvas = this._canvas,
        contextPad = this._contextPad,
        rules = this._rules,
        translate = this._translate;

    var actions = {};

    if (element.type === 'label') {
      return actions;
    }

    var businessObject = element.businessObject;

    function startConnect(event, element, autoActivate) {
      connect.start(event, element, autoActivate);
    }

    function removeElement(e) {
      modeling.removeElements([element]);
    }

    function getReplaceMenuPosition(element) {

      var Y_OFFSET = 5;

      var diagramContainer = canvas.getContainer(),
          pad = contextPad.getPad(element).html;

      var diagramRect = diagramContainer.getBoundingClientRect(),
          padRect = pad.getBoundingClientRect();

      var top = padRect.top - diagramRect.top;
      var left = padRect.left - diagramRect.left;

      var pos = {
        x: left,
        y: top + padRect.height + Y_OFFSET
      };

      return pos;
    }

    /**
    * Create an append action
    *
    * @param {String} type
    * @param {String} className
    * @param {String} [title]
    * @param {Object} [options]
    *
    * @return {Object} descriptor
    */
    function appendAction(type, className, title, options) {

      if (typeof title !== 'string') {
        options = title;
        title = translate('Append {type}', { type: type.replace(/^dmn:/, '') });
      }

      function appendListener(event, element) {

        var shape = elementFactory.createShape(assign({ type: type }, options));
        create.start(event, shape, element);
      }

      return {
        group: 'model',
        className: className,
        title: title,
        action: {
          dragstart: appendListener,
          click: appendListener
        }
      };
    }

    if (isAny(businessObject, ['dmn:InputData', 'dmn:BusinessKnowledgeModel', 'dmn:KnowledgeSource', 'dmn:Decision'])) {
      assign(actions, {
        'append.decision': appendAction('dmn:Decision', 'dmn-icon-decision')
      });
    }

    if (isAny(businessObject, ['dmn:InputData', 'dmn:Decision', 'dmn:KnowledgeSource'])) {
      assign(actions, {
        'append.knowledge-source': appendAction('dmn:KnowledgeSource', 'dmn-icon-knowledge-source')
      });
    }

    if (isAny(businessObject, ['dmn:BusinessKnowledgeModel', 'dmn:KnowledgeSource'])) {
      assign(actions, {
        'append.business-knowledge-model': appendAction('dmn:BusinessKnowledgeModel', 'dmn-icon-business-knowledge')
      });
    }

    if (isAny(businessObject, ['dmn:Decision'])) {
      assign(actions, {
        'append.input-data': appendAction('dmn:InputData', 'dmn-icon-input-data')
      });
    }

    if (is(businessObject, 'dmn:DRGElement')) {

      assign(actions, {
        'append.text-annotation': appendAction('dmn:TextAnnotation', 'dmn-icon-text-annotation'),

        'connect': {
          group: 'connect',
          className: 'dmn-icon-connection-multi',
          title: translate('Connect using Information/Knowledge' + '/Authority Requirement or Association'),
          action: {
            click: startConnect,
            dragstart: startConnect
          }
        }
      });
    }

    if (!popupMenu.isEmpty(element, 'dmn-replace')) {

      // Replace menu entry
      assign(actions, {
        'replace': {
          group: 'edit',
          className: 'dmn-icon-screw-wrench',
          title: translate('Change type'),
          action: {
            click: function click(event, element) {

              var position = assign(getReplaceMenuPosition(element), {
                cursor: { x: event.x, y: event.y }
              });

              popupMenu.open(element, 'dmn-replace', position);
            }
          }
        }
      });
    }

    // delete element entry, only show if allowed by rules
    var deleteAllowed = rules.allowed('elements.delete', { elements: [element] });

    if (isArray(deleteAllowed)) {
      // was the element returned as a deletion candidate?
      deleteAllowed = deleteAllowed[0] === element;
    }

    if (deleteAllowed) {
      assign(actions, {
        'delete': {
          group: 'edit',
          className: 'dmn-icon-trash',
          title: translate('Remove'),
          action: {
            click: removeElement
          }
        }
      });
    }

    return actions;
  };

  var ContextPadModule = {
    __depends__: [DiagramTranslate, DiagramContextPad, DiagramSelection, DiagramConnect, DiagramCreate, PopupMenu$1],
    __init__: ['contextPadProvider'],
    contextPadProvider: ['type', ContextPadProvider]
  };

  /**
   * A keyboard abstraction that may be activated and
   * deactivated by users at will, consuming key events
   * and triggering diagram actions.
   *
   * The implementation fires the following key events that allow
   * other components to hook into key handling:
   *
   *  - keyboard.bind
   *  - keyboard.unbind
   *  - keyboard.init
   *  - keyboard.destroy
   *
   * All events contain the fields (node, listeners).
   *
   * A default binding for the keyboard may be specified via the
   * `keyboard.bindTo` configuration option.
   *
   * @param {Config} config
   * @param {EventBus} eventBus
   * @param {EditorActions} editorActions
   */
  function Keyboard(config, eventBus, editorActions) {
    var self = this;

    this._config = config || {};
    this._eventBus = eventBus;
    this._editorActions = editorActions;

    this._listeners = [];

    // our key handler is a singleton that passes
    // (keycode, modifiers) to each listener.
    //
    // listeners must indicate that they handled a key event
    // by returning true. This stops the event propagation.
    //
    this._keyHandler = function (event$$1) {

      var i,
          l,
          target = event$$1.target,
          listeners = self._listeners,
          code = event$$1.keyCode || event$$1.charCode || -1;

      if (target && (matchesSelector$1(target, 'input, textarea') || target.contentEditable === 'true')) {
        return;
      }

      for (i = 0; l = listeners[i]; i++) {
        if (l(code, event$$1)) {
          event$$1.preventDefault();
          event$$1.stopPropagation();
        }
      }
    };

    // properly clean dom registrations
    eventBus.on('diagram.destroy', function () {
      self._fire('destroy');

      self.unbind();
      self._listeners = null;
    });

    eventBus.on('diagram.init', function () {
      self._fire('init');
    });

    eventBus.on('attach', function () {
      if (config && config.bindTo) {
        self.bind(config.bindTo);
      }
    });

    eventBus.on('detach', function () {
      self.unbind();
    });

    this._init();
  }

  Keyboard.$inject = ['config.keyboard', 'eventBus', 'editorActions'];

  Keyboard.prototype.bind = function (node) {
    // make sure that the keyboard is only bound once to the DOM
    this.unbind();

    this._node = node;

    // bind key events
    componentEvent.bind(node, 'keydown', this._keyHandler, true);

    this._fire('bind');
  };

  Keyboard.prototype.getBinding = function () {
    return this._node;
  };

  Keyboard.prototype.unbind = function () {
    var node = this._node;

    if (node) {
      this._fire('unbind');

      // unbind key events
      componentEvent.unbind(node, 'keydown', this._keyHandler, true);
    }

    this._node = null;
  };

  Keyboard.prototype._fire = function (event$$1) {
    this._eventBus.fire('keyboard.' + event$$1, { node: this._node, listeners: this._listeners });
  };

  Keyboard.prototype._init = function () {

    var listeners = this._listeners;

    var editorActions = this._editorActions,
        config = this._config;

    // init default listeners

    // undo
    // (CTRL|CMD) + Z
    function undo(key, modifiers) {

      if (isCmd(modifiers) && !isShift(modifiers) && key === 90) {
        editorActions.trigger('undo');

        return true;
      }
    }

    // redo
    // CTRL + Y
    // CMD + SHIFT + Z
    function redo(key, modifiers) {

      if (isCmd(modifiers) && (key === 89 || key === 90 && isShift(modifiers))) {
        editorActions.trigger('redo');

        return true;
      }
    }

    // copy
    // CTRL/CMD + C
    function copy(key, modifiers) {

      if (isCmd(modifiers) && key === 67) {
        editorActions.trigger('copy');

        return true;
      }
    }

    // paste
    // CTRL/CMD + V
    function paste(key, modifiers) {

      if (isCmd(modifiers) && key === 86) {
        editorActions.trigger('paste');

        return true;
      }
    }

    /**
     * zoom in one step
     * CTRL + +
     *
     * 107 = numpad plus
     * 187 = regular plus
     * 171 = regular plus in Firefox (german keyboard layout)
     *  61 = regular plus in Firefox (US keyboard layout)
     */
    function zoomIn(key, modifiers) {

      if ((key === 107 || key === 187 || key === 171 || key === 61) && isCmd(modifiers)) {
        editorActions.trigger('stepZoom', { value: 1 });

        return true;
      }
    }

    /**
     * zoom out one step
     * CTRL + -
     *
     * 109 = numpad minus
     * 189 = regular minus
     * 173 = regular minus in Firefox (US and german keyboard layout)
     */
    function zoomOut(key, modifiers) {

      if ((key === 109 || key === 189 || key === 173) && isCmd(modifiers)) {
        editorActions.trigger('stepZoom', { value: -1 });

        return true;
      }
    }

    /**
     * zoom to the default level
     * CTRL + 0
     *
     * 96 = numpad zero
     * 48 = regular zero
     */
    function zoomDefault(key, modifiers) {

      if ((key === 96 || key === 48) && isCmd(modifiers)) {
        editorActions.trigger('zoom', { value: 1 });

        return true;
      }
    }

    // delete selected element
    // DEL
    function removeSelection(key, modifiers) {

      if (key === 46) {
        editorActions.trigger('removeSelection');

        return true;
      }
    }

    // move canvas left
    // left arrow
    //
    // 37 = Left
    // 38 = Up
    // 39 = Right
    // 40 = Down
    function moveCanvas(key, modifiers) {

      if ([37, 38, 39, 40].indexOf(key) >= 0) {

        var opts = {
          invertY: config.invertY,
          speed: config.speed || 50
        };

        switch (key) {
          case 37:
            // Left
            opts.direction = 'left';
            break;
          case 38:
            // Up
            opts.direction = 'up';
            break;
          case 39:
            // Right
            opts.direction = 'right';
            break;
          case 40:
            // Down
            opts.direction = 'down';
            break;
        }

        editorActions.trigger('moveCanvas', opts);

        return true;
      }
    }

    listeners.push(undo);
    listeners.push(redo);
    listeners.push(copy);
    listeners.push(paste);
    listeners.push(removeSelection);
    listeners.push(zoomIn);
    listeners.push(zoomOut);
    listeners.push(zoomDefault);
    listeners.push(moveCanvas);
  };

  /**
   * Add a listener function that is notified with (key, modifiers) whenever
   * the keyboard is bound and the user presses a key.
   *
   * @param {Function} listenerFn
   */
  Keyboard.prototype.addListener = function (listenerFn) {
    this._listeners.push(listenerFn);
  };

  Keyboard.prototype.hasModifier = hasModifier;
  Keyboard.prototype.isCmd = isCmd;
  Keyboard.prototype.isShift = isShift;

  function hasModifier(modifiers) {
    return modifiers.ctrlKey || modifiers.metaKey || modifiers.shiftKey || modifiers.altKey;
  }

  function isCmd(modifiers) {
    // ensure we don't react to AltGr
    // (mapped to CTRL + ALT)
    if (modifiers.altKey) {
      return false;
    }

    return modifiers.ctrlKey || modifiers.metaKey;
  }

  function isShift(modifiers) {
    return modifiers.shiftKey;
  }

  var DiagramKeyboard = {
    __init__: ['keyboard'],
    keyboard: ['type', Keyboard]
  };

  /**
   * DRD specific key bindings.
   *
   * @param {Keyboard} keyboard
   * @param {EditorActions} editorActions
   */
  function DrdKeyBindings(keyboard, editorActions) {

    keyboard.addListener(function (key, modifiers) {

      // ctrl + a -> select all elements
      if (key === 65 && keyboard.isCmd(modifiers)) {
        editorActions.trigger('selectElements');

        return true;
      }

      if (keyboard.hasModifier(modifiers)) {
        return;
      }

      // l -> activate lasso tool
      if (key === 76) {
        editorActions.trigger('lassoTool');

        return true;
      }

      // e -> activate direct editing
      if (key === 69) {
        editorActions.trigger('directEditing');

        return true;
      }
    });
  }

  DrdKeyBindings.$inject = ['keyboard', 'editorActions'];

  var KeyboardModule = {
    __depends__: [DiagramKeyboard],
    __init__: ['drdKeyBindings'],
    drdKeyBindings: ['type', DrdKeyBindings]
  };

  /**
   * A service that offers un- and redoable execution of commands.
   *
   * The command stack is responsible for executing modeling actions
   * in a un- and redoable manner. To do this it delegates the actual
   * command execution to {@link CommandHandler}s.
   *
   * Command handlers provide {@link CommandHandler#execute(ctx)} and
   * {@link CommandHandler#revert(ctx)} methods to un- and redo a command
   * identified by a command context.
   *
   *
   * ## Life-Cycle events
   *
   * In the process the command stack fires a number of life-cycle events
   * that other components to participate in the command execution.
   *
   *    * preExecute
   *    * preExecuted
   *    * execute
   *    * executed
   *    * postExecute
   *    * postExecuted
   *    * revert
   *    * reverted
   *
   * A special event is used for validating, whether a command can be
   * performed prior to its execution.
   *
   *    * canExecute
   *
   * Each of the events is fired as `commandStack.{eventName}` and
   * `commandStack.{commandName}.{eventName}`, respectively. This gives
   * components fine grained control on where to hook into.
   *
   * The event object fired transports `command`, the name of the
   * command and `context`, the command context.
   *
   *
   * ## Creating Command Handlers
   *
   * Command handlers should provide the {@link CommandHandler#execute(ctx)}
   * and {@link CommandHandler#revert(ctx)} methods to implement
   * redoing and undoing of a command.
   *
   * A command handler _must_ ensure undo is performed properly in order
   * not to break the undo chain. It must also return the shapes that
   * got changed during the `execute` and `revert` operations.
   *
   * Command handlers may execute other modeling operations (and thus
   * commands) in their `preExecute` and `postExecute` phases. The command
   * stack will properly group all commands together into a logical unit
   * that may be re- and undone atomically.
   *
   * Command handlers must not execute other commands from within their
   * core implementation (`execute`, `revert`).
   *
   *
   * ## Change Tracking
   *
   * During the execution of the CommandStack it will keep track of all
   * elements that have been touched during the command's execution.
   *
   * At the end of the CommandStack execution it will notify interested
   * components via an 'elements.changed' event with all the dirty
   * elements.
   *
   * The event can be picked up by components that are interested in the fact
   * that elements have been changed. One use case for this is updating
   * their graphical representation after moving / resizing or deletion.
   *
   * @see CommandHandler
   *
   * @param {EventBus} eventBus
   * @param {Injector} injector
   */
  function CommandStack(eventBus, injector) {

    /**
     * A map of all registered command handlers.
     *
     * @type {Object}
     */
    this._handlerMap = {};

    /**
     * A stack containing all re/undoable actions on the diagram
     *
     * @type {Array<Object>}
     */
    this._stack = [];

    /**
     * The current index on the stack
     *
     * @type {Number}
     */
    this._stackIdx = -1;

    /**
     * Current active commandStack execution
     *
     * @type {Object}
     */
    this._currentExecution = {
      actions: [],
      dirty: []
    };

    this._injector = injector;
    this._eventBus = eventBus;

    this._uid = 1;

    eventBus.on(['diagram.destroy', 'diagram.clear'], function () {
      this.clear(false);
    }, this);
  }

  CommandStack.$inject = ['eventBus', 'injector'];

  /**
   * Execute a command
   *
   * @param {String} command the command to execute
   * @param {Object} context the environment to execute the command in
   */
  CommandStack.prototype.execute = function (command, context) {
    if (!command) {
      throw new Error('command required');
    }

    var action = { command: command, context: context };

    this._pushAction(action);
    this._internalExecute(action);
    this._popAction(action);
  };

  /**
   * Ask whether a given command can be executed.
   *
   * Implementors may hook into the mechanism on two ways:
   *
   *   * in event listeners:
   *
   *     Users may prevent the execution via an event listener.
   *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.
   *
   *   * in command handlers:
   *
   *     If the method {@link CommandHandler#canExecute} is implemented in a handler
   *     it will be called to figure out whether the execution is allowed.
   *
   * @param  {String} command the command to execute
   * @param  {Object} context the environment to execute the command in
   *
   * @return {Boolean} true if the command can be executed
   */
  CommandStack.prototype.canExecute = function (command, context) {

    var action = { command: command, context: context };

    var handler = this._getHandler(command);

    var result = this._fire(command, 'canExecute', action);

    // handler#canExecute will only be called if no listener
    // decided on a result already
    if (result === undefined) {
      if (!handler) {
        return false;
      }

      if (handler.canExecute) {
        result = handler.canExecute(context);
      }
    }

    return result;
  };

  /**
   * Clear the command stack, erasing all undo / redo history
   */
  CommandStack.prototype.clear = function (emit) {
    this._stack.length = 0;
    this._stackIdx = -1;

    if (emit !== false) {
      this._fire('changed');
    }
  };

  /**
   * Undo last command(s)
   */
  CommandStack.prototype.undo = function () {
    var action = this._getUndoAction(),
        next;

    if (action) {
      this._pushAction(action);

      while (action) {
        this._internalUndo(action);
        next = this._getUndoAction();

        if (!next || next.id !== action.id) {
          break;
        }

        action = next;
      }

      this._popAction();
    }
  };

  /**
   * Redo last command(s)
   */
  CommandStack.prototype.redo = function () {
    var action = this._getRedoAction(),
        next;

    if (action) {
      this._pushAction(action);

      while (action) {
        this._internalExecute(action, true);
        next = this._getRedoAction();

        if (!next || next.id !== action.id) {
          break;
        }

        action = next;
      }

      this._popAction();
    }
  };

  /**
   * Register a handler instance with the command stack
   *
   * @param {String} command
   * @param {CommandHandler} handler
   */
  CommandStack.prototype.register = function (command, handler) {
    this._setHandler(command, handler);
  };

  /**
   * Register a handler type with the command stack
   * by instantiating it and injecting its dependencies.
   *
   * @param {String} command
   * @param {Function} a constructor for a {@link CommandHandler}
   */
  CommandStack.prototype.registerHandler = function (command, handlerCls) {

    if (!command || !handlerCls) {
      throw new Error('command and handlerCls must be defined');
    }

    var handler = this._injector.instantiate(handlerCls);
    this.register(command, handler);
  };

  CommandStack.prototype.canUndo = function () {
    return !!this._getUndoAction();
  };

  CommandStack.prototype.canRedo = function () {
    return !!this._getRedoAction();
  };

  // stack access  //////////////////////

  CommandStack.prototype._getRedoAction = function () {
    return this._stack[this._stackIdx + 1];
  };

  CommandStack.prototype._getUndoAction = function () {
    return this._stack[this._stackIdx];
  };

  // internal functionality //////////////////////

  CommandStack.prototype._internalUndo = function (action) {
    var self = this;

    var command = action.command,
        context = action.context;

    var handler = this._getHandler(command);

    // guard against illegal nested command stack invocations
    this._atomicDo(function () {
      self._fire(command, 'revert', action);

      if (handler.revert) {
        self._markDirty(handler.revert(context));
      }

      self._revertedAction(action);

      self._fire(command, 'reverted', action);
    });
  };

  CommandStack.prototype._fire = function (command, qualifier, event) {
    if (arguments.length < 3) {
      event = qualifier;
      qualifier = null;
    }

    var names = qualifier ? [command + '.' + qualifier, qualifier] : [command],
        i,
        name,
        result;

    event = this._eventBus.createEvent(event);

    for (i = 0; name = names[i]; i++) {
      result = this._eventBus.fire('commandStack.' + name, event);

      if (event.cancelBubble) {
        break;
      }
    }

    return result;
  };

  CommandStack.prototype._createId = function () {
    return this._uid++;
  };

  CommandStack.prototype._atomicDo = function (fn) {

    var execution = this._currentExecution;

    execution.atomic = true;

    try {
      fn();
    } finally {
      execution.atomic = false;
    }
  };

  CommandStack.prototype._internalExecute = function (action, redo) {
    var self = this;

    var command = action.command,
        context = action.context;

    var handler = this._getHandler(command);

    if (!handler) {
      throw new Error('no command handler registered for <' + command + '>');
    }

    this._pushAction(action);

    if (!redo) {
      this._fire(command, 'preExecute', action);

      if (handler.preExecute) {
        handler.preExecute(context);
      }

      this._fire(command, 'preExecuted', action);
    }

    // guard against illegal nested command stack invocations
    this._atomicDo(function () {

      self._fire(command, 'execute', action);

      if (handler.execute) {
        // actual execute + mark return results as dirty
        self._markDirty(handler.execute(context));
      }

      // log to stack
      self._executedAction(action, redo);

      self._fire(command, 'executed', action);
    });

    if (!redo) {
      this._fire(command, 'postExecute', action);

      if (handler.postExecute) {
        handler.postExecute(context);
      }

      this._fire(command, 'postExecuted', action);
    }

    this._popAction(action);
  };

  CommandStack.prototype._pushAction = function (action) {

    var execution = this._currentExecution,
        actions = execution.actions;

    var baseAction = actions[0];

    if (execution.atomic) {
      throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');
    }

    if (!action.id) {
      action.id = baseAction && baseAction.id || this._createId();
    }

    actions.push(action);
  };

  CommandStack.prototype._popAction = function () {
    var execution = this._currentExecution,
        actions = execution.actions,
        dirty = execution.dirty;

    actions.pop();

    if (!actions.length) {
      this._eventBus.fire('elements.changed', { elements: uniqueBy('id', dirty) });

      dirty.length = 0;

      this._fire('changed');
    }
  };

  CommandStack.prototype._markDirty = function (elements) {
    var execution = this._currentExecution;

    if (!elements) {
      return;
    }

    elements = isArray(elements) ? elements : [elements];

    execution.dirty = execution.dirty.concat(elements);
  };

  CommandStack.prototype._executedAction = function (action, redo) {
    var stackIdx = ++this._stackIdx;

    if (!redo) {
      this._stack.splice(stackIdx, this._stack.length, action);
    }
  };

  CommandStack.prototype._revertedAction = function (action) {
    this._stackIdx--;
  };

  CommandStack.prototype._getHandler = function (command) {
    return this._handlerMap[command];
  };

  CommandStack.prototype._setHandler = function (command, handler) {
    if (!command || !handler) {
      throw new Error('command and handler required');
    }

    if (this._handlerMap[command]) {
      throw new Error('overriding handler for command <' + command + '>');
    }

    this._handlerMap[command] = handler;
  };

  var CommandStack$1 = {
    commandStack: ['type', CommandStack]
  };

  /**
   * Adds change support to the diagram, including
   *
   * <ul>
   *   <li>redrawing shapes and connections on change</li>
   * </ul>
   *
   * @param {EventBus} eventBus
   * @param {Canvas} canvas
   * @param {ElementRegistry} elementRegistry
   * @param {GraphicsFactory} graphicsFactory
   */
  function ChangeSupport(eventBus, canvas, elementRegistry, graphicsFactory) {

    // redraw shapes / connections on change

    eventBus.on('element.changed', function (event) {

      var element = event.element;

      // element might have been deleted and replaced by new element with same ID
      // thus check for parent of element except for root element
      if (element.parent || element === canvas.getRootElement()) {
        event.gfx = elementRegistry.getGraphics(element);
      }

      // shape + gfx may have been deleted
      if (!event.gfx) {
        return;
      }

      eventBus.fire(getType(element) + '.changed', event);
    });

    eventBus.on('elements.changed', function (event) {

      var elements = event.elements;

      elements.forEach(function (e) {
        eventBus.fire('element.changed', { element: e });
      });

      graphicsFactory.updateContainments(elements);
    });

    eventBus.on('shape.changed', function (event) {
      graphicsFactory.update('shape', event.element, event.gfx);
    });

    eventBus.on('connection.changed', function (event) {
      graphicsFactory.update('connection', event.element, event.gfx);
    });
  }

  ChangeSupport.$inject = ['eventBus', 'canvas', 'elementRegistry', 'graphicsFactory'];

  var DiagramChangeSupport = {
    __init__: ['changeSupport'],
    changeSupport: ['type', ChangeSupport]
  };

  var min = Math.min,
      max$1 = Math.max;

  function preventDefault$1(e) {
    e.preventDefault();
  }

  function stopPropagation$1(e) {
    e.stopPropagation();
  }

  function isTextNode(node) {
    return node.nodeType === Node.TEXT_NODE;
  }

  function toArray(nodeList) {
    return [].slice.call(nodeList);
  }

  /**
   * Initializes a container for a content editable div.
   *
   * Structure:
   *
   * container
   *   parent
   *     content
   *     resize-handle
   *
   * @param {object} options
   * @param {DOMElement} options.container The DOM element to append the contentContainer to
   * @param {Function} options.keyHandler Handler for key events
   * @param {Function} options.resizeHandler Handler for resize events
   */
  function TextBox(options) {
    this.container = options.container;

    this.parent = domify('<div class="djs-direct-editing-parent">' + '<div class="djs-direct-editing-content" contenteditable="true"></div>' + '</div>');

    this.content = query('[contenteditable]', this.parent);

    this.keyHandler = options.keyHandler || function () {};
    this.resizeHandler = options.resizeHandler || function () {};

    this.autoResize = bind(this.autoResize, this);
    this.handlePaste = bind(this.handlePaste, this);
  }

  /**
   * Create a text box with the given position, size, style and text content
   *
   * @param {Object} bounds
   * @param {Number} bounds.x absolute x position
   * @param {Number} bounds.y absolute y position
   * @param {Number} [bounds.width] fixed width value
   * @param {Number} [bounds.height] fixed height value
   * @param {Number} [bounds.maxWidth] maximum width value
   * @param {Number} [bounds.maxHeight] maximum height value
   * @param {Number} [bounds.minWidth] minimum width value
   * @param {Number} [bounds.minHeight] minimum height value
   * @param {Object} [style]
   * @param {String} value text content
   *
   * @return {DOMElement} The created content DOM element
   */
  TextBox.prototype.create = function (bounds, style, value, options) {
    var self = this;

    var parent = this.parent,
        content = this.content,
        container = this.container;

    options = this.options = options || {};

    style = this.style = style || {};

    var parentStyle = pick(style, ['width', 'height', 'maxWidth', 'maxHeight', 'minWidth', 'minHeight', 'left', 'top', 'backgroundColor', 'position', 'overflow', 'border', 'wordWrap', 'textAlign', 'outline', 'transform']);

    assign(parent.style, {
      width: bounds.width + 'px',
      height: bounds.height + 'px',
      maxWidth: bounds.maxWidth + 'px',
      maxHeight: bounds.maxHeight + 'px',
      minWidth: bounds.minWidth + 'px',
      minHeight: bounds.minHeight + 'px',
      left: bounds.x + 'px',
      top: bounds.y + 'px',
      backgroundColor: '#ffffff',
      position: 'absolute',
      overflow: 'visible',
      border: '1px solid #ccc',
      boxSizing: 'border-box',
      wordWrap: 'normal',
      textAlign: 'center',
      outline: 'none'
    }, parentStyle);

    var contentStyle = pick(style, ['fontFamily', 'fontSize', 'fontWeight', 'lineHeight', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft']);

    assign(content.style, {
      boxSizing: 'border-box',
      width: '100%',
      outline: 'none',
      wordWrap: 'break-word'
    }, contentStyle);

    if (options.centerVertically) {
      assign(content.style, {
        position: 'absolute',
        top: '50%',
        transform: 'translate(0, -50%)'
      }, contentStyle);
    }

    content.innerText = value;

    componentEvent.bind(content, 'keydown', this.keyHandler);
    componentEvent.bind(content, 'mousedown', stopPropagation$1);
    componentEvent.bind(content, 'paste', self.handlePaste);

    if (options.autoResize) {
      componentEvent.bind(content, 'input', this.autoResize);
    }

    if (options.resizable) {
      this.resizable(style);
    }

    container.appendChild(parent);

    // set selection to end of text
    this.setSelection(content.lastChild, content.lastChild && content.lastChild.length);

    return parent;
  };

  /**
   * Intercept paste events to remove formatting from pasted text.
   */
  TextBox.prototype.handlePaste = function (e) {
    var self = this;

    var options = this.options,
        style = this.style;

    e.preventDefault();

    var text;

    if (e.clipboardData) {

      // Chrome, Firefox, Safari
      text = e.clipboardData.getData('text/plain');
    } else {

      // Internet Explorer
      text = window.clipboardData.getData('Text');
    }

    // insertHTML command not supported by Internet Explorer
    var success = document.execCommand('insertHTML', false, text);

    if (!success) {

      // Internet Explorer
      var range = this.getSelection(),
          startContainer = range.startContainer,
          endContainer = range.endContainer,
          startOffset = range.startOffset,
          endOffset = range.endOffset,
          commonAncestorContainer = range.commonAncestorContainer;

      var childNodesArray = toArray(commonAncestorContainer.childNodes);

      var container, offset;

      if (isTextNode(commonAncestorContainer)) {
        var containerTextContent = startContainer.textContent;

        startContainer.textContent = containerTextContent.substring(0, startOffset) + text + containerTextContent.substring(endOffset);

        container = startContainer;
        offset = startOffset + text.length;
      } else if (startContainer === this.content && endContainer === this.content) {
        var textNode = document.createTextNode(text);

        this.content.insertBefore(textNode, childNodesArray[startOffset]);

        container = textNode;
        offset = textNode.textContent.length;
      } else {
        var startContainerChildIndex = childNodesArray.indexOf(startContainer),
            endContainerChildIndex = childNodesArray.indexOf(endContainer);

        childNodesArray.forEach(function (childNode, index) {

          if (index === startContainerChildIndex) {
            childNode.textContent = startContainer.textContent.substring(0, startOffset) + text + endContainer.textContent.substring(endOffset);
          } else if (index > startContainerChildIndex && index <= endContainerChildIndex) {
            remove(childNode);
          }
        });

        container = startContainer;
        offset = startOffset + text.length;
      }

      if (container && offset !== undefined) {

        // is necessary in Internet Explorer
        setTimeout(function () {
          self.setSelection(container, offset);
        });
      }
    }

    if (options.autoResize) {
      var hasResized = this.autoResize(style);

      if (hasResized) {
        this.resizeHandler(hasResized);
      }
    }
  };

  /**
   * Automatically resize element vertically to fit its content.
   */
  TextBox.prototype.autoResize = function () {
    var parent = this.parent,
        content = this.content;

    var fontSize = parseInt(this.style.fontSize) || 12;

    if (content.scrollHeight > parent.offsetHeight || content.scrollHeight < parent.offsetHeight - fontSize) {
      var bounds = parent.getBoundingClientRect();

      var height = content.scrollHeight;
      parent.style.height = height + 'px';

      this.resizeHandler({
        width: bounds.width,
        height: bounds.height,
        dx: 0,
        dy: height - bounds.height
      });
    }
  };

  /**
   * Make an element resizable by adding a resize handle.
   */
  TextBox.prototype.resizable = function () {
    var self = this;

    var parent = this.parent,
        resizeHandle = this.resizeHandle;

    var minWidth = parseInt(this.style.minWidth) || 0,
        minHeight = parseInt(this.style.minHeight) || 0,
        maxWidth = parseInt(this.style.maxWidth) || Infinity,
        maxHeight = parseInt(this.style.maxHeight) || Infinity;

    if (!resizeHandle) {
      resizeHandle = this.resizeHandle = domify('<div class="djs-direct-editing-resize-handle"></div>');

      var startX, startY, startWidth, startHeight;

      var onMouseDown = function onMouseDown(e) {
        preventDefault$1(e);
        stopPropagation$1(e);

        startX = e.clientX;
        startY = e.clientY;

        var bounds = parent.getBoundingClientRect();

        startWidth = bounds.width;
        startHeight = bounds.height;

        componentEvent.bind(document, 'mousemove', onMouseMove);
        componentEvent.bind(document, 'mouseup', onMouseUp);
      };

      var onMouseMove = function onMouseMove(e) {
        preventDefault$1(e);
        stopPropagation$1(e);

        var newWidth = min(max$1(startWidth + e.clientX - startX, minWidth), maxWidth);
        var newHeight = min(max$1(startHeight + e.clientY - startY, minHeight), maxHeight);

        parent.style.width = newWidth + 'px';
        parent.style.height = newHeight + 'px';

        self.resizeHandler({
          width: startWidth,
          height: startHeight,
          dx: e.clientX - startX,
          dy: e.clientY - startY
        });
      };

      var onMouseUp = function onMouseUp(e) {
        preventDefault$1(e);
        stopPropagation$1(e);

        componentEvent.unbind(document, 'mousemove', onMouseMove, false);
        componentEvent.unbind(document, 'mouseup', onMouseUp, false);
      };

      componentEvent.bind(resizeHandle, 'mousedown', onMouseDown);
    }

    assign(resizeHandle.style, {
      position: 'absolute',
      bottom: '0px',
      right: '0px',
      cursor: 'nwse-resize',
      width: '0',
      height: '0',
      borderTop: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid transparent',
      borderRight: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid #ccc',
      borderBottom: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid #ccc',
      borderLeft: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid transparent'
    });

    parent.appendChild(resizeHandle);
  };

  /**
   * Clear content and style of the textbox, unbind listeners and
   * reset CSS style.
   */
  TextBox.prototype.destroy = function () {
    var parent = this.parent,
        content = this.content,
        resizeHandle = this.resizeHandle;

    // clear content
    content.innerText = '';

    // clear styles
    parent.removeAttribute('style');
    content.removeAttribute('style');

    componentEvent.unbind(content, 'keydown', this.keyHandler);
    componentEvent.unbind(content, 'mousedown', stopPropagation$1);
    componentEvent.unbind(content, 'input', this.autoResize);
    componentEvent.unbind(content, 'paste', this.handlePaste);

    if (resizeHandle) {
      resizeHandle.removeAttribute('style');

      remove(resizeHandle);
    }

    remove(parent);
  };

  TextBox.prototype.getValue = function () {
    return this.content.innerText;
  };

  TextBox.prototype.getSelection = function () {
    var selection = window.getSelection(),
        range = selection.getRangeAt(0);

    return range;
  };

  TextBox.prototype.setSelection = function (container, offset) {
    var range = document.createRange();

    if (container === null) {
      range.selectNodeContents(this.content);
    } else {
      range.setStart(container, offset);
      range.setEnd(container, offset);
    }

    var selection = window.getSelection();

    selection.removeAllRanges();
    selection.addRange(range);
  };

  /**
   * A direct editing component that allows users
   * to edit an elements text directly in the diagram
   *
   * @param {EventBus} eventBus the event bus
   */
  function DirectEditing(eventBus, canvas) {

    this._eventBus = eventBus;

    this._providers = [];
    this._textbox = new TextBox({
      container: canvas.getContainer(),
      keyHandler: bind(this._handleKey, this),
      resizeHandler: bind(this._handleResize, this)
    });
  }

  DirectEditing.$inject = ['eventBus', 'canvas'];

  /**
   * Register a direct editing provider

   * @param {Object} provider the provider, must expose an #activate(element) method that returns
   *                          an activation context ({ bounds: {x, y, width, height }, text }) if
   *                          direct editing is available for the given element.
   *                          Additionally the provider must expose a #update(element, value) method
   *                          to receive direct editing updates.
   */
  DirectEditing.prototype.registerProvider = function (provider) {
    this._providers.push(provider);
  };

  /**
   * Returns true if direct editing is currently active
   *
   * @return {Boolean}
   */
  DirectEditing.prototype.isActive = function () {
    return !!this._active;
  };

  /**
   * Cancel direct editing, if it is currently active
   */
  DirectEditing.prototype.cancel = function () {
    if (!this._active) {
      return;
    }

    this._fire('cancel');
    this.close();
  };

  DirectEditing.prototype._fire = function (event, context) {
    this._eventBus.fire('directEditing.' + event, context || { active: this._active });
  };

  DirectEditing.prototype.close = function () {
    this._textbox.destroy();

    this._fire('deactivate');

    this._active = null;

    this.resizable = undefined;
  };

  DirectEditing.prototype.complete = function () {

    var active = this._active;

    if (!active) {
      return;
    }

    var text = this.getValue();

    var bounds = this.$textbox.getBoundingClientRect();

    if (text !== active.context.text || this.resizable) {
      active.provider.update(active.element, text, active.context.text, {
        x: bounds.top,
        y: bounds.left,
        width: bounds.width,
        height: bounds.height
      });
    }

    this._fire('complete');

    this.close();
  };

  DirectEditing.prototype.getValue = function () {
    return this._textbox.getValue();
  };

  DirectEditing.prototype._handleKey = function (e) {

    // stop bubble
    e.stopPropagation();

    var key = e.keyCode || e.charCode;

    // ESC
    if (key === 27) {
      e.preventDefault();
      return this.cancel();
    }

    // Enter
    if (key === 13 && !e.shiftKey) {
      e.preventDefault();
      return this.complete();
    }
  };

  DirectEditing.prototype._handleResize = function (event) {
    this._fire('resize', event);
  };

  /**
   * Activate direct editing on the given element
   *
   * @param {Object} ElementDescriptor the descriptor for a shape or connection
   * @return {Boolean} true if the activation was possible
   */
  DirectEditing.prototype.activate = function (element) {
    if (this.isActive()) {
      this.cancel();
    }

    // the direct editing context
    var context;

    var provider = find(this._providers, function (p) {
      return (context = p.activate(element)) ? p : null;
    });

    // check if activation took place
    if (context) {
      this.$textbox = this._textbox.create(context.bounds, context.style, context.text, context.options);

      this._active = {
        element: element,
        context: context,
        provider: provider
      };

      if (context.options && context.options.resizable) {
        this.resizable = true;
      }

      this._fire('activate');
    }

    return !!context;
  };

  var DiagramDirectEditing = {
    __depends__: [InteractionEventsModule],
    __init__: ['directEditing'],
    directEditing: ['type', DirectEditing]
  };

  function getLabelAttr(semantic) {
    if (is(semantic, 'dmn:Decision') || is(semantic, 'dmn:BusinessKnowledgeModel') || is(semantic, 'dmn:InputData') || is(semantic, 'dmn:KnowledgeSource')) {

      return 'name';
    }

    if (is(semantic, 'dmn:TextAnnotation')) {
      return 'text';
    }
  }

  function getLabel(element) {
    var semantic = element.businessObject,
        attr = getLabelAttr(semantic);

    if (attr) {
      return semantic[attr] || '';
    }
  }

  function setLabel(element, text, isExternal) {
    var semantic = element.businessObject,
        attr = getLabelAttr(semantic);

    if (attr) {
      semantic[attr] = text;
    }

    // show external label if not empty
    if (isExternal) {
      element.hidden = !text;
    }

    return element;
  }

  /**
   * A handler that updates the name of a DMN element.
   */
  function UpdateLabelHandler() {

    /**
     * Set the label and return the changed elements.
     *
     * Element parameter can be label itself or connection (i.e. sequence flow).
     *
     * @param {djs.model.Base} element
     * @param {String} text
     */
    function setText(element, text) {

      // external label if present
      var label = element.label || element;

      var labelTarget = element.labelTarget || element;

      setLabel(label, text, labelTarget !== label);

      return [label, labelTarget];
    }

    function execute(ctx) {
      ctx.oldLabel = getLabel(ctx.element);
      return setText(ctx.element, ctx.newLabel);
    }

    function revert(ctx) {
      return setText(ctx.element, ctx.oldLabel);
    }

    // API

    this.execute = execute;
    this.revert = revert;
  }

  function LabelEditingProvider(eventBus, canvas, directEditing, commandStack) {

    this._canvas = canvas;
    this._commandStack = commandStack;

    directEditing.registerProvider(this);

    commandStack.registerHandler('element.updateLabel', UpdateLabelHandler);

    // listen to dblclick on non-root elements
    eventBus.on('element.dblclick', function (event) {
      directEditing.activate(event.element);
    });

    // complete on followup canvas operation
    eventBus.on(['element.mousedown', 'drag.init', 'canvas.viewbox.changed'], function (event) {
      directEditing.complete();
    });

    // cancel on command stack changes
    eventBus.on(['commandStack.changed'], function () {
      directEditing.cancel();
    });

    eventBus.on('create.end', 500, function (e) {

      var element = e.shape;

      if (is(element, 'dmn:Decision') || is(element, 'dmn:InputData') || is(element, 'dmn:BusinessKnowledgeModel') || is(element, 'dmn:KnowledgeSource')) {

        directEditing.activate(element);
      }
    });
  }

  LabelEditingProvider.$inject = ['eventBus', 'canvas', 'directEditing', 'commandStack'];

  /**
   * Activate direct editing for drgs and text annotations.
   *
   * @param  {djs.model.Base} element
   *
   * @return {Object} an object with properties bounds (position and size) and text
   */
  LabelEditingProvider.prototype.activate = function (element) {

    var text = getLabel(element);

    if (text === undefined) {
      return;
    }

    var properties = this.getEditingBBox(element);

    properties.text = text;

    return properties;
  };

  /**
   * Get the editing bounding box based on the element's size and position
   *
   * @param  {djs.model.Base} element
   *
   * @return {Object}
   *         an object containing information about position and
   *         size (fixed or minimum and/or maximum)
   */
  LabelEditingProvider.prototype.getEditingBBox = function (element) {
    var canvas = this._canvas;

    var target = element.label || element;

    var bbox = canvas.getAbsoluteBBox(target);

    // default position
    var bounds = { x: bbox.x, y: bbox.y };

    var style = {},
        zoom;

    zoom = canvas.zoom();

    // fixed size for internal labels:
    // on high zoom levels: text box size === bbox size
    // on low zoom levels: text box size === bbox size at 100% zoom
    // This ensures minimum bounds at low zoom levels
    if (zoom > 1) {
      bounds.width = bbox.width;
      bounds.height = bbox.height;
    } else {
      bounds.width = bbox.width / zoom;
      bounds.height = bbox.height / zoom;
    }

    // centering overlapping text box size at low zoom levels
    if (zoom < 1) {
      bounds.x = bbox.x - (bounds.width / 2 - bbox.width / 2);
      bounds.y = bbox.y - (bounds.height / 2 - bbox.height / 2);
    }

    // text annotations
    if (is(element, 'dmn:TextAnnotation')) {
      bounds.minWidth = 100;
      bounds.height = element.height;

      style.textAlign = 'left';
    }

    return { bounds: bounds, style: style };
  };

  LabelEditingProvider.prototype.update = function (element, newLabel) {
    this._commandStack.execute('element.updateLabel', {
      element: element,
      newLabel: newLabel
    });
  };

  var LabelEditingModule = {
    __depends__: [CommandStack$1, DiagramChangeSupport, DiagramDirectEditing],
    __init__: ['labelEditingProvider'],
    labelEditingProvider: ['type', LabelEditingProvider]
  };

  var DEFAULT_PRIORITY$1 = 1000;

  /**
   * A utility that can be used to plug-in into the command execution for
   * extension and/or validation.
   *
   * @param {EventBus} eventBus
   *
   * @example
   *
   * import inherits from 'inherits';
   *
   * import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';
   *
   * function CommandLogger(eventBus) {
   *   CommandInterceptor.call(this, eventBus);
   *
   *   this.preExecute(function(event) {
   *     console.log('command pre-execute', event);
   *   });
   * }
   *
   * inherits(CommandLogger, CommandInterceptor);
   *
   */
  function CommandInterceptor(eventBus) {
    this._eventBus = eventBus;
  }

  CommandInterceptor.$inject = ['eventBus'];

  function unwrapEvent(fn, that) {
    return function (event) {
      return fn.call(that || null, event.context, event.command, event);
    };
  }

  /**
   * Register an interceptor for a command execution
   *
   * @param {String|Array<String>} [events] list of commands to register on
   * @param {String} [hook] command hook, i.e. preExecute, executed to listen on
   * @param {Number} [priority] the priority on which to hook into the execution
   * @param {Function} handlerFn interceptor to be invoked with (event)
   * @param {Boolean} unwrap if true, unwrap the event and pass (context, command, event) to the
   *                          listener instead
   * @param {Object} [that] Pass context (`this`) to the handler function
   */
  CommandInterceptor.prototype.on = function (events, hook, priority, handlerFn, unwrap, that) {

    if (isFunction(hook) || isNumber(hook)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = hook;
      hook = null;
    }

    if (isFunction(priority)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = DEFAULT_PRIORITY$1;
    }

    if (isObject(unwrap)) {
      that = unwrap;
      unwrap = false;
    }

    if (!isFunction(handlerFn)) {
      throw new Error('handlerFn must be a function');
    }

    if (!isArray(events)) {
      events = [events];
    }

    var eventBus = this._eventBus;

    forEach(events, function (event) {
      // concat commandStack(.event)?(.hook)?
      var fullEvent = ['commandStack', event, hook].filter(function (e) {
        return e;
      }).join('.');

      eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);
    });
  };

  var hooks = ['canExecute', 'preExecute', 'preExecuted', 'execute', 'executed', 'postExecute', 'postExecuted', 'revert', 'reverted'];

  /*
   * Install hook shortcuts
   *
   * This will generate the CommandInterceptor#(preExecute|...|reverted) methods
   * which will in term forward to CommandInterceptor#on.
   */
  forEach(hooks, function (hook) {

    /**
     * {canExecute|preExecute|preExecuted|execute|executed|postExecute|postExecuted|revert|reverted}
     *
     * A named hook for plugging into the command execution
     *
     * @param {String|Array<String>} [events] list of commands to register on
     * @param {Number} [priority] the priority on which to hook into the execution
     * @param {Function} handlerFn interceptor to be invoked with (event)
     * @param {Boolean} [unwrap=false] if true, unwrap the event and pass (context, command, event) to the
     *                          listener instead
     * @param {Object} [that] Pass context (`this`) to the handler function
     */
    CommandInterceptor.prototype[hook] = function (events, priority, handlerFn, unwrap, that) {

      if (isFunction(events) || isNumber(events)) {
        that = unwrap;
        unwrap = handlerFn;
        handlerFn = priority;
        priority = events;
        events = null;
      }

      this.on(events, hook, priority, handlerFn, unwrap, that);
    };
  });

  function getRequirementType(source) {
    switch (source.type) {
      case 'dmn:InputData':
        return 'Input';
      case 'dmn:Decision':
        return 'Decision';
      case 'dmn:KnowledgeSource':
        return 'Authority';
      case 'dmn:BusinessKnowledgeModel':
        return 'Knowledge';
    }
  }

  function CreateConnectionBehavior(eventBus, drdFactory, drdRules) {

    CommandInterceptor.call(this, eventBus);

    this.preExecute('connection.create', function (context) {
      var connection = context.connection,
          connectionBusinessObject = connection.businessObject,
          source = context.source,
          target = context.target,
          sourceRef,
          targetRef,
          requirementType,
          requirement,
          edge;

      if (connection.type === 'dmn:Association') {
        sourceRef = drdFactory.create('dmn:DMNElementReference', {
          href: '#' + source.id
        });
        targetRef = drdFactory.create('dmn:DMNElementReference', {
          href: '#' + target.id
        });

        connectionBusinessObject.sourceRef = sourceRef;
        connectionBusinessObject.targetRef = targetRef;

        connectionBusinessObject.extensionElements = drdFactory.createDi();

        edge = drdFactory.createDiEdge(source, [getMid(source), getMid(target)]);

        connectionBusinessObject.extensionElements.values.push(edge);
      } else {

        // flip around source and target
        if (is(source, 'dmn:Decision') && is(target, 'dmn:InputData')) {
          context.target = source;
          context.source = source = target;
        }

        requirementType = getRequirementType(source);
        requirement = drdFactory.create('dmn:DMNElementReference', {
          href: '#' + source.id
        });

        connectionBusinessObject['required' + requirementType] = requirement;

        edge = drdFactory.createDiEdge(source, [getMid(source), getMid(context.target)]);

        // DI
        context.di = edge;
      }
    }, true);
  }

  CreateConnectionBehavior.$inject = ['eventBus', 'drdFactory', 'drdRules'];

  inherits_browser(CreateConnectionBehavior, CommandInterceptor);

  function ReplaceConnectionBehavior(eventBus, modeling, drdRules) {

    CommandInterceptor.call(this, eventBus);

    function fixConnection(connection) {

      var source = connection.source,
          target = connection.target,
          parent = connection.parent,
          replacementAttrs;

      // do not do anything if connection
      // is already deleted (may happen due to other
      // behaviors plugged-in before)
      if (!parent) {
        return;
      }

      replacementAttrs = drdRules.canConnect(source, target) || { type: 'dmn:Association' };
      replacementAttrs.waypoints = connection.waypoints.slice();

      // create a new connection
      modeling.removeConnection(connection);
      modeling.connect(source, target, replacementAttrs);
    }

    this.postExecuted('connection.reconnectStart', function (event) {

      // remove old di information from target
      var extensionElements = event.context.connection.target.businessObject.extensionElements.values;

      var extension = filter(extensionElements, function (extension) {
        return extension.$type === 'biodi:Edge' && extension.source === event.context.oldSource.id;
      })[0];

      if (extension) {
        extensionElements.splice(extensionElements.indexOf(extension), 1);
      }
    });

    this.postExecuted(['connection.reconnectStart', 'connection.reconnectEnd'], function (event) {

      var connection = event.context.connection;

      fixConnection(connection);
    });
  }

  inherits_browser(ReplaceConnectionBehavior, CommandInterceptor);

  ReplaceConnectionBehavior.$inject = ['eventBus', 'modeling', 'drdRules'];

  /**
   * Defines the behaviour of what happens to the elements inside a container
   * that morphs into another DRD element
   */
  function ReplaceElementBehaviour(eventBus, modeling) {
    CommandInterceptor.call(this, eventBus);

    this._modeling = modeling;

    this.postExecuted(['shape.replace'], 1500, function (e) {
      var context = e.context,
          oldShape = context.oldShape,
          newShape = context.newShape,
          newId = newShape.id;

      modeling.unclaimId(oldShape.businessObject.id, oldShape.businessObject);
      modeling.updateProperties(newShape, { id: oldShape.id });

      // update id of target connection references
      forEach(newShape.outgoing, function (connection) {
        var bo = connection.businessObject,
            extensionElements,
            extension;

        if (bo.$instanceOf('dmn:Association')) {
          bo.sourceRef.href = '#' + oldShape.id;
          extensionElements = bo.extensionElements;
        } else {
          bo.requiredDecision.href = '#' + oldShape.id;
          extensionElements = bo.$parent.extensionElements;
        }

        extension = filter(extensionElements.values, function (extension) {
          return extension.$type === 'biodi:Edge' && extension.source === newId;
        })[0];

        if (extension) {
          extension.source = oldShape.id;
        }
      });
    });
  }

  inherits_browser(ReplaceElementBehaviour, CommandInterceptor);

  ReplaceElementBehaviour.$inject = ['eventBus', 'modeling'];

  var ModelingBehavior = {
    __init__: ['createConnectionBehavior', 'replaceConnectionBehavior', 'replaceElementBehavior'],
    createConnectionBehavior: ['type', CreateConnectionBehavior],
    replaceConnectionBehavior: ['type', ReplaceConnectionBehavior],
    replaceElementBehavior: ['type', ReplaceElementBehaviour]
  };

  /**
   * A basic provider that may be extended to implement modeling rules.
   *
   * Extensions should implement the init method to actually add their custom
   * modeling checks. Checks may be added via the #addRule(action, fn) method.
   *
   * @param {EventBus} eventBus
   */
  function RuleProvider(eventBus) {
    CommandInterceptor.call(this, eventBus);

    this.init();
  }

  RuleProvider.$inject = ['eventBus'];

  inherits_browser(RuleProvider, CommandInterceptor);

  /**
   * Adds a modeling rule for the given action, implemented through
   * a callback function.
   *
   * The function will receive the modeling specific action context
   * to perform its check. It must return `false` to disallow the
   * action from happening or `true` to allow the action.
   *
   * A rule provider may pass over the evaluation to lower priority
   * rules by returning return nothing (or <code>undefined</code>).
   *
   * @example
   *
   * ResizableRules.prototype.init = function() {
   *
   *   \/**
   *    * Return `true`, `false` or nothing to denote
   *    * _allowed_, _not allowed_ and _continue evaluating_.
   *    *\/
   *   this.addRule('shape.resize', function(context) {
   *
   *     var shape = context.shape;
   *
   *     if (!context.newBounds) {
   *       // check general resizability
   *       if (!shape.resizable) {
   *         return false;
   *       }
   *
   *       // not returning anything (read: undefined)
   *       // will continue the evaluation of other rules
   *       // (with lower priority)
   *       return;
   *     } else {
   *       // element must have minimum size of 10*10 points
   *       return context.newBounds.width > 10 && context.newBounds.height > 10;
   *     }
   *   });
   * };
   *
   * @param {String|Array<String>} actions the identifier for the modeling action to check
   * @param {Number} [priority] the priority at which this rule is being applied
   * @param {Function} fn the callback function that performs the actual check
   */
  RuleProvider.prototype.addRule = function (actions, priority, fn) {

    var self = this;

    if (typeof actions === 'string') {
      actions = [actions];
    }

    actions.forEach(function (action) {

      self.canExecute(action, priority, function (context, action, event) {
        return fn(context);
      }, true);
    });
  };

  /**
   * Implement this method to add new rules during provider initialization.
   */
  RuleProvider.prototype.init = function () {};

  /**
   * DRD specific modeling rule
   */
  function DrdRules(eventBus) {
    RuleProvider.call(this, eventBus);
  }

  inherits_browser(DrdRules, RuleProvider);

  DrdRules.$inject = ['eventBus'];

  DrdRules.prototype.init = function () {

    this.addRule('elements.move', function (context) {

      var target = context.target,
          shapes = context.shapes,
          position = context.position;

      return canMove(shapes, target, position);
    });

    this.addRule('connection.create', function (context) {
      var source = context.source,
          target = context.target;

      return canConnect(source, target);
    });

    this.addRule('connection.reconnectStart', function (context) {

      var connection = context.connection,
          source = context.hover || context.source,
          target = connection.target;

      return canConnect(source, target, connection);
    });

    this.addRule('connection.reconnectEnd', function (context) {

      var connection = context.connection,
          source = connection.source,
          target = context.hover || context.target;

      return canConnect(source, target, connection);
    });

    this.addRule('connection.updateWaypoints', function (context) {
      // OK! but visually ignore
      return null;
    });

    this.addRule('shape.create', function (context) {
      return canCreate(context.shape, context.target);
    });
  };

  DrdRules.prototype.canConnect = canConnect;

  DrdRules.prototype.canCreate = canCreate;

  DrdRules.prototype.canMove = canMove;

  function canConnect(source, target) {

    if (is(source, 'dmn:Definitions') || is(target, 'dmn:Definitions')) {
      return false;
    }

    if (is(source, 'dmn:Decision') || is(source, 'dmn:InputData')) {
      if (is(target, 'dmn:Decision') || is(source, 'dmn:Decision') && is(target, 'dmn:InputData')) {
        return { type: 'dmn:InformationRequirement' };
      }

      if (is(target, 'dmn:KnowledgeSource')) {
        return { type: 'dmn:AuthorityRequirement' };
      }
    }

    if (is(source, 'dmn:BusinessKnowledgeModel') && isAny(target, ['dmn:Decision', 'dmn:BusinessKnowledgeModel'])) {
      return { type: 'dmn:KnowledgeRequirement' };
    }

    if (is(source, 'dmn:KnowledgeSource') && isAny(target, ['dmn:Decision', 'dmn:BusinessKnowledgeModel', 'dmn:KnowledgeSource'])) {
      return { type: 'dmn:AuthorityRequirement' };
    }

    if (is(target, 'dmn:TextAnnotation')) {
      return { type: 'dmn:Association' };
    }

    return false;
  }

  function canCreate(shape, target) {
    return is(target, 'dmn:Definitions');
  }

  function canMove(elements, target) {

    // allow default move check to start move operation
    if (!target) {
      return true;
    }

    if (is(target, 'dmn:Definitions')) {
      return true;
    }

    return false;
  }

  var Rules$2 = {
    __depends__: [Rules$1],
    __init__: ['drdRules'],
    drdRules: ['type', DrdRules]
  };

  function DrdFactory(moddle) {
    this._model = moddle;
  }

  DrdFactory.$inject = ['moddle'];

  DrdFactory.prototype._needsId = function (element) {
    return element.$instanceOf('dmn:DRGElement') || element.$instanceOf('dmn:Artifact') || element.$instanceOf('dmn:DMNElement');
  };

  DrdFactory.prototype._ensureId = function (element) {

    // generate semantic ids for elements
    // dmn:Decision -> Decision_ID
    var prefix = (element.$type || '').replace(/^[^:]*:/g, '') + '_';

    if (!element.id && this._needsId(element)) {
      element.id = this._model.ids.nextPrefixed(prefix, element);
    }
  };

  DrdFactory.prototype.create = function (type, attrs) {
    var element = this._model.create(type, attrs || {});

    this._ensureId(element);

    return element;
  };

  DrdFactory.prototype.createDi = function () {
    return this.create('dmn:ExtensionElements', { values: [] });
  };

  DrdFactory.prototype.createDiBounds = function (bounds) {
    return this.create('biodi:Bounds', bounds);
  };

  DrdFactory.prototype.createDiEdge = function (source, waypoints) {
    var self = this;
    var semanticWaypoints = [];

    forEach(waypoints || [], function (wp) {
      semanticWaypoints.push(self.createDiWaypoint(wp));
    });

    return this.create('biodi:Edge', {
      waypoints: semanticWaypoints,
      source: source.id
    });
  };

  DrdFactory.prototype.createDiWaypoint = function (waypoint) {
    return this.create('biodi:Waypoint', waypoint);
  };

  /**
   * A command interceptor responsible for updating elements after they've
   * been changed in the DRD view.
   */
  function DrdUpdater(eventBus, drdFactory, connectionDocking, drdRules, definitionPropertiesView) {

    CommandInterceptor.call(this, eventBus);

    this._drdFactory = drdFactory;
    this._drdRules = drdRules;
    this._definitionPropertiesView = definitionPropertiesView;

    var self = this;

    // connection cropping //////////////////////

    // crop connection ends during create/update
    function cropConnection(e) {
      var context = e.context,
          connection;

      if (!context.cropped) {
        connection = context.connection;
        connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
        context.cropped = true;
      }
    }

    this.executed(['connection.layout', 'connection.create', 'connection.reconnectEnd', 'connection.reconnectStart'], cropConnection);

    this.reverted(['connection.layout'], function (e) {
      delete e.context.cropped;
    });

    // DRD + DI update //////////////////////

    // update parent
    function updateParent(e) {
      var context = e.context,
          element = context.shape || context.connection,
          oldParent = context.oldParent;

      // for all requirements the semantic parent is the target
      if (context.connection && !is(element, 'dmn:Association')) {
        oldParent = element.target;
      }

      self.updateParent(element, oldParent);
    }

    function reverseUpdateParent(e) {
      var context = e.context;

      var element = context.shape || context.connection,


      // oldParent is the (old) new parent, because we are undoing
      oldParent = context.parent || context.newParent;

      // for all requirements the semantic parent is the target
      if (context.connection && !is(element, 'dmn:Association')) {
        oldParent = element.target;
      }

      self.updateParent(element, oldParent);
    }

    this.executed(['shape.create', 'shape.delete', 'connection.create', 'connection.move', 'connection.delete'], updateParent);

    this.reverted(['shape.create', 'shape.delete', 'connection.create', 'connection.move', 'connection.delete'], reverseUpdateParent);

    // update bounds
    function updateBounds(e) {
      var shape = e.context.shape;

      if (!(is(shape, 'dmn:DRGElement') || is(shape, 'dmn:TextAnnotation'))) {
        return;
      }

      self.updateBounds(shape);
    }

    this.executed(['shape.create', 'shape.move'], updateBounds);

    this.reverted(['shape.create', 'shape.move'], updateBounds);

    function updateConnectionWaypoints(e) {
      self.updateConnectionWaypoints(e.context);
    }

    this.executed(['connection.layout', 'connection.updateWaypoints', 'connection.move'], updateConnectionWaypoints);

    this.reverted(['connection.layout', 'connection.updateWaypoints', 'connection.move'], updateConnectionWaypoints);

    this.executed(['connection.create'], function (event) {
      var context = event.context,
          connection = context.connection,
          targetBO = context.target.businessObject,
          di,
          ext;

      if (is(connection, 'dmn:Association')) {
        updateParent(event);
      } else {
        // semantic parent is target (instead of graphical parent)
        self.updateSemanticParent(connection.businessObject, targetBO);

        // add di to target business object extension elements
        di = context.di;
        ext = targetBO.extensionElements.values;

        // fix di waypoints, due to connection cropping
        forEach(di.waypoints, function (waypoint, index) {
          waypoint.x = connection.waypoints[index].x;
          waypoint.y = connection.waypoints[index].y;
        });

        ext.push(di);
      }
    });

    this.reverted(['connection.create'], function (event) {
      var context = event.context,
          connection = context.connection,
          di,
          ext,
          idx;

      reverseUpdateParent(event);

      if (!is(connection, 'dmn:Association')) {
        // remove di from target business object extension elements
        di = context.di;
        ext = context.target.businessObject.extensionElements.values;
        idx = ext.indexOf(di);

        if (idx !== -1) {
          ext.splice(idx, 1);
        }
      }
    });

    this.executed(['connection.delete'], function (event) {
      var context = event.context,
          connection = getBusinessObject(context.connection),
          source = context.source,
          target = getBusinessObject(context.target),
          index;

      if (is(connection, 'dmn:Association')) {
        return;
      }

      forEach(target.extensionElements.values, function (value, idx) {
        if (is(value, 'biodi:Edge') && source.id === value.source) {
          index = idx;

          return false;
        }
      });

      if (index !== undefined) {
        context.oldDI = target.extensionElements.values[index];

        target.extensionElements.values.splice(index, 1);
      }
    });

    this.reverted(['connection.delete'], function (event) {
      var context = event.context,
          connection = context.connection,
          target = getBusinessObject(context.target),
          oldDI = context.oldDI;

      if (!oldDI || is(connection, 'dmn:Association')) {
        return;
      }

      target.extensionElements.values.push(oldDI);
    });

    this.executed(['element.updateProperties'], function (event) {
      definitionPropertiesView.update();
    });
    this.reverted(['element.updateProperties'], function (event) {
      definitionPropertiesView.update();
    });

    this.reverted(['connection.reconnectEnd'], function (event) {
      self.updateSemanticParent(event.context.connection.businessObject, event.context.oldTarget.businessObject);
    });
  }

  inherits_browser(DrdUpdater, CommandInterceptor);

  DrdUpdater.$inject = ['eventBus', 'drdFactory', 'connectionDocking', 'drdRules', 'definitionPropertiesView'];

  // implementation //////////////////////

  DrdUpdater.prototype.updateParent = function (element, oldParent) {
    var parentShape = element.parent;

    if (!is(element, 'dmn:DRGElement') && !is(element, 'dmn:Artifact')) {
      parentShape = oldParent;
    }

    var businessObject = element.businessObject,
        parentBusinessObject = parentShape && parentShape.businessObject;

    this.updateSemanticParent(businessObject, parentBusinessObject);

    this.updateExtensionElements(businessObject);
  };

  DrdUpdater.prototype.updateBounds = function (shape) {
    var drdFactory = this._drdFactory;

    var businessObject = getBusinessObject(shape),
        extensionElements = businessObject.extensionElements,
        values$$1,
        bounds;

    if (!extensionElements) {
      return;
    }

    values$$1 = extensionElements.values;
    bounds = values$$1[0];

    if (!bounds) {
      values$$1.push(drdFactory.createDiBounds({
        x: shape.x,
        y: shape.y,
        width: shape.width,
        height: shape.height
      }));
    } else {
      values$$1[0] = assign(bounds, {
        x: shape.x,
        y: shape.y,
        width: shape.width,
        height: shape.height
      });
    }
  };

  DrdUpdater.prototype.updateExtensionElements = function (businessObject) {
    var extensionElements = businessObject.extensionElements;

    if (extensionElements && !extensionElements.$parent) {
      extensionElements.$parent = businessObject;
    }
  };

  DrdUpdater.prototype.updateSemanticParent = function (businessObject, newParent) {

    var containment, children;

    if (businessObject.$parent === newParent) {
      return;
    }

    if (businessObject.$instanceOf('dmn:DRGElement')) {
      containment = 'drgElements';
    } else if (businessObject.$instanceOf('dmn:Artifact')) {
      containment = 'artifacts';
    } else if (businessObject.$instanceOf('dmn:InformationRequirement')) {
      containment = 'informationRequirement';
    } else if (businessObject.$instanceOf('dmn:AuthorityRequirement')) {
      containment = 'authorityRequirement';
    } else if (businessObject.$instanceOf('dmn:KnowledgeRequirement')) {
      containment = 'knowledgeRequirement';
    }

    if (businessObject.$parent) {
      // remove from old parent
      children = businessObject.$parent.get(containment);

      remove$2(children, businessObject);
    }

    if (!newParent) {
      businessObject.$parent = null;
    } else {
      // add to new parent
      children = newParent.get(containment);
      if (children) {
        children.push(businessObject);
        businessObject.$parent = newParent;
      }
    }
  };

  DrdUpdater.prototype.updateConnectionWaypoints = function (context) {
    var drdFactory = this._drdFactory;

    var connection = context.connection,
        source = connection.source,
        target = connection.target,
        extensionElements;

    if (is(connection, 'dmn:Association')) {
      extensionElements = connection.businessObject.extensionElements;
    } else {
      extensionElements = target.businessObject.extensionElements;
    }

    // update di -> target extensionElements
    extensionElements.values = map(extensionElements.values, function (value) {

      if (is(value, 'biodi:Edge') && value.source === source.id) {
        value.waypoints = [];

        forEach(connection.waypoints, function (waypoint, index) {
          var semanticWaypoint = drdFactory.createDiWaypoint(pick(waypoint, ['x', 'y']));

          semanticWaypoint.$parent = value;

          value.waypoints.push(semanticWaypoint);
        });
      }

      return value;
    });
  };

  /**
   * A drd-aware factory for diagram-js shapes
   */
  function ElementFactory$1(drdFactory) {
    ElementFactory.call(this);

    this._drdFactory = drdFactory;
  }

  inherits_browser(ElementFactory$1, ElementFactory);

  ElementFactory$1.$inject = ['drdFactory'];

  ElementFactory$1.prototype.baseCreate = ElementFactory.prototype.create;

  ElementFactory$1.prototype.create = function (elementType, attrs) {
    return this.createDrdElement(elementType, attrs);
  };

  ElementFactory$1.prototype.createDrdElement = function (elementType, attrs) {
    var drdFactory = this._drdFactory;

    var size$$1;

    attrs = attrs || {};

    var businessObject = attrs.businessObject;

    if (!businessObject) {
      if (!attrs.type) {
        throw new Error('no shape type specified');
      }

      businessObject = drdFactory.create(attrs.type);
    }

    if (elementType !== 'root' && elementType !== 'connection' && !businessObject.extensionElements) {
      businessObject.extensionElements = drdFactory.createDi();
    }

    size$$1 = this._getDefaultSize(businessObject);

    attrs = assign({
      businessObject: businessObject,
      id: businessObject.id
    }, size$$1, attrs);

    return this.baseCreate(elementType, attrs);
  };

  ElementFactory$1.prototype._getDefaultSize = function (semantic) {

    if (is(semantic, 'dmn:Decision')) {
      return { width: 180, height: 80 };
    }

    if (is(semantic, 'dmn:InputData')) {
      return { width: 125, height: 45 };
    }

    if (is(semantic, 'dmn:KnowledgeSource')) {
      return { width: 100, height: 63 };
    }

    if (is(semantic, 'dmn:BusinessKnowledgeModel')) {
      return { width: 135, height: 46 };
    }

    return { width: 100, height: 80 };
  };

  /**
   * A handler that implements reversible appending of shapes
   * to a source shape.
   *
   * @param {canvas} Canvas
   * @param {elementFactory} ElementFactory
   * @param {modeling} Modeling
   */
  function AppendShapeHandler(modeling) {
    this._modeling = modeling;
  }

  AppendShapeHandler.$inject = ['modeling'];

  // api //////////////////////


  /**
   * Creates a new shape
   *
   * @param {Object} context
   * @param {ElementDescriptor} context.shape the new shape
   * @param {ElementDescriptor} context.source the source object
   * @param {ElementDescriptor} context.parent the parent object
   * @param {Point} context.position position of the new element
   */
  AppendShapeHandler.prototype.preExecute = function (context) {

    var source = context.source;

    if (!source) {
      throw new Error('source required');
    }

    var target = context.target || source.parent,
        shape = context.shape;

    shape = context.shape = this._modeling.createShape(shape, context.position, target, { attach: context.attach });

    context.shape = shape;
  };

  AppendShapeHandler.prototype.postExecute = function (context) {
    var parent = context.connectionParent || context.shape.parent;

    if (!existsConnection(context.source, context.shape)) {

      // create connection
      this._modeling.connect(context.source, context.shape, context.connection, parent);
    }
  };

  function existsConnection(source, target) {
    return some(source.outgoing, function (c) {
      return c.target === target;
    });
  }

  var round$7 = Math.round;

  /**
   * A handler that implements reversible addition of shapes.
   *
   * @param {canvas} Canvas
   */
  function CreateShapeHandler(canvas) {
    this._canvas = canvas;
  }

  CreateShapeHandler.$inject = ['canvas'];

  // api //////////////////////


  /**
   * Appends a shape to a target shape
   *
   * @param {Object} context
   * @param {djs.model.Base} context.parent the parent object
   * @param {Point} context.position position of the new element
   */
  CreateShapeHandler.prototype.execute = function (context) {

    var shape = context.shape,
        positionOrBounds = context.position,
        parent = context.parent,
        parentIndex = context.parentIndex;

    if (!parent) {
      throw new Error('parent required');
    }

    if (!positionOrBounds) {
      throw new Error('position required');
    }

    // (1) add at event center position _or_ at given bounds
    if (positionOrBounds.width !== undefined) {
      assign(shape, positionOrBounds);
    } else {
      assign(shape, {
        x: positionOrBounds.x - round$7(shape.width / 2),
        y: positionOrBounds.y - round$7(shape.height / 2)
      });
    }

    // (2) add to canvas
    this._canvas.addShape(shape, parent, parentIndex);

    return shape;
  };

  /**
   * Undo append by removing the shape
   */
  CreateShapeHandler.prototype.revert = function (context) {

    // (3) remove form canvas
    this._canvas.removeShape(context.shape);
  };

  /**
   * Remove from the beginning of a collection until it is empty.
   *
   * This is a null-safe operation that ensures elements
   * are being removed from the given collection until the
   * collection is empty.
   *
   * The implementation deals with the fact that a remove operation
   * may touch, i.e. remove multiple elements in the collection
   * at a time.
   *
   * @param {Array<Object>} [collection]
   * @param {Function} removeFn
   *
   * @return {Array<Object>} the cleared collection
   */
  function saveClear(collection, removeFn) {

    if (typeof removeFn !== 'function') {
      throw new Error('removeFn iterator must be a function');
    }

    if (!collection) {
      return;
    }

    var e;

    while (e = collection[0]) {
      removeFn(e);
    }

    return collection;
  }

  /**
   * A handler that implements reversible deletion of shapes.
   *
   */
  function DeleteShapeHandler(canvas, modeling) {
    this._canvas = canvas;
    this._modeling = modeling;
  }

  DeleteShapeHandler.$inject = ['canvas', 'modeling'];

  /**
   * - Remove connections
   * - Remove all direct children
   */
  DeleteShapeHandler.prototype.preExecute = function (context) {

    var modeling = this._modeling;

    var shape = context.shape;

    // remove connections
    saveClear(shape.incoming, function (connection) {
      // To make sure that the connection isn't removed twice
      // For example if a container is removed
      modeling.removeConnection(connection, { nested: true });
    });

    saveClear(shape.outgoing, function (connection) {
      modeling.removeConnection(connection, { nested: true });
    });

    // remove child shapes and connections
    saveClear(shape.children, function (child) {
      if (isConnection$2(child)) {
        modeling.removeConnection(child, { nested: true });
      } else {
        modeling.removeShape(child, { nested: true });
      }
    });
  };

  /**
   * Remove shape and remember the parent
   */
  DeleteShapeHandler.prototype.execute = function (context) {
    var canvas = this._canvas;

    var shape = context.shape,
        oldParent = shape.parent;

    context.oldParent = oldParent;

    // remove containment
    context.oldParentIndex = indexOf$1(oldParent.children, shape);

    // remove shape
    canvas.removeShape(shape);

    return shape;
  };

  /**
   * Command revert implementation
   */
  DeleteShapeHandler.prototype.revert = function (context) {

    var canvas = this._canvas;

    var shape = context.shape,
        oldParent = context.oldParent,
        oldParentIndex = context.oldParentIndex;

    // restore containment
    add(oldParent.children, shape, oldParentIndex);

    canvas.addShape(shape, oldParent);

    return shape;
  };

  function isConnection$2(element) {
    return element.waypoints;
  }

  /**
   * Calculates the absolute point relative to the new element's position
   *
   * @param {point} point [absolute]
   * @param {bounds} oldBounds
   * @param {bounds} newBounds
   *
   * @return {point} point [absolute]
   */
  function getNewAttachPoint(point, oldBounds, newBounds) {
    var oldCenter = center(oldBounds),
        newCenter = center(newBounds),
        oldDelta = delta(point, oldCenter);

    var newDelta = {
      x: oldDelta.x * (newBounds.width / oldBounds.width),
      y: oldDelta.y * (newBounds.height / oldBounds.height)
    };

    return roundPoint({
      x: newCenter.x + newDelta.x,
      y: newCenter.y + newDelta.y
    });
  }

  function getResizedSourceAnchor(connection, shape, oldBounds) {

    var waypoints = safeGetWaypoints(connection),
        oldAnchor = waypoints[0];

    return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
  }

  function getResizedTargetAnchor(connection, shape, oldBounds) {

    var waypoints = safeGetWaypoints(connection),
        oldAnchor = waypoints[waypoints.length - 1];

    return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
  }

  function getMovedSourceAnchor(connection, source, moveDelta) {
    return getResizedSourceAnchor(connection, source, substractPosition(source, moveDelta));
  }

  function getMovedTargetAnchor(connection, target, moveDelta) {
    return getResizedTargetAnchor(connection, target, substractPosition(target, moveDelta));
  }

  // helpers //////////////////////

  function substractPosition(bounds, delta) {
    return {
      x: bounds.x - delta.x,
      y: bounds.y - delta.y,
      width: bounds.width,
      height: bounds.height
    };
  }

  /**
   * Return waypoints of given connection; throw if non exists (should not happen!!).
   *
   * @param {Connection} connection
   *
   * @return {Array<Point>}
   */
  function safeGetWaypoints(connection) {

    var waypoints = connection.waypoints;

    if (!waypoints.length) {
      throw new Error('connection#' + connection.id + ': no waypoints');
    }

    return waypoints;
  }

  function MoveClosure() {

    this.allShapes = {};
    this.allConnections = {};

    this.enclosedElements = {};
    this.enclosedConnections = {};

    this.topLevel = {};
  }

  MoveClosure.prototype.add = function (element, isTopLevel) {
    return this.addAll([element], isTopLevel);
  };

  MoveClosure.prototype.addAll = function (elements, isTopLevel) {

    var newClosure = getClosure(elements, !!isTopLevel, this);

    assign(this, newClosure);

    return this;
  };

  /**
   * A helper that is able to carry out serialized move
   * operations on multiple elements.
   *
   * @param {Modeling} modeling
   */
  function MoveHelper(modeling) {
    this._modeling = modeling;
  }

  /**
   * Move the specified elements and all children by the given delta.
   *
   * This moves all enclosed connections, too and layouts all affected
   * external connections.
   *
   * @param  {Array<djs.model.Base>} elements
   * @param  {Point} delta
   * @param  {djs.model.Base} newParent applied to the first level of shapes
   *
   * @return {Array<djs.model.Base>} list of touched elements
   */
  MoveHelper.prototype.moveRecursive = function (elements, delta, newParent) {
    if (!elements) {
      return [];
    } else {
      return this.moveClosure(this.getClosure(elements), delta, newParent);
    }
  };

  /**
   * Move the given closure of elmements.
   *
   * @param {Object} closure
   * @param {Point} delta
   * @param {djs.model.Base} [newParent]
   * @param {djs.model.Base} [newHost]
   */
  MoveHelper.prototype.moveClosure = function (closure, delta, newParent, newHost, primaryShape) {
    var modeling = this._modeling;

    var allShapes = closure.allShapes,
        allConnections = closure.allConnections,
        enclosedConnections = closure.enclosedConnections,
        topLevel = closure.topLevel,
        keepParent = false;

    if (primaryShape && primaryShape.parent === newParent) {
      keepParent = true;
    }

    // move all shapes
    forEach(allShapes, function (shape) {

      // move the element according to the given delta
      modeling.moveShape(shape, delta, topLevel[shape.id] && !keepParent && newParent, {
        recurse: false,
        layout: false
      });
    });

    // move all child connections / layout external connections
    forEach(allConnections, function (c) {

      var sourceMoved = !!allShapes[c.source.id],
          targetMoved = !!allShapes[c.target.id];

      if (enclosedConnections[c.id] && sourceMoved && targetMoved) {
        modeling.moveConnection(c, delta, topLevel[c.id] && !keepParent && newParent);
      } else {
        modeling.layoutConnection(c, {
          connectionStart: sourceMoved && getMovedSourceAnchor(c, c.source, delta),
          connectionEnd: targetMoved && getMovedTargetAnchor(c, c.target, delta)
        });
      }
    });
  };

  /**
   * Returns the closure for the selected elements
   *
   * @param  {Array<djs.model.Base>} elements
   * @return {MoveClosure} closure
   */
  MoveHelper.prototype.getClosure = function (elements) {
    return new MoveClosure().addAll(elements, true);
  };

  /**
   * A handler that implements reversible moving of shapes.
   */
  function MoveShapeHandler(modeling) {
    this._modeling = modeling;

    this._helper = new MoveHelper(modeling);
  }

  MoveShapeHandler.$inject = ['modeling'];

  MoveShapeHandler.prototype.execute = function (context) {

    var shape = context.shape,
        delta = context.delta,
        newParent = context.newParent || shape.parent,
        newParentIndex = context.newParentIndex,
        oldParent = shape.parent;

    context.oldBounds = pick(shape, ['x', 'y', 'width', 'height']);

    // save old parent in context
    context.oldParent = oldParent;
    context.oldParentIndex = remove$2(oldParent.children, shape);

    // add to new parent at position
    add(newParent.children, shape, newParentIndex);

    // update shape parent + position
    assign(shape, {
      parent: newParent,
      x: shape.x + delta.x,
      y: shape.y + delta.y
    });

    return shape;
  };

  MoveShapeHandler.prototype.postExecute = function (context) {

    var shape = context.shape,
        delta = context.delta,
        hints = context.hints;

    var modeling = this._modeling;

    if (hints.layout !== false) {

      forEach(shape.incoming, function (c) {
        modeling.layoutConnection(c, {
          connectionEnd: getMovedTargetAnchor(c, shape, delta)
        });
      });

      forEach(shape.outgoing, function (c) {
        modeling.layoutConnection(c, {
          connectionStart: getMovedSourceAnchor(c, shape, delta)
        });
      });
    }

    if (hints.recurse !== false) {
      this.moveChildren(context);
    }
  };

  MoveShapeHandler.prototype.revert = function (context) {

    var shape = context.shape,
        oldParent = context.oldParent,
        oldParentIndex = context.oldParentIndex,
        delta = context.delta;

    // restore previous location in old parent
    add(oldParent.children, shape, oldParentIndex);

    // revert to old position and parent
    assign(shape, {
      parent: oldParent,
      x: shape.x - delta.x,
      y: shape.y - delta.y
    });

    return shape;
  };

  MoveShapeHandler.prototype.moveChildren = function (context) {

    var delta = context.delta,
        shape = context.shape;

    this._helper.moveRecursive(shape.children, delta, null);
  };

  MoveShapeHandler.prototype.getNewParent = function (context) {
    return context.newParent || context.shape.parent;
  };

  /**
   * A handler that implements reversible resizing of shapes.
   *
   * @param {Modeling} modeling
   */
  function ResizeShapeHandler(modeling) {
    this._modeling = modeling;
  }

  ResizeShapeHandler.$inject = ['modeling'];

  /**
   * {
   *   shape: {....}
   *   newBounds: {
   *     width:  20,
   *     height: 40,
   *     x:       5,
   *     y:      10
   *   }
   *
   * }
   */
  ResizeShapeHandler.prototype.execute = function (context) {
    var shape = context.shape,
        newBounds = context.newBounds,
        minBounds = context.minBounds;

    if (newBounds.x === undefined || newBounds.y === undefined || newBounds.width === undefined || newBounds.height === undefined) {
      throw new Error('newBounds must have {x, y, width, height} properties');
    }

    if (minBounds && (newBounds.width < minBounds.width || newBounds.height < minBounds.height)) {
      throw new Error('width and height cannot be less than minimum height and width');
    } else if (!minBounds && newBounds.width < 10 || newBounds.height < 10) {
      throw new Error('width and height cannot be less than 10px');
    }

    // save old bbox in context
    context.oldBounds = {
      width: shape.width,
      height: shape.height,
      x: shape.x,
      y: shape.y
    };

    // update shape
    assign(shape, {
      width: newBounds.width,
      height: newBounds.height,
      x: newBounds.x,
      y: newBounds.y
    });

    return shape;
  };

  ResizeShapeHandler.prototype.postExecute = function (context) {

    var shape = context.shape,
        oldBounds = context.oldBounds;

    var modeling = this._modeling;

    forEach(shape.incoming, function (c) {
      modeling.layoutConnection(c, {
        connectionEnd: getResizedTargetAnchor(c, shape, oldBounds)
      });
    });

    forEach(shape.outgoing, function (c) {
      modeling.layoutConnection(c, {
        connectionStart: getResizedSourceAnchor(c, shape, oldBounds)
      });
    });
  };

  ResizeShapeHandler.prototype.revert = function (context) {

    var shape = context.shape,
        oldBounds = context.oldBounds;

    // restore previous bbox
    assign(shape, {
      width: oldBounds.width,
      height: oldBounds.height,
      x: oldBounds.x,
      y: oldBounds.y
    });

    return shape;
  };

  /**
   * A handler that implements reversible replacing of shapes.
   * Internally the old shape will be removed and the new shape will be added.
   *
   *
   * @class
   * @constructor
   *
   * @param {canvas} Canvas
   */
  function ReplaceShapeHandler(modeling, rules) {
    this._modeling = modeling;
    this._rules = rules;
  }

  ReplaceShapeHandler.$inject = ['modeling', 'rules'];

  // api //////////////////////


  /**
   * Replaces a shape with an replacement Element.
   *
   * The newData object should contain type, x, y.
   *
   * If possible also the incoming/outgoing connection
   * will be restored.
   *
   * @param {Object} context
   */
  ReplaceShapeHandler.prototype.preExecute = function (context) {

    var self = this,
        modeling = this._modeling,
        rules = this._rules;

    var oldShape = context.oldShape,
        newData = context.newData,
        hints = context.hints,
        newShape;

    function canReconnect(type, source, target, connection) {
      return rules.allowed(type, {
        source: source,
        target: target,
        connection: connection
      });
    }

    // (1) place a new shape at the given position

    var position = {
      x: newData.x,
      y: newData.y
    };

    newShape = context.newShape = context.newShape || self.createShape(newData, position, oldShape.parent);

    // (2) update the host

    if (oldShape.host) {
      modeling.updateAttachment(newShape, oldShape.host);
    }

    // (3) adopt all children from the old shape

    var children;

    if (hints.moveChildren !== false) {
      children = oldShape.children.slice();

      modeling.moveElements(children, { x: 0, y: 0 }, newShape);
    }

    // (4) reconnect connections to the new shape (where allowed)

    var incoming = oldShape.incoming.slice(),
        outgoing = oldShape.outgoing.slice();

    forEach(incoming, function (connection) {
      var waypoints = connection.waypoints,
          docking = waypoints[waypoints.length - 1],
          source = connection.source,
          allowed = canReconnect('connection.reconnectEnd', source, newShape, connection);

      if (allowed) {
        self.reconnectEnd(connection, newShape, docking);
      }
    });

    forEach(outgoing, function (connection) {
      var waypoints = connection.waypoints,
          docking = waypoints[0],
          target = connection.target,
          allowed = canReconnect('connection.reconnectStart', newShape, target, connection);

      if (allowed) {
        self.reconnectStart(connection, newShape, docking);
      }
    });
  };

  ReplaceShapeHandler.prototype.postExecute = function (context) {
    var modeling = this._modeling;

    var oldShape = context.oldShape,
        newShape = context.newShape;

    // if an element gets resized on replace, layout the connection again
    forEach(newShape.incoming, function (c) {
      modeling.layoutConnection(c, { endChanged: true });
    });

    forEach(newShape.outgoing, function (c) {
      modeling.layoutConnection(c, { startChanged: true });
    });

    modeling.removeShape(oldShape);
  };

  ReplaceShapeHandler.prototype.execute = function (context) {};

  ReplaceShapeHandler.prototype.revert = function (context) {};

  ReplaceShapeHandler.prototype.createShape = function (shape, position, target) {
    var modeling = this._modeling;
    return modeling.createShape(shape, position, target);
  };

  ReplaceShapeHandler.prototype.reconnectStart = function (connection, newSource, dockingPoint) {
    var modeling = this._modeling;
    modeling.reconnectStart(connection, newSource, dockingPoint);
  };

  ReplaceShapeHandler.prototype.reconnectEnd = function (connection, newTarget, dockingPoint) {
    var modeling = this._modeling;
    modeling.reconnectEnd(connection, newTarget, dockingPoint);
  };

  /**
   * A handler that toggles the collapsed state of an element
   * and the visibility of all its children.
   *
   * @param {Modeling} modeling
   */
  function ToggleShapeCollapseHandler(modeling) {
    this._modeling = modeling;
  }

  ToggleShapeCollapseHandler.$inject = ['modeling'];

  ToggleShapeCollapseHandler.prototype.execute = function (context) {

    var shape = context.shape,
        children = shape.children;

    // remember previous visibility of children
    context.oldChildrenVisibility = getElementsVisibility(children);

    // toggle state
    shape.collapsed = !shape.collapsed;

    // hide/show children
    setHidden(children, shape.collapsed);

    return [shape].concat(children);
  };

  ToggleShapeCollapseHandler.prototype.revert = function (context) {

    var shape = context.shape,
        oldChildrenVisibility = context.oldChildrenVisibility;

    var children = shape.children;

    // set old visability of children
    restoreVisibility(children, oldChildrenVisibility);

    // retoggle state
    shape.collapsed = !shape.collapsed;

    return [shape].concat(children);
  };

  // helpers //////////////////////

  /**
   * Return a map { elementId -> hiddenState}.
   *
   * @param {Array<djs.model.Shape>} elements
   *
   * @return {Object}
   */
  function getElementsVisibility(elements) {

    var result = {};

    elements.forEach(function (e) {
      result[e.id] = e.hidden;
    });

    return result;
  }

  function setHidden(elements, newHidden) {
    elements.forEach(function (element) {
      element.hidden = newHidden;
    });
  }

  function restoreVisibility(elements, lastState) {
    elements.forEach(function (e) {
      e.hidden = lastState[e.id];
    });
  }

  /**
   * Get Resize direction given axis + offset
   *
   * @param {String} axis (x|y)
   * @param {Number} offset
   *
   * @return {String} (e|w|n|s)
   */

  /**
   * Resize the given bounds by the specified delta from a given anchor point.
   *
   * @param {Bounds} bounds the bounding box that should be resized
   * @param {String} direction in which the element is resized (n, s, e, w)
   * @param {Point} delta of the resize operation
   *
   * @return {Bounds} resized bounding box
   */
  function resizeBounds(bounds, direction, delta) {

    var dx = delta.x,
        dy = delta.y;

    switch (direction) {

      case 'n':
        return {
          x: bounds.x,
          y: bounds.y + dy,
          width: bounds.width,
          height: bounds.height - dy
        };

      case 's':
        return {
          x: bounds.x,
          y: bounds.y,
          width: bounds.width,
          height: bounds.height + dy
        };

      case 'w':
        return {
          x: bounds.x + dx,
          y: bounds.y,
          width: bounds.width - dx,
          height: bounds.height
        };

      case 'e':
        return {
          x: bounds.x,
          y: bounds.y,
          width: bounds.width + dx,
          height: bounds.height
        };

      default:
        throw new Error('unrecognized direction: ' + direction);
    }
  }

  /**
   * A handler that implements reversible creating and removing of space.
   *
   * It executes in two phases:
   *
   *  (1) resize all affected resizeShapes
   *  (2) move all affected moveElements
   */
  function SpaceToolHandler(modeling) {
    this._modeling = modeling;
  }

  SpaceToolHandler.$inject = ['modeling'];

  SpaceToolHandler.prototype.preExecute = function (context) {

    // resize
    var modeling = this._modeling,
        resizingShapes = context.resizingShapes,
        delta = context.delta,
        direction = context.direction;

    forEach(resizingShapes, function (shape) {
      var newBounds = resizeBounds(shape, direction, delta);

      modeling.resizeShape(shape, newBounds);
    });
  };

  SpaceToolHandler.prototype.postExecute = function (context) {
    // move
    var modeling = this._modeling,
        movingShapes = context.movingShapes,
        delta = context.delta;

    modeling.moveElements(movingShapes, delta, undefined, { autoResize: false, attach: false });
  };

  SpaceToolHandler.prototype.execute = function (context) {};
  SpaceToolHandler.prototype.revert = function (context) {};

  /**
   * A handler that attaches a label to a given target shape.
   *
   * @param {Canvas} canvas
   */
  function CreateLabelHandler(canvas) {
    CreateShapeHandler.call(this, canvas);
  }

  inherits_browser(CreateLabelHandler, CreateShapeHandler);

  CreateLabelHandler.$inject = ['canvas'];

  // api //////////////////////


  var originalExecute = CreateShapeHandler.prototype.execute;

  /**
   * Appends a label to a target shape.
   *
   * @method CreateLabelHandler#execute
   *
   * @param {Object} context
   * @param {ElementDescriptor} context.target the element the label is attached to
   * @param {ElementDescriptor} context.parent the parent object
   * @param {Point} context.position position of the new element
   */
  CreateLabelHandler.prototype.execute = function (context) {

    var label = context.shape;

    ensureValidDimensions(label);

    label.labelTarget = context.labelTarget;

    return originalExecute.call(this, context);
  };

  var originalRevert = CreateShapeHandler.prototype.revert;

  /**
   * Undo append by removing the shape
   */
  CreateLabelHandler.prototype.revert = function (context) {
    context.shape.labelTarget = null;

    return originalRevert.call(this, context);
  };

  // helpers //////////////////////

  function ensureValidDimensions(label) {
    // make sure a label has valid { width, height } dimensions
    ['width', 'height'].forEach(function (prop) {
      if (typeof label[prop] === 'undefined') {
        label[prop] = 0;
      }
    });
  }

  function CreateConnectionHandler(canvas, layouter) {
    this._canvas = canvas;
    this._layouter = layouter;
  }

  CreateConnectionHandler.$inject = ['canvas', 'layouter'];

  // api //////////////////////


  /**
   * Appends a shape to a target shape
   *
   * @param {Object} context
   * @param {djs.element.Base} context.source the source object
   * @param {djs.element.Base} context.target the parent object
   * @param {Point} context.position position of the new element
   */
  CreateConnectionHandler.prototype.execute = function (context) {

    var connection = context.connection,
        source = context.source,
        target = context.target,
        parent = context.parent,
        parentIndex = context.parentIndex,
        hints = context.hints;

    if (!source || !target) {
      throw new Error('source and target required');
    }

    if (!parent) {
      throw new Error('parent required');
    }

    connection.source = source;
    connection.target = target;

    if (!connection.waypoints) {
      connection.waypoints = this._layouter.layoutConnection(connection, hints);
    }

    // add connection
    this._canvas.addConnection(connection, parent, parentIndex);

    return connection;
  };

  CreateConnectionHandler.prototype.revert = function (context) {
    var connection = context.connection;

    this._canvas.removeConnection(connection);

    connection.source = null;
    connection.target = null;
  };

  /**
   * A handler that implements reversible deletion of Connections.
   */
  function DeleteConnectionHandler(canvas, modeling) {
    this._canvas = canvas;
    this._modeling = modeling;
  }

  DeleteConnectionHandler.$inject = ['canvas', 'modeling'];

  DeleteConnectionHandler.prototype.execute = function (context) {

    var connection = context.connection,
        parent = connection.parent;

    context.parent = parent;

    // remember containment
    context.parentIndex = indexOf$1(parent.children, connection);

    context.source = connection.source;
    context.target = connection.target;

    this._canvas.removeConnection(connection);

    connection.source = null;
    connection.target = null;

    return connection;
  };

  /**
   * Command revert implementation.
   */
  DeleteConnectionHandler.prototype.revert = function (context) {

    var connection = context.connection,
        parent = context.parent,
        parentIndex = context.parentIndex;

    connection.source = context.source;
    connection.target = context.target;

    // restore containment
    add(parent.children, connection, parentIndex);

    this._canvas.addConnection(connection, parent);

    return connection;
  };

  /**
   * A handler that implements reversible moving of connections.
   *
   * The handler differs from the layout connection handler in a sense
   * that it preserves the connection layout.
   */
  function MoveConnectionHandler() {}

  MoveConnectionHandler.prototype.execute = function (context) {

    var connection = context.connection,
        delta = context.delta;

    var newParent = context.newParent || connection.parent,
        newParentIndex = context.newParentIndex,
        oldParent = connection.parent;

    // save old parent in context
    context.oldParent = oldParent;
    context.oldParentIndex = remove$2(oldParent.children, connection);

    // add to new parent at position
    add(newParent.children, connection, newParentIndex);

    // update parent
    connection.parent = newParent;

    // update waypoint positions
    forEach(connection.waypoints, function (p) {
      p.x += delta.x;
      p.y += delta.y;

      if (p.original) {
        p.original.x += delta.x;
        p.original.y += delta.y;
      }
    });

    return connection;
  };

  MoveConnectionHandler.prototype.revert = function (context) {

    var connection = context.connection,
        newParent = connection.parent,
        oldParent = context.oldParent,
        oldParentIndex = context.oldParentIndex,
        delta = context.delta;

    // remove from newParent
    remove$2(newParent.children, connection);

    // restore previous location in old parent
    add(oldParent.children, connection, oldParentIndex);

    // restore parent
    connection.parent = oldParent;

    // revert to old waypoint positions
    forEach(connection.waypoints, function (p) {
      p.x -= delta.x;
      p.y -= delta.y;

      if (p.original) {
        p.original.x -= delta.x;
        p.original.y -= delta.y;
      }
    });

    return connection;
  };

  /**
   * A handler that implements reversible moving of shapes.
   */
  function LayoutConnectionHandler(layouter, canvas) {
    this._layouter = layouter;
    this._canvas = canvas;
  }

  LayoutConnectionHandler.$inject = ['layouter', 'canvas'];

  LayoutConnectionHandler.prototype.execute = function (context) {

    var connection = context.connection;

    var oldWaypoints = connection.waypoints;

    assign(context, {
      oldWaypoints: oldWaypoints
    });

    connection.waypoints = this._layouter.layoutConnection(connection, context.hints);

    return connection;
  };

  LayoutConnectionHandler.prototype.revert = function (context) {

    var connection = context.connection;

    connection.waypoints = context.oldWaypoints;

    return connection;
  };

  function UpdateWaypointsHandler() {}

  UpdateWaypointsHandler.prototype.execute = function (context) {

    var connection = context.connection,
        newWaypoints = context.newWaypoints;

    context.oldWaypoints = connection.waypoints;

    connection.waypoints = newWaypoints;

    return connection;
  };

  UpdateWaypointsHandler.prototype.revert = function (context) {

    var connection = context.connection,
        oldWaypoints = context.oldWaypoints;

    connection.waypoints = oldWaypoints;

    return connection;
  };

  /**
   * Reconnect connection handler
   */
  function ReconnectConnectionHandler() {}

  ReconnectConnectionHandler.$inject = [];

  ReconnectConnectionHandler.prototype.execute = function (context) {

    var newSource = context.newSource,
        newTarget = context.newTarget,
        connection = context.connection,
        dockingOrPoints = context.dockingOrPoints,
        oldWaypoints = connection.waypoints,
        newWaypoints;

    if (!newSource && !newTarget) {
      throw new Error('newSource or newTarget are required');
    }

    if (newSource && newTarget) {
      throw new Error('must specify either newSource or newTarget');
    }

    context.oldWaypoints = oldWaypoints;

    if (isArray(dockingOrPoints)) {
      newWaypoints = dockingOrPoints;
    } else {
      newWaypoints = oldWaypoints.slice();

      newWaypoints.splice(newSource ? 0 : -1, 1, dockingOrPoints);
    }

    if (newSource) {
      context.oldSource = connection.source;
      connection.source = newSource;
    }

    if (newTarget) {
      context.oldTarget = connection.target;
      connection.target = newTarget;
    }

    connection.waypoints = newWaypoints;

    return connection;
  };

  ReconnectConnectionHandler.prototype.revert = function (context) {

    var newSource = context.newSource,
        newTarget = context.newTarget,
        connection = context.connection;

    if (newSource) {
      connection.source = context.oldSource;
    }

    if (newTarget) {
      connection.target = context.oldTarget;
    }

    connection.waypoints = context.oldWaypoints;

    return connection;
  };

  /**
   * A handler that implements reversible moving of shapes.
   */
  function MoveElementsHandler(modeling) {
    this._helper = new MoveHelper(modeling);
  }

  MoveElementsHandler.$inject = ['modeling'];

  MoveElementsHandler.prototype.preExecute = function (context) {
    context.closure = this._helper.getClosure(context.shapes);
  };

  MoveElementsHandler.prototype.postExecute = function (context) {

    var hints = context.hints,
        primaryShape;

    if (hints && hints.primaryShape) {
      primaryShape = hints.primaryShape;
      hints.oldParent = primaryShape.parent;
    }

    this._helper.moveClosure(context.closure, context.delta, context.newParent, context.newHost, primaryShape);
  };

  function DeleteElementsHandler(modeling, elementRegistry) {
    this._modeling = modeling;
    this._elementRegistry = elementRegistry;
  }

  DeleteElementsHandler.$inject = ['modeling', 'elementRegistry'];

  DeleteElementsHandler.prototype.postExecute = function (context) {

    var modeling = this._modeling,
        elementRegistry = this._elementRegistry,
        elements = context.elements;

    forEach(elements, function (element) {

      // element may have been removed with previous
      // remove operations already (e.g. in case of nesting)
      if (!elementRegistry.get(element.id)) {
        return;
      }

      if (element.waypoints) {
        modeling.removeConnection(element);
      } else {
        modeling.removeShape(element);
      }
    });
  };

  /**
   * A handler that distributes elements evenly.
   */
  function DistributeElements(modeling) {
    this._modeling = modeling;
  }

  DistributeElements.$inject = ['modeling'];

  var OFF_AXIS = {
    x: 'y',
    y: 'x'
  };

  DistributeElements.prototype.preExecute = function (context) {
    var modeling = this._modeling;

    var groups = context.groups,
        axis = context.axis,
        dimension = context.dimension;

    function updateRange(group, element) {
      group.range.min = Math.min(element[axis], group.range.min);
      group.range.max = Math.max(element[axis] + element[dimension], group.range.max);
    }

    function center(element) {
      return element[axis] + element[dimension] / 2;
    }

    function lastIdx(arr) {
      return arr.length - 1;
    }

    function rangeDiff(range) {
      return range.max - range.min;
    }

    function centerElement(refCenter, element) {
      var delta = { y: 0 };

      delta[axis] = refCenter - center(element);

      if (delta[axis]) {

        delta[OFF_AXIS[axis]] = 0;

        modeling.moveElements([element], delta, element.parent);
      }
    }

    var firstGroup = groups[0],
        lastGroupIdx = lastIdx(groups),
        lastGroup = groups[lastGroupIdx];

    var margin,
        spaceInBetween,
        groupsSize = 0; // the size of each range

    forEach(groups, function (group, idx) {
      var sortedElements, refElem, refCenter;

      if (group.elements.length < 2) {
        if (idx && idx !== groups.length - 1) {
          updateRange(group, group.elements[0]);

          groupsSize += rangeDiff(group.range);
        }
        return;
      }

      sortedElements = sortBy(group.elements, axis);

      refElem = sortedElements[0];

      if (idx === lastGroupIdx) {
        refElem = sortedElements[lastIdx(sortedElements)];
      }

      refCenter = center(refElem);

      // wanna update the ranges after the shapes have been centered
      group.range = null;

      forEach(sortedElements, function (element) {

        centerElement(refCenter, element);

        if (group.range === null) {
          group.range = {
            min: element[axis],
            max: element[axis] + element[dimension]
          };

          return;
        }

        // update group's range after centering the range elements
        updateRange(group, element);
      });

      if (idx && idx !== groups.length - 1) {
        groupsSize += rangeDiff(group.range);
      }
    });

    spaceInBetween = Math.abs(lastGroup.range.min - firstGroup.range.max);

    margin = Math.round((spaceInBetween - groupsSize) / (groups.length - 1));

    if (margin < groups.length - 1) {
      return;
    }

    forEach(groups, function (group, groupIdx) {
      var delta = {},
          prevGroup;

      if (group === firstGroup || group === lastGroup) {
        return;
      }

      prevGroup = groups[groupIdx - 1];

      group.range.max = 0;

      forEach(group.elements, function (element, idx) {
        delta[OFF_AXIS[axis]] = 0;
        delta[axis] = prevGroup.range.max - element[axis] + margin;

        if (group.range.min !== element[axis]) {
          delta[axis] += element[axis] - group.range.min;
        }

        if (delta[axis]) {
          modeling.moveElements([element], delta, element.parent);
        }

        group.range.max = Math.max(element[axis] + element[dimension], idx ? group.range.max : 0);
      });
    });
  };

  DistributeElements.prototype.postExecute = function (context) {};

  /**
   * A handler that align elements in a certain way.
   *
   */
  function AlignElements(modeling, canvas) {
    this._modeling = modeling;
    this._canvas = canvas;
  }

  AlignElements.$inject = ['modeling', 'canvas'];

  AlignElements.prototype.preExecute = function (context) {
    var modeling = this._modeling;

    var elements = context.elements,
        alignment = context.alignment;

    forEach(elements, function (element) {
      var delta = {
        x: 0,
        y: 0
      };

      if (alignment.left) {
        delta.x = alignment.left - element.x;
      } else if (alignment.right) {
        delta.x = alignment.right - element.width - element.x;
      } else if (alignment.center) {
        delta.x = alignment.center - Math.round(element.width / 2) - element.x;
      } else if (alignment.top) {
        delta.y = alignment.top - element.y;
      } else if (alignment.bottom) {
        delta.y = alignment.bottom - element.height - element.y;
      } else if (alignment.middle) {
        delta.y = alignment.middle - Math.round(element.height / 2) - element.y;
      }

      modeling.moveElements([element], delta, element.parent);
    });
  };

  AlignElements.prototype.postExecute = function (context) {};

  /**
   * A handler that implements reversible attaching/detaching of shapes.
   */
  function UpdateAttachmentHandler(modeling) {
    this._modeling = modeling;
  }

  UpdateAttachmentHandler.$inject = ['modeling'];

  UpdateAttachmentHandler.prototype.execute = function (context) {
    var shape = context.shape,
        newHost = context.newHost,
        oldHost = shape.host;

    // (0) detach from old host
    context.oldHost = oldHost;
    context.attacherIdx = removeAttacher(oldHost, shape);

    // (1) attach to new host
    addAttacher(newHost, shape);

    // (2) update host
    shape.host = newHost;

    return shape;
  };

  UpdateAttachmentHandler.prototype.revert = function (context) {
    var shape = context.shape,
        newHost = context.newHost,
        oldHost = context.oldHost,
        attacherIdx = context.attacherIdx;

    // (2) update host
    shape.host = oldHost;

    // (1) attach to new host
    removeAttacher(newHost, shape);

    // (0) detach from old host
    addAttacher(oldHost, shape, attacherIdx);

    return shape;
  };

  function removeAttacher(host, attacher) {
    // remove attacher from host
    return remove$2(host && host.attachers, attacher);
  }

  function addAttacher(host, attacher, idx) {

    if (!host) {
      return;
    }

    var attachers = host.attachers;

    if (!attachers) {
      host.attachers = attachers = [];
    }

    add(attachers, attacher, idx);
  }

  function removeProperties(element, properties) {
    forEach(properties, function (prop) {
      if (element[prop]) {
        delete element[prop];
      }
    });
  }

  /**
   * A handler that implements pasting of elements onto the diagram.
   *
   * @param {eventBus} EventBus
   * @param {canvas} Canvas
   * @param {selection} Selection
   * @param {elementFactory} ElementFactory
   * @param {modeling} Modeling
   * @param {rules} Rules
   */
  function PasteHandler(eventBus, canvas, selection, elementFactory, modeling, rules) {

    this._eventBus = eventBus;
    this._canvas = canvas;
    this._selection = selection;
    this._elementFactory = elementFactory;
    this._modeling = modeling;
    this._rules = rules;
  }

  PasteHandler.$inject = ['eventBus', 'canvas', 'selection', 'elementFactory', 'modeling', 'rules'];

  // api //////////////////////

  /**
   * Creates a new shape
   *
   * @param {Object} context
   * @param {Object} context.tree the new shape
   * @param {Element} context.topParent the paste target
   */
  PasteHandler.prototype.preExecute = function (context) {
    var eventBus = this._eventBus,
        self = this;

    var tree = context.tree,
        topParent = context.topParent,
        position = context.position;

    tree.createdElements = {};

    tree.labels = [];

    forEach(tree, function (elements, depthStr) {
      var depth = parseInt(depthStr, 10);

      if (isNaN(depth)) {
        return;
      }

      // set the parent on the top level elements
      if (!depth) {
        elements = map(elements, function (descriptor) {
          descriptor.parent = topParent;

          return descriptor;
        });
      }

      // Order by priority for element creation
      elements = sortBy(elements, 'priority');

      forEach(elements, function (descriptor) {
        var id = descriptor.id,
            parent = descriptor.parent,
            hints = {},
            newPosition;

        var element = assign({}, descriptor);

        if (depth) {
          element.parent = self._getCreatedElement(parent, tree);
        }

        // this happens when shapes have not been created due to rules
        if (!parent) {
          return;
        }

        eventBus.fire('element.paste', {
          createdElements: tree.createdElements,
          descriptor: element
        });

        // in case the parent changed during 'element.paste'
        parent = element.parent;

        if (element.waypoints) {
          element = self._createConnection(element, parent, position, tree);

          if (element) {
            tree.createdElements[id] = {
              element: element,
              descriptor: descriptor
            };
          }

          return;
        }

        // supply not-root information as hint
        if (element.parent !== topParent) {
          hints.root = false;
        }

        // set host
        if (element.host) {
          hints.attach = true;

          parent = self._getCreatedElement(element.host, tree);
        }

        // handle labels
        if (element.labelTarget) {
          return tree.labels.push(element);
        }

        newPosition = {
          x: Math.round(position.x + element.delta.x + element.width / 2),
          y: Math.round(position.y + element.delta.y + element.height / 2)
        };

        removeProperties(element, ['id', 'parent', 'delta', 'host', 'priority']);

        element = self._createShape(element, parent, newPosition, hints);

        if (element) {
          tree.createdElements[id] = {
            element: element,
            descriptor: descriptor
          };
        }
      });
    });
  };

  // move label's to their relative position
  PasteHandler.prototype.postExecute = function (context) {
    var modeling = this._modeling,
        selection = this._selection,
        self = this;

    var tree = context.tree,
        labels = tree.labels,
        topLevelElements = [];

    forEach(labels, function (labelDescriptor) {
      var labelTarget = self._getCreatedElement(labelDescriptor.labelTarget, tree),
          labels,
          labelTargetPos,
          newPosition;

      if (!labelTarget) {
        return;
      }

      labels = labelTarget.labels;

      if (!labels || !labels.length) {
        return;
      }

      labelTargetPos = {
        x: labelTarget.x,
        y: labelTarget.y
      };

      if (labelTarget.waypoints) {
        labelTargetPos = labelTarget.waypoints[0];
      }

      forEach(labels, function (label) {
        newPosition = {
          x: Math.round(labelTargetPos.x - label.x + labelDescriptor.delta.x),
          y: Math.round(labelTargetPos.y - label.y + labelDescriptor.delta.y)
        };

        modeling.moveShape(label, newPosition, labelTarget.parent);
      });
    });

    forEach(tree[0], function (descriptor) {
      var id = descriptor.id,
          toplevel = tree.createdElements[id];

      if (toplevel) {
        topLevelElements.push(toplevel.element);
      }
    });

    selection.select(topLevelElements);
  };

  PasteHandler.prototype._createConnection = function (element, parent, parentCenter, tree) {
    var modeling = this._modeling,
        rules = this._rules;

    var connection, source, target, canPaste;

    element.waypoints = map(element.waypoints, function (waypoint, idx) {
      return {
        x: Math.round(parentCenter.x + element.delta[idx].x),
        y: Math.round(parentCenter.y + element.delta[idx].y)
      };
    });

    source = this._getCreatedElement(element.source, tree);
    target = this._getCreatedElement(element.target, tree);

    if (!source || !target) {
      return null;
    }

    canPaste = rules.allowed('element.paste', {
      source: source,
      target: target
    });

    if (!canPaste) {
      return null;
    }

    removeProperties(element, ['id', 'parent', 'delta', 'source', 'target', 'width', 'height', 'priority']);

    connection = modeling.createConnection(source, target, element, parent);

    return connection;
  };

  PasteHandler.prototype._createShape = function (element, parent, position, isAttach, hints) {
    var modeling = this._modeling,
        elementFactory = this._elementFactory,
        rules = this._rules;

    var canPaste = rules.allowed('element.paste', {
      element: element,
      position: position,
      parent: parent
    });

    if (!canPaste) {
      return null;
    }

    var shape = elementFactory.createShape(element);

    modeling.createShape(shape, position, parent, isAttach, hints);

    return shape;
  };

  PasteHandler.prototype._getCreatedElement = function (id, tree) {
    return tree.createdElements[id] && tree.createdElements[id].element;
  };

  var _typeof$8 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  /**
   * The basic modeling entry point.
   *
   * @param {EventBus} eventBus
   * @param {ElementFactory} elementFactory
   * @param {CommandStack} commandStack
   */
  function Modeling(eventBus, elementFactory, commandStack) {
    this._eventBus = eventBus;
    this._elementFactory = elementFactory;
    this._commandStack = commandStack;

    var self = this;

    eventBus.on('diagram.init', function () {
      // register modeling handlers
      self.registerHandlers(commandStack);
    });
  }

  Modeling.$inject = ['eventBus', 'elementFactory', 'commandStack'];

  Modeling.prototype.getHandlers = function () {
    return {
      'shape.append': AppendShapeHandler,
      'shape.create': CreateShapeHandler,
      'shape.delete': DeleteShapeHandler,
      'shape.move': MoveShapeHandler,
      'shape.resize': ResizeShapeHandler,
      'shape.replace': ReplaceShapeHandler,
      'shape.toggleCollapse': ToggleShapeCollapseHandler,

      'spaceTool': SpaceToolHandler,

      'label.create': CreateLabelHandler,

      'connection.create': CreateConnectionHandler,
      'connection.delete': DeleteConnectionHandler,
      'connection.move': MoveConnectionHandler,
      'connection.layout': LayoutConnectionHandler,

      'connection.updateWaypoints': UpdateWaypointsHandler,

      'connection.reconnectStart': ReconnectConnectionHandler,
      'connection.reconnectEnd': ReconnectConnectionHandler,

      'elements.move': MoveElementsHandler,
      'elements.delete': DeleteElementsHandler,

      'elements.distribute': DistributeElements,
      'elements.align': AlignElements,

      'element.updateAttachment': UpdateAttachmentHandler,

      'elements.paste': PasteHandler
    };
  };

  /**
   * Register handlers with the command stack
   *
   * @param {CommandStack} commandStack
   */
  Modeling.prototype.registerHandlers = function (commandStack) {
    forEach(this.getHandlers(), function (handler, id) {
      commandStack.registerHandler(id, handler);
    });
  };

  // modeling helpers //////////////////////

  Modeling.prototype.moveShape = function (shape, delta, newParent, newParentIndex, hints) {

    if ((typeof newParentIndex === 'undefined' ? 'undefined' : _typeof$8(newParentIndex)) === 'object') {
      hints = newParentIndex;
      newParentIndex = null;
    }

    var context = {
      shape: shape,
      delta: delta,
      newParent: newParent,
      newParentIndex: newParentIndex,
      hints: hints || {}
    };

    this._commandStack.execute('shape.move', context);
  };

  /**
   * Update the attachment of the given shape.
   *
   * @param {djs.mode.Base} shape
   * @param {djs.model.Base} [newHost]
   */
  Modeling.prototype.updateAttachment = function (shape, newHost) {
    var context = {
      shape: shape,
      newHost: newHost
    };

    this._commandStack.execute('element.updateAttachment', context);
  };

  /**
   * Move a number of shapes to a new target, either setting it as
   * the new parent or attaching it.
   *
   * @param {Array<djs.mode.Base>} shapes
   * @param {Point} delta
   * @param {djs.model.Base} [target]
   * @param {Object} [hints]
   * @param {Boolean} [hints.attach=false]
   */
  Modeling.prototype.moveElements = function (shapes, delta, target, hints) {

    hints = hints || {};

    var attach = hints.attach;

    var newParent = target,
        newHost;

    if (attach === true) {
      newHost = target;
      newParent = target.parent;
    } else if (attach === false) {
      newHost = null;
    }

    var context = {
      shapes: shapes,
      delta: delta,
      newParent: newParent,
      newHost: newHost,
      hints: hints
    };

    this._commandStack.execute('elements.move', context);
  };

  Modeling.prototype.moveConnection = function (connection, delta, newParent, newParentIndex, hints) {

    if ((typeof newParentIndex === 'undefined' ? 'undefined' : _typeof$8(newParentIndex)) === 'object') {
      hints = newParentIndex;
      newParentIndex = undefined;
    }

    var context = {
      connection: connection,
      delta: delta,
      newParent: newParent,
      newParentIndex: newParentIndex,
      hints: hints || {}
    };

    this._commandStack.execute('connection.move', context);
  };

  Modeling.prototype.layoutConnection = function (connection, hints) {
    var context = {
      connection: connection,
      hints: hints || {}
    };

    this._commandStack.execute('connection.layout', context);
  };

  /**
   * Create connection.
   *
   * @param {djs.model.Base} source
   * @param {djs.model.Base} target
   * @param {Number} [targetIndex]
   * @param {Object|djs.model.Connection} connection
   * @param {djs.model.Base} parent
   * @param {Object} hints
   *
   * @return {djs.model.Connection} the created connection.
   */
  Modeling.prototype.createConnection = function (source, target, parentIndex, connection, parent, hints) {

    if ((typeof parentIndex === 'undefined' ? 'undefined' : _typeof$8(parentIndex)) === 'object') {
      hints = parent;
      parent = connection;
      connection = parentIndex;
      parentIndex = undefined;
    }

    connection = this._create('connection', connection);

    var context = {
      source: source,
      target: target,
      parent: parent,
      parentIndex: parentIndex,
      connection: connection,
      hints: hints
    };

    this._commandStack.execute('connection.create', context);

    return context.connection;
  };

  /**
   * Create a shape at the specified position.
   *
   * @param {djs.model.Shape|Object} shape
   * @param {Point} position
   * @param {djs.model.Shape|djs.model.Root} target
   * @param {Number} [parentIndex] position in parents children list
   * @param {Object} [hints]
   * @param {Boolean} [hints.attach] whether to attach to target or become a child
   *
   * @return {djs.model.Shape} the created shape
   */
  Modeling.prototype.createShape = function (shape, position, target, parentIndex, hints) {

    if (typeof parentIndex !== 'number') {
      hints = parentIndex;
      parentIndex = undefined;
    }

    hints = hints || {};

    var attach = hints.attach,
        parent,
        host;

    shape = this._create('shape', shape);

    if (attach) {
      parent = target.parent;
      host = target;
    } else {
      parent = target;
    }

    var context = {
      position: position,
      shape: shape,
      parent: parent,
      parentIndex: parentIndex,
      host: host,
      hints: hints
    };

    this._commandStack.execute('shape.create', context);

    return context.shape;
  };

  Modeling.prototype.createLabel = function (labelTarget, position, label, parent) {

    label = this._create('label', label);

    var context = {
      labelTarget: labelTarget,
      position: position,
      parent: parent || labelTarget.parent,
      shape: label
    };

    this._commandStack.execute('label.create', context);

    return context.shape;
  };

  /**
   * Append shape to given source, drawing a connection
   * between source and the newly created shape.
   *
   * @param {djs.model.Shape} source
   * @param {djs.model.Shape|Object} shape
   * @param {Point} position
   * @param {djs.model.Shape} target
   * @param {Object} [hints]
   * @param {Boolean} [hints.attach]
   * @param {djs.model.Connection|Object} [hints.connection]
   * @param {djs.model.Base} [hints.connectionParent]
   *
   * @return {djs.model.Shape} the newly created shape
   */
  Modeling.prototype.appendShape = function (source, shape, position, target, hints) {

    hints = hints || {};

    shape = this._create('shape', shape);

    var context = {
      source: source,
      position: position,
      target: target,
      shape: shape,
      connection: hints.connection,
      connectionParent: hints.connectionParent,
      attach: hints.attach
    };

    this._commandStack.execute('shape.append', context);

    return context.shape;
  };

  Modeling.prototype.removeElements = function (elements) {
    var context = {
      elements: elements
    };

    this._commandStack.execute('elements.delete', context);
  };

  Modeling.prototype.distributeElements = function (groups, axis, dimension) {
    var context = {
      groups: groups,
      axis: axis,
      dimension: dimension
    };

    this._commandStack.execute('elements.distribute', context);
  };

  Modeling.prototype.removeShape = function (shape, hints) {
    var context = {
      shape: shape,
      hints: hints || {}
    };

    this._commandStack.execute('shape.delete', context);
  };

  Modeling.prototype.removeConnection = function (connection, hints) {
    var context = {
      connection: connection,
      hints: hints || {}
    };

    this._commandStack.execute('connection.delete', context);
  };

  Modeling.prototype.replaceShape = function (oldShape, newShape, hints) {
    var context = {
      oldShape: oldShape,
      newData: newShape,
      hints: hints || {}
    };

    this._commandStack.execute('shape.replace', context);

    return context.newShape;
  };

  Modeling.prototype.pasteElements = function (tree, topParent, position) {
    var context = {
      tree: tree,
      topParent: topParent,
      position: position
    };

    this._commandStack.execute('elements.paste', context);
  };

  Modeling.prototype.alignElements = function (elements, alignment) {
    var context = {
      elements: elements,
      alignment: alignment
    };

    this._commandStack.execute('elements.align', context);
  };

  Modeling.prototype.resizeShape = function (shape, newBounds, minBounds) {
    var context = {
      shape: shape,
      newBounds: newBounds,
      minBounds: minBounds
    };

    this._commandStack.execute('shape.resize', context);
  };

  Modeling.prototype.createSpace = function (movingShapes, resizingShapes, delta, direction) {
    var context = {
      movingShapes: movingShapes,
      resizingShapes: resizingShapes,
      delta: delta,
      direction: direction
    };

    this._commandStack.execute('spaceTool', context);
  };

  Modeling.prototype.updateWaypoints = function (connection, newWaypoints, hints) {
    var context = {
      connection: connection,
      newWaypoints: newWaypoints,
      hints: hints || {}
    };

    this._commandStack.execute('connection.updateWaypoints', context);
  };

  Modeling.prototype.reconnectStart = function (connection, newSource, dockingOrPoints) {
    var context = {
      connection: connection,
      newSource: newSource,
      dockingOrPoints: dockingOrPoints
    };

    this._commandStack.execute('connection.reconnectStart', context);
  };

  Modeling.prototype.reconnectEnd = function (connection, newTarget, dockingOrPoints) {
    var context = {
      connection: connection,
      newTarget: newTarget,
      dockingOrPoints: dockingOrPoints
    };

    this._commandStack.execute('connection.reconnectEnd', context);
  };

  Modeling.prototype.connect = function (source, target, attrs, hints) {
    return this.createConnection(source, target, attrs || {}, source.parent, hints);
  };

  Modeling.prototype._create = function (type, attrs) {
    if (attrs instanceof Base$1) {
      return attrs;
    } else {
      return this._elementFactory.create(type, attrs);
    }
  };

  Modeling.prototype.toggleCollapse = function (shape, hints) {
    var context = {
      shape: shape,
      hints: hints || {}
    };

    this._commandStack.execute('shape.toggleCollapse', context);
  };

  var NAME = 'name',
      ID = 'id';

  /**
   * A handler that implements a DMN property update.
   *
   * This should be used to set simple properties on elements with
   * an underlying DMN business object.
   *
   * Use respective diagram-js provided handlers if you would
   * like to perform automated modeling.
   */
  function UpdatePropertiesHandler(elementRegistry, moddle) {
    this._elementRegistry = elementRegistry;
    this._moddle = moddle;
  }

  UpdatePropertiesHandler.$inject = ['elementRegistry', 'moddle'];

  /**
   * Updates a DMN element with a list of new properties
   *
   * @param {Object} context
   * @param {djs.model.Base} context.element the element to update
   * @param {Object} context.properties a list of properties to set on the element's
   *                                    businessObject (the DMN model element)
   *
   * @return {Array<djs.model.Base>} the updated element
   */
  UpdatePropertiesHandler.prototype.execute = function (context) {

    var element = context.element,
        changed = [element];

    if (!element) {
      throw new Error('element required');
    }

    var elementRegistry = this._elementRegistry,
        ids = this._moddle.ids;

    var businessObject = element.businessObject,
        properties = context.properties,
        oldProperties = context.oldProperties || getProperties(businessObject, keys(properties));

    if (isIdChange(properties, businessObject)) {
      ids.unclaim(businessObject[ID]);

      elementRegistry.updateId(element, properties[ID]);

      ids.claim(properties[ID], businessObject);
    }

    if (NAME in properties && element.label) {
      changed.push(element.label);
    }

    // update properties
    setProperties(businessObject, properties);

    // store old values
    context.oldProperties = oldProperties;
    context.changed = changed;

    // indicate changed on objects affected by the update
    return changed;
  };

  /**
   * Reverts the update on a DMN elements properties.
   *
   * @param  {Object} context
   *
   * @return {djs.model.Base} the updated element
   */
  UpdatePropertiesHandler.prototype.revert = function (context) {

    var element = context.element,
        properties = context.properties,
        oldProperties = context.oldProperties,
        businessObject = element.businessObject,
        elementRegistry = this._elementRegistry,
        ids = this._moddle.ids;

    // update properties
    setProperties(businessObject, oldProperties);

    if (isIdChange(properties, businessObject)) {
      ids.unclaim(properties[ID]);

      elementRegistry.updateId(element, oldProperties[ID]);

      ids.claim(oldProperties[ID], businessObject);
    }

    return context.changed;
  };

  function isIdChange(properties, businessObject) {
    return ID in properties && properties[ID] !== businessObject[ID];
  }

  function getProperties(businessObject, propertyNames) {
    return reduce(propertyNames, function (result, key) {
      result[key] = businessObject.get(key);
      return result;
    }, {});
  }

  function setProperties(businessObject, properties) {
    forEach(properties, function (value, key) {
      businessObject.set(key, value);
    });
  }

  function IdClaimHandler(moddle) {
    this._moddle = moddle;
  }

  IdClaimHandler.$inject = ['moddle'];

  IdClaimHandler.prototype.execute = function (context) {
    var ids = this._moddle.ids,
        id = context.id,
        element = context.element,
        claiming = context.claiming;

    if (claiming) {
      ids.claim(id, element);
    } else {
      ids.unclaim(id);
    }
  };

  /**
   * Command revert implementation.
   */
  IdClaimHandler.prototype.revert = function (context) {
    var ids = this._moddle.ids,
        id = context.id,
        element = context.element,
        claiming = context.claiming;

    if (claiming) {
      ids.unclaim(id);
    } else {
      ids.claim(id, element);
    }
  };

  /**
   * DMN 1.1 modeling features activator
   *
   * @param {Canvas} canvas
   * @param {EventBus} eventBus
   * @param {ElementFactory} elementFactory
   * @param {CommandStack} commandStack
   * @param {DrdRules} drdRules
   */
  function Modeling$1(canvas, eventBus, elementFactory, commandStack, drdRules) {

    this._canvas = canvas;
    this._drdRules = drdRules;

    Modeling.call(this, eventBus, elementFactory, commandStack);
  }

  inherits_browser(Modeling$1, Modeling);

  Modeling$1.$inject = ['canvas', 'eventBus', 'elementFactory', 'commandStack', 'drdRules'];

  Modeling$1.prototype.getHandlers = function () {
    var handlers = Modeling.prototype.getHandlers.call(this);

    handlers['element.updateProperties'] = UpdatePropertiesHandler;
    handlers['id.updateClaim'] = IdClaimHandler;

    return handlers;
  };

  Modeling$1.prototype.updateProperties = function (element, properties) {
    this._commandStack.execute('element.updateProperties', {
      element: element,
      properties: properties
    });
  };

  Modeling$1.prototype.claimId = function (id, moddleElement) {
    this._commandStack.execute('id.updateClaim', {
      id: id,
      element: moddleElement,
      claiming: true
    });
  };

  Modeling$1.prototype.unclaimId = function (id, moddleElement) {
    this._commandStack.execute('id.updateClaim', {
      id: id,
      element: moddleElement
    });
  };

  Modeling$1.prototype.connect = function (source, target, attrs, hints) {

    var drdRules = this._drdRules,
        rootElement = this._canvas.getRootElement();

    if (!attrs) {
      attrs = drdRules.canConnect(source, target) || { type: 'dmn:Association' };
    }

    return this.createConnection(source, target, attrs, rootElement, hints);
  };

  /**
   * A base connection layouter implementation
   * that layouts the connection by directly connecting
   * mid(source) + mid(target).
   */
  function BaseLayouter() {}

  /**
   * Return the new layouted waypoints for the given connection.
   *
   * The connection passed is still unchanged; you may figure out about
   * the new connection start / end via the layout hints provided.
   *
   * @param {djs.model.Connection} connection
   * @param {Object} [hints]
   * @param {Point} [hints.connectionStart]
   * @param {Point} [hints.connectionEnd]
   *
   * @return {Array<Point>} the layouted connection waypoints
   */
  BaseLayouter.prototype.layoutConnection = function (connection, hints) {

    hints = hints || {};

    return [hints.connectionStart || getMid(connection.source), hints.connectionEnd || getMid(connection.target)];
  };

  function DrdLayouter() {}

  inherits_browser(DrdLayouter, BaseLayouter);

  DrdLayouter.prototype.layoutConnection = function (connection, hints) {

    hints = hints || {};

    var source = connection.source,
        target = connection.target,
        waypoints = connection.waypoints,
        start = hints.connectionStart,
        end = hints.connectionEnd,
        middle;

    waypoints = waypoints || [];

    middle = waypoints.slice(1, waypoints.length - 1);

    if (!start) {
      start = getConnectionDocking(waypoints && waypoints[0], source);
    }

    if (!end) {
      end = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);
    }

    return [start].concat(middle, [end]);
  };

  function getConnectionDocking(point, shape) {
    return point ? point.original || point : getMid(shape);
  }

  function dockingToPoint(docking) {
    // use the dockings actual point and
    // retain the original docking
    return assign({ original: docking.point.original || docking.point }, docking.actual);
  }

  /**
   * A {@link ConnectionDocking} that crops connection waypoints based on
   * the path(s) of the connection source and target.
   *
   * @param {djs.core.ElementRegistry} elementRegistry
   */
  function CroppingConnectionDocking(elementRegistry, graphicsFactory) {
    this._elementRegistry = elementRegistry;
    this._graphicsFactory = graphicsFactory;
  }

  CroppingConnectionDocking.$inject = ['elementRegistry', 'graphicsFactory'];

  /**
   * @inheritDoc ConnectionDocking#getCroppedWaypoints
   */
  CroppingConnectionDocking.prototype.getCroppedWaypoints = function (connection, source, target) {

    source = source || connection.source;
    target = target || connection.target;

    var sourceDocking = this.getDockingPoint(connection, source, true),
        targetDocking = this.getDockingPoint(connection, target);

    var croppedWaypoints = connection.waypoints.slice(sourceDocking.idx + 1, targetDocking.idx);

    croppedWaypoints.unshift(dockingToPoint(sourceDocking));
    croppedWaypoints.push(dockingToPoint(targetDocking));

    return croppedWaypoints;
  };

  /**
   * Return the connection docking point on the specified shape
   *
   * @inheritDoc ConnectionDocking#getDockingPoint
   */
  CroppingConnectionDocking.prototype.getDockingPoint = function (connection, shape, dockStart) {

    var waypoints = connection.waypoints,
        dockingIdx,
        dockingPoint,
        croppedPoint;

    dockingIdx = dockStart ? 0 : waypoints.length - 1;
    dockingPoint = waypoints[dockingIdx];

    croppedPoint = this._getIntersection(shape, connection, dockStart);

    return {
      point: dockingPoint,
      actual: croppedPoint || dockingPoint,
      idx: dockingIdx
    };
  };

  // helpers //////////////////////

  CroppingConnectionDocking.prototype._getIntersection = function (shape, connection, takeFirst) {

    var shapePath = this._getShapePath(shape),
        connectionPath = this._getConnectionPath(connection);

    return getElementLineIntersection(shapePath, connectionPath, takeFirst);
  };

  CroppingConnectionDocking.prototype._getConnectionPath = function (connection) {
    return this._graphicsFactory.getConnectionPath(connection);
  };

  CroppingConnectionDocking.prototype._getShapePath = function (shape) {
    return this._graphicsFactory.getShapePath(shape);
  };

  CroppingConnectionDocking.prototype._getGfx = function (element) {
    return this._elementRegistry.getGraphics(element);
  };

  var ModelingModule = {
    __init__: ['modeling', 'drdUpdater'],
    __depends__: [ModelingBehavior, Rules$2, DefinitionPropertiesViewer, CommandStack$1, DiagramSelection, DiagramChangeSupport],
    drdFactory: ['type', DrdFactory],
    drdUpdater: ['type', DrdUpdater],
    elementFactory: ['type', ElementFactory$1],
    modeling: ['type', Modeling$1],
    layouter: ['type', DrdLayouter],
    connectionDocking: ['type', CroppingConnectionDocking]
  };

  var TOGGLE_SELECTOR = '.djs-palette-toggle',
      ENTRY_SELECTOR = '.entry',
      ELEMENT_SELECTOR = TOGGLE_SELECTOR + ', ' + ENTRY_SELECTOR;

  var PALETTE_OPEN_CLS = 'open',
      PALETTE_TWO_COLUMN_CLS = 'two-column';

  /**
   * A palette containing modeling elements.
   */
  function Palette(eventBus, canvas) {

    this._eventBus = eventBus;
    this._canvas = canvas;

    this._providers = [];

    var self = this;

    eventBus.on('tool-manager.update', function (event$$1) {
      var tool = event$$1.tool;

      self.updateToolHighlight(tool);
    });

    eventBus.on('i18n.changed', function () {
      self._update();
    });

    eventBus.on('diagram.init', function () {

      self._diagramInitialized = true;

      // initialize + update once diagram is ready
      if (self._providers.length) {
        self._init();

        self._update();
      }
    });
  }

  Palette.$inject = ['eventBus', 'canvas'];

  /**
   * Register a provider with the palette
   *
   * @param  {PaletteProvider} provider
   */
  Palette.prototype.registerProvider = function (provider) {
    this._providers.push(provider);

    // postpone init / update until diagram is initialized
    if (!this._diagramInitialized) {
      return;
    }

    if (!this._container) {
      this._init();
    }

    this._update();
  };

  /**
   * Returns the palette entries for a given element
   *
   * @return {Array<PaletteEntryDescriptor>} list of entries
   */
  Palette.prototype.getEntries = function () {

    var entries = {};

    // loop through all providers and their entries.
    // group entries by id so that overriding an entry is possible
    forEach(this._providers, function (provider) {
      var e = provider.getPaletteEntries();

      forEach(e, function (entry, id) {
        entries[id] = entry;
      });
    });

    return entries;
  };

  /**
   * Initialize
   */
  Palette.prototype._init = function () {
    var canvas = this._canvas,
        eventBus = this._eventBus;

    var parent = canvas.getContainer(),
        container = this._container = domify(Palette.HTML_MARKUP),
        self = this;

    parent.appendChild(container);

    delegateEvents.bind(container, ELEMENT_SELECTOR, 'click', function (event$$1) {

      var target = event$$1.delegateTarget;

      if (matchesSelector$1(target, TOGGLE_SELECTOR)) {
        return self.toggle();
      }

      self.trigger('click', event$$1);
    });

    // prevent drag propagation
    componentEvent.bind(container, 'mousedown', function (event$$1) {
      event$$1.stopPropagation();
    });

    // prevent drag propagation
    delegateEvents.bind(container, ENTRY_SELECTOR, 'dragstart', function (event$$1) {
      self.trigger('dragstart', event$$1);
    });

    eventBus.on('canvas.resized', this._layoutChanged, this);

    eventBus.fire('palette.create', {
      container: container
    });
  };

  /**
   * Update palette state.
   *
   * @param  {Object} [state] { open, twoColumn }
   */
  Palette.prototype._toggleState = function (state) {

    state = state || {};

    var parent = this._getParentContainer(),
        container = this._container;

    var eventBus = this._eventBus;

    var twoColumn;

    var cls = classes(container);

    if ('twoColumn' in state) {
      twoColumn = state.twoColumn;
    } else {
      twoColumn = this._needsCollapse(parent.clientHeight, this._entries || {});
    }

    // always update two column
    cls.toggle(PALETTE_TWO_COLUMN_CLS, twoColumn);

    if ('open' in state) {
      cls.toggle(PALETTE_OPEN_CLS, state.open);
    }

    eventBus.fire('palette.changed', {
      twoColumn: twoColumn,
      open: this.isOpen()
    });
  };

  Palette.prototype._update = function () {

    var entriesContainer = query('.djs-palette-entries', this._container),
        entries = this._entries = this.getEntries();

    clear(entriesContainer);

    forEach(entries, function (entry, id) {

      var grouping = entry.group || 'default';

      var container = query('[data-group=' + grouping + ']', entriesContainer);
      if (!container) {
        container = domify('<div class="group" data-group="' + grouping + '"></div>');
        entriesContainer.appendChild(container);
      }

      var html = entry.html || (entry.separator ? '<hr class="separator" />' : '<div class="entry" draggable="true"></div>');

      var control = domify(html);
      container.appendChild(control);

      if (!entry.separator) {
        attr(control, 'data-action', id);

        if (entry.title) {
          attr(control, 'title', entry.title);
        }

        if (entry.className) {
          addClasses$1(control, entry.className);
        }

        if (entry.imageUrl) {
          control.appendChild(domify('<img src="' + entry.imageUrl + '">'));
        }
      }
    });

    // open after update
    this.open();
  };

  /**
   * Trigger an action available on the palette
   *
   * @param  {String} action
   * @param  {Event} event
   */
  Palette.prototype.trigger = function (action, event$$1, autoActivate) {
    var entries = this._entries,
        entry,
        handler,
        originalEvent,
        button = event$$1.delegateTarget || event$$1.target;

    if (!button) {
      return event$$1.preventDefault();
    }

    entry = entries[attr(button, 'data-action')];

    // when user clicks on the palette and not on an action
    if (!entry) {
      return;
    }

    handler = entry.action;

    originalEvent = event$$1.originalEvent || event$$1;

    // simple action (via callback function)
    if (isFunction(handler)) {
      if (action === 'click') {
        handler(originalEvent, autoActivate);
      }
    } else {
      if (handler[action]) {
        handler[action](originalEvent, autoActivate);
      }
    }

    // silence other actions
    event$$1.preventDefault();
  };

  Palette.prototype._layoutChanged = function () {
    this._toggleState({});
  };

  /**
   * Do we need to collapse to two columns?
   *
   * @param {Number} availableHeight
   * @param {Object} entries
   *
   * @return {Boolean}
   */
  Palette.prototype._needsCollapse = function (availableHeight, entries) {

    // top margin + bottom toggle + bottom margin
    // implementors must override this method if they
    // change the palette styles
    var margin = 20 + 10 + 20;

    var entriesHeight = Object.keys(entries).length * 46;

    return availableHeight < entriesHeight + margin;
  };

  /**
   * Close the palette
   */
  Palette.prototype.close = function () {

    this._toggleState({
      open: false,
      twoColumn: false
    });
  };

  /**
   * Open the palette
   */
  Palette.prototype.open = function () {
    this._toggleState({ open: true });
  };

  Palette.prototype.toggle = function (open) {
    if (this.isOpen()) {
      this.close();
    } else {
      this.open();
    }
  };

  Palette.prototype.isActiveTool = function (tool) {
    return tool && this._activeTool === tool;
  };

  Palette.prototype.updateToolHighlight = function (name) {
    var entriesContainer, toolsContainer;

    if (!this._toolsContainer) {
      entriesContainer = query('.djs-palette-entries', this._container);

      this._toolsContainer = query('[data-group=tools]', entriesContainer);
    }

    toolsContainer = this._toolsContainer;

    forEach(toolsContainer.children, function (tool) {
      var actionName = tool.getAttribute('data-action');

      if (!actionName) {
        return;
      }

      var toolClasses = classes(tool);

      actionName = actionName.replace('-tool', '');

      if (toolClasses.contains('entry') && actionName === name) {
        toolClasses.add('highlighted-entry');
      } else {
        toolClasses.remove('highlighted-entry');
      }
    });
  };

  /**
   * Return true if the palette is opened.
   *
   * @example
   *
   * palette.open();
   *
   * if (palette.isOpen()) {
   *   // yes, we are open
   * }
   *
   * @return {boolean} true if palette is opened
   */
  Palette.prototype.isOpen = function () {
    return classes(this._container).has(PALETTE_OPEN_CLS);
  };

  /**
   * Get container the palette lives in.
   *
   * @return {Element}
   */
  Palette.prototype._getParentContainer = function () {
    return this._canvas.getContainer();
  };

  /* markup definition */

  Palette.HTML_MARKUP = '<div class="djs-palette">' + '<div class="djs-palette-entries"></div>' + '<div class="djs-palette-toggle"></div>' + '</div>';

  // helpers //////////////////////

  function addClasses$1(element, classNames) {

    var classes$$1 = classes(element);

    var actualClassNames = isArray(classNames) ? classNames : classNames.split(/\s+/g);
    actualClassNames.forEach(function (cls) {
      classes$$1.add(cls);
    });
  }

  var DiagramPalette = {
    __init__: ['palette'],
    palette: ['type', Palette]
  };

  /**
   * A palette provider for DMN 1.1 elements.
   */
  function PaletteProvider(palette, create, elementFactory, lassoTool, translate) {

    this._palette = palette;
    this._create = create;
    this._elementFactory = elementFactory;
    this._lassoTool = lassoTool;
    this._translate = translate;

    palette.registerProvider(this);
  }

  PaletteProvider.$inject = ['palette', 'create', 'elementFactory', 'lassoTool', 'translate'];

  PaletteProvider.prototype.getPaletteEntries = function (element) {

    var actions = {},
        create = this._create,
        elementFactory = this._elementFactory,
        lassoTool = this._lassoTool,
        translate = this._translate;

    function createAction(type, group, className, title, options) {

      function createListener(event) {
        var shape = elementFactory.createShape(assign({ type: type }, options));

        create.start(event, shape);
      }

      return {
        group: group,
        className: className,
        title: title,
        action: {
          dragstart: createListener,
          click: createListener
        }
      };
    }

    assign(actions, {
      'lasso-tool': {
        group: 'tools',
        className: 'dmn-icon-lasso-tool',
        title: translate('Activate the lasso tool'),
        action: {
          click: function click(event) {
            lassoTool.activateSelection(event);
          }
        }
      },
      'tool-separator': {
        group: 'tools',
        separator: true
      },
      'create.decision': createAction('dmn:Decision', 'drd', 'dmn-icon-decision'),
      'create.input-data': createAction('dmn:InputData', 'drd', 'dmn-icon-input-data'),
      'create.knowledge-source': createAction('dmn:KnowledgeSource', 'drd', 'dmn-icon-knowledge-source'),
      'create.business-knowledge-model': createAction('dmn:BusinessKnowledgeModel', 'drd', 'dmn-icon-business-knowledge')
    });

    return actions;
  };

  var PaletteModule = {
    __depends__: [DiagramTranslate, DiagramPalette, DiagramCreate, DiagramLasso],
    __init__: ['paletteProvider'],
    paletteProvider: ['type', PaletteProvider]
  };

  var DEBOUNCE_DELAY = 300;

  function DefinitionIdEdit(eventBus, modeling, canvas) {
    this._eventBus = eventBus;
    this._modeling = modeling;
    this._canvas = canvas;

    eventBus.on('definitionIdView.create', function (event) {
      var container = event.html,
          nameElement = query('.dmn-definitions-name', container),
          idElement = query('.dmn-definitions-id', container);

      this._setup(nameElement, 'name');
      this._setup(idElement, 'id');
    }, this);
  }

  DefinitionIdEdit.$inject = ['eventBus', 'modeling', 'canvas'];

  DefinitionIdEdit.prototype.update = function (type, newValue) {
    var newProperties = {};
    newProperties[type] = newValue;

    this._modeling.updateProperties(this._canvas.getRootElement(), newProperties);
  };

  DefinitionIdEdit.prototype._setup = function (node, type) {
    var self = this;

    node.setAttribute('contenteditable', true);

    node.addEventListener('input', debounce(function (evt) {
      var value = evt.target.value || evt.target.textContent;

      self.update(type, value.trim());
    }, DEBOUNCE_DELAY));

    node.addEventListener('keydown', function (evt) {
      if (evt.keyCode === 13) {
        node.blur();
        window.getSelection().removeAllRanges();
      }
    });
  };

  var DefinitionPropertiesModule = {
    __init__: ['definitionPropertiesEdit', 'definitionPropertiesPaletteAdapter'],
    definitionPropertiesEdit: ['type', DefinitionIdEdit],
    definitionPropertiesPaletteAdapter: ['type', PaletteAdapter]
  };

  /**
   * A modeler for DMN tables.
   *
   *
   * ## Extending the Modeler
   *
   * In order to extend the viewer pass extension modules to bootstrap via the
   * `additionalModules` option. An extension module is an object that exposes
   * named services.
   *
   * The following example depicts the integration of a simple
   * logging component that integrates with interaction events:
   *
   *
   * ```javascript
   *
   * // logging component
   * function InteractionLogger(eventBus) {
   *   eventBus.on('element.hover', function(event) {
   *     console.log()
   *   })
   * }
   *
   * InteractionLogger.$inject = [ 'eventBus' ]; // minification save
   *
   * // extension module
   * var extensionModule = {
   *   __init__: [ 'interactionLogger' ],
   *   interactionLogger: [ 'type', InteractionLogger ]
   * };
   *
   * // extend the viewer
   * var dmnModeler = new Modeler({ additionalModules: [ extensionModule ] });
   * dmnModeler.importXML(...);
   * ```
   *
   *
   * ## Customizing / Replacing Components
   *
   * You can replace individual table components by redefining them in override modules.
   * This works for all components, including those defined in the core.
   *
   * Pass in override modules via the `options.additionalModules` flag like this:
   *
   * ```javascript
   * function CustomContextPadProvider(contextPad) {
   *
   *   contextPad.registerProvider(this);
   *
   *   this.getContextPadEntries = function(element) {
   *     // no entries, effectively disable the context pad
   *     return {};
   *   };
   * }
   *
   * CustomContextPadProvider.$inject = [ 'contextPad' ];
   *
   * var overrideModule = {
   *   contextPadProvider: [ 'type', CustomContextPadProvider ]
   * };
   *
   * var dmnModeler = new Modeler({ additionalModules: [ overrideModule ]});
   * ```
   *
   * @param {Object} [options] configuration options to pass to the viewer
   * @param {DOMElement} [options.container]
   *        the container to render the viewer in, defaults to body.
   * @param {String|Number} [options.width] the width of the viewer
   * @param {String|Number} [options.height] the height of the viewer
   * @param {Object} [options.moddleExtensions]
   *        extension packages to provide
   * @param {Array<didi.Module>} [options.modules]
   *        a list of modules to override the default modules
   * @param {Array<didi.Module>} [options.additionalModules]
   *        a list of modules to use with the default modules
   */
  function Modeler(options) {
    NavigatedViewer.call(this, options);
  }

  inherits_browser(Modeler, NavigatedViewer);

  Modeler.prototype._modelingModules = [
  // modeling components
  MoveModule, BendpointsModule, GenerateDiModule, EditorActionsModule, ContextPadModule, KeyboardModule, LabelEditingModule, ModelingModule, PaletteModule, DefinitionPropertiesModule];

  Modeler.prototype._modules = [].concat(Modeler.prototype._modules, Modeler.prototype._modelingModules);

  var _typeof$9 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  function _possibleConstructorReturn$1(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$9(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$9(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _classCallCheck$3(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Base$2 = function Base(attrs) {
    _classCallCheck$3(this, Base);

    assign(this, attrs);

    /**
     * The object that backs up the shape
     *
     * @name Base#businessObject
     * @type Object
     */
    defineProperty$2(this, 'businessObject', {
      writable: true
    });
  };

  var Root$1 = function (_Base) {
    _inherits$1(Root, _Base);

    function Root(attrs) {
      _classCallCheck$3(this, Root);

      /**
       * The tables rows
       *
       * @name Root#rows
       * @type Row
       */
      var _this = _possibleConstructorReturn$1(this, (Root.__proto__ || Object.getPrototypeOf(Root)).call(this, attrs));

      defineProperty$2(_this, 'rows', {
        enumerable: true,
        value: _this.rows || []
      });

      /**
       * The tables columns
       *
       * @name Root#cols
       * @type Col
       */
      defineProperty$2(_this, 'cols', {
        enumerable: true,
        value: _this.cols || []
      });
      return _this;
    }

    return Root;
  }(Base$2);

  var Row = function (_Base2) {
    _inherits$1(Row, _Base2);

    function Row(attrs) {
      _classCallCheck$3(this, Row);

      /**
       * Reference to the table
       *
       * @name Row#root
       * @type Root
       */
      var _this2 = _possibleConstructorReturn$1(this, (Row.__proto__ || Object.getPrototypeOf(Row)).call(this, attrs));

      defineProperty$2(_this2, 'root', {
        writable: true
      });

      /**
       * Reference to contained cells
       *
       * @name Row#cells
       * @type Cell
       */
      defineProperty$2(_this2, 'cells', {
        enumerable: true,
        value: _this2.cells || []
      });
      return _this2;
    }

    return Row;
  }(Base$2);

  var Col = function (_Base3) {
    _inherits$1(Col, _Base3);

    function Col(attrs) {
      _classCallCheck$3(this, Col);

      /**
       * Reference to the table
       *
       * @name Col#table
       * @type Root
       */
      var _this3 = _possibleConstructorReturn$1(this, (Col.__proto__ || Object.getPrototypeOf(Col)).call(this, attrs));

      defineProperty$2(_this3, 'root', {
        writable: true
      });

      /**
       * Reference to contained cells
       *
       * @name Row#cells
       * @type Cell
       */
      defineProperty$2(_this3, 'cells', {
        enumerable: true,
        value: _this3.cells || []
      });
      return _this3;
    }

    return Col;
  }(Base$2);

  var Cell = function (_Base4) {
    _inherits$1(Cell, _Base4);

    function Cell(attrs) {
      _classCallCheck$3(this, Cell);

      /**
       * Reference to the row
       *
       * @name Cell#row
       * @type Row
       */
      var _this4 = _possibleConstructorReturn$1(this, (Cell.__proto__ || Object.getPrototypeOf(Cell)).call(this, attrs));

      defineProperty$2(_this4, 'row', {
        writable: true
      });

      /**
       * Reference to the col
       *
       * @name Cell#col
       * @type Col
       */
      defineProperty$2(_this4, 'col', {
        writable: true
      });
      return _this4;
    }

    return Cell;
  }(Base$2);

  var TYPES = {
    root: Root$1,
    row: Row,
    col: Col,
    cell: Cell
  };

  function create$2(type, attrs) {
    var Type = TYPES[type];

    if (!Type) {
      throw new Error('unknown type ' + type);
    }

    return new Type(attrs);
  }

  // helpers /////////////

  function defineProperty$2(el, prop, options) {
    Object.defineProperty(el, prop, options);
  }

  var _createClass$3 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$4(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var ElementFactory$2 = function () {
    function ElementFactory() {
      _classCallCheck$4(this, ElementFactory);

      this._uid = 12;
    }

    _createClass$3(ElementFactory, [{
      key: 'create',
      value: function create$$1(type) {
        var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (!attrs.id) {
          attrs.id = type + '_' + this._uid++;
        }

        return create$2(type, attrs);
      }
    }, {
      key: 'createRoot',
      value: function createRoot(attrs) {
        return this.create('root', attrs);
      }
    }, {
      key: 'createRow',
      value: function createRow(attrs) {
        return this.create('row', attrs);
      }
    }, {
      key: 'createCol',
      value: function createCol(attrs) {
        return this.create('col', attrs);
      }
    }, {
      key: 'createCell',
      value: function createCell(attrs) {
        return this.create('cell', attrs);
      }
    }]);

    return ElementFactory;
  }();

  var _createClass$4 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$5(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var ElementRegistry$1 = function () {
    function ElementRegistry(eventBus) {
      _classCallCheck$5(this, ElementRegistry);

      this._eventBus = eventBus;

      this._elements = {};

      eventBus.on('table.clear', this.clear.bind(this));
    }

    _createClass$4(ElementRegistry, [{
      key: 'add',
      value: function add(element, type) {
        var id = element.id;

        this._elements[id] = element;
      }
    }, {
      key: 'remove',
      value: function remove(element) {
        var id = element.id || element;

        delete this._elements[id];
      }
    }, {
      key: 'get',
      value: function get(id) {
        return this._elements[id];
      }
    }, {
      key: 'getAll',
      value: function getAll() {
        return values$1(this._elements);
      }
    }, {
      key: 'forEach',
      value: function forEach(fn) {
        values$1(this._elements).forEach(function (element) {
          return fn(element);
        });
      }
    }, {
      key: 'filter',
      value: function filter(fn) {
        return values$1(this._elements).filter(function (element) {
          return fn(element);
        });
      }
    }, {
      key: 'clear',
      value: function clear() {
        this._elements = {};
      }
    }, {
      key: 'updateId',
      value: function updateId(element, newId) {

        this._validateId(newId);

        if (typeof element === 'string') {
          element = this.get(element);
        }

        this._eventBus.fire('element.updateId', {
          element: element,
          newId: newId
        });

        this.remove(element);

        element.id = newId;

        this.add(element);
      }

      /**
      * Validate the suitability of the given id and signals a problem
      * with an exception.
      *
      * @param {String} id
      *
      * @throws {Error} if id is empty or already assigned
      */

    }, {
      key: '_validateId',
      value: function _validateId(id) {
        if (!id) {
          throw new Error('element must have an id');
        }

        if (this._elements[id]) {
          throw new Error('element with id ' + id + ' already added');
        }
      }
    }]);

    return ElementRegistry;
  }();

  ElementRegistry$1.$inject = ['eventBus'];

  // helpers

  function values$1(obj) {
    return Object.keys(obj).map(function (k) {
      return obj[k];
    });
  }

  var _createClass$5 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$6(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var ChangeSupport$1 = function () {
    function ChangeSupport(eventBus) {
      var _this = this;

      _classCallCheck$6(this, ChangeSupport);

      this._listeners = {};

      eventBus.on('elements.changed', function (_ref) {
        var elements = _ref.elements;

        _this.elementsChanged(elements);
      });

      eventBus.on('root.remove', function (context) {
        var oldRootId = context.root.id;

        if (_this._listeners[oldRootId]) {

          eventBus.once('root.add', function (context) {
            var newRootId = context.root.id;

            _this.updateId(oldRootId, newRootId);
          });
        }
      });

      eventBus.on('element.updateId', function (_ref2) {
        var element = _ref2.element,
            newId = _ref2.newId;

        _this.updateId(element.id, newId);
      });
    }

    _createClass$5(ChangeSupport, [{
      key: 'elementsChanged',
      value: function elementsChanged(elements) {
        var invoked = {};

        var elementsLength = elements.length;

        for (var i = 0; i < elementsLength; i++) {
          var id = elements[i].id;

          if (invoked[id]) {
            return;
          }

          invoked[id] = true;

          var listenersLength = this._listeners[id] && this._listeners[id].length;

          if (listenersLength) {
            for (var j = 0; j < listenersLength; j++) {

              // listeners might remove themselves before they get called
              this._listeners[id][j] && this._listeners[id][j]();
            }
          }
        }
      }
    }, {
      key: 'onElementsChanged',
      value: function onElementsChanged(id, listener) {
        if (!this._listeners[id]) {
          this._listeners[id] = [];
        }

        // avoid push for better performance
        this._listeners[id][this._listeners[id].length] = listener;
      }
    }, {
      key: 'offElementsChanged',
      value: function offElementsChanged(id, listener) {
        if (!this._listeners[id]) {
          return;
        }

        if (listener) {
          var idx = this._listeners[id].indexOf(listener);

          if (idx !== -1) {
            this._listeners[id].splice(idx, 1);
          }
        } else {
          this._listeners[id].length = 0;
        }
      }
    }, {
      key: 'updateId',
      value: function updateId(oldId, newId) {
        if (this._listeners[oldId]) {

          this._listeners[newId] = this._listeners[oldId];

          delete this._listeners[oldId];
        }
      }
    }]);

    return ChangeSupport;
  }();

  ChangeSupport$1.$inject = ['eventBus'];

  var _createClass$6 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$7(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var DEFAULT_PRIORITY$2 = 1000;

  var Components = function () {
    function Components() {
      _classCallCheck$7(this, Components);

      this._listeners = {};
    }

    _createClass$6(Components, [{
      key: 'getComponent',
      value: function getComponent(type, context) {
        var listeners = this._listeners[type];

        if (!listeners) {
          return;
        }

        var component = void 0;

        for (var i = 0; i < listeners.length; i++) {
          component = listeners[i].callback(context);

          if (component) {
            break;
          }
        }

        return component;
      }
    }, {
      key: 'getComponents',
      value: function getComponents(type, context) {
        var listeners = this._listeners[type];

        var components = [];

        if (!listeners) {
          return components;
        }

        for (var i = 0; i < listeners.length; i++) {
          var component = listeners[i].callback(context);

          if (component) {
            components.push(component);
          }
        }

        if (!components.length) {
          return components;
        }

        return components;
      }
    }, {
      key: 'onGetComponent',
      value: function onGetComponent(type, priority, callback) {
        if (isFunction(priority)) {
          callback = priority;
          priority = DEFAULT_PRIORITY$2;
        }

        if (!isNumber(priority)) {
          throw new Error('priority must be a number');
        }

        var listeners = this._getListeners(type);

        var existingListener = void 0,
            idx = void 0;

        var newListener = { priority: priority, callback: callback };

        for (idx = 0; existingListener = listeners[idx]; idx++) {
          if (existingListener.priority < priority) {

            // prepend newListener at before existingListener
            listeners.splice(idx, 0, newListener);
            return;
          }
        }

        listeners.push(newListener);
      }
    }, {
      key: 'offGetComponent',
      value: function offGetComponent(type, callback) {
        var listeners = this._getListeners(type);

        var listener = void 0,
            listenerCallback = void 0,
            idx = void 0;

        if (callback) {

          // move through listeners from back to front
          // and remove matching listeners
          for (idx = listeners.length - 1; listener = listeners[idx]; idx--) {
            listenerCallback = listener.callback;

            if (listenerCallback === callback) {
              listeners.splice(idx, 1);
            }
          }
        } else {
          // clear listeners
          listeners.length = 0;
        }
      }
    }, {
      key: '_getListeners',
      value: function _getListeners(type) {
        var listeners = this._listeners[type];

        if (!listeners) {
          this._listeners[type] = listeners = [];
        }

        return listeners;
      }
    }]);

    return Components;
  }();

  var _typeof$10 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var NO_OP = '$NO_OP';
  var ERROR_MSG = 'a runtime error occured! Use Inferno in development environment to find the error.';
  // This should be boolean and not reference to window.document
  var isBrowser = !!(typeof window !== 'undefined' && window.document);
  // this is MUCH faster than .constructor === Array and instanceof Array
  // in Node 7 and the later versions of V8, slower in older versions though
  var isArray$2 = Array.isArray;
  function isStringOrNumber(o) {
      var type = typeof o === 'undefined' ? 'undefined' : _typeof$10(o);
      return type === 'string' || type === 'number';
  }
  function isNullOrUndef(o) {
      return isUndefined$2(o) || isNull(o);
  }
  function isInvalid(o) {
      return isNull(o) || o === false || isTrue(o) || isUndefined$2(o);
  }
  function isFunction$1(o) {
      return typeof o === 'function';
  }
  function isString$1(o) {
      return typeof o === 'string';
  }
  function isNumber$1(o) {
      return typeof o === 'number';
  }
  function isNull(o) {
      return o === null;
  }
  function isTrue(o) {
      return o === true;
  }
  function isUndefined$2(o) {
      return o === void 0;
  }
  function isObject$1(o) {
      return (typeof o === 'undefined' ? 'undefined' : _typeof$10(o)) === 'object';
  }
  function throwError(message) {
      if (!message) {
          message = ERROR_MSG;
      }
      throw new Error("Inferno Error: " + message);
  }
  function combineFrom(first, second) {
      var out = {};
      if (first) {
          for (var key in first) {
              out[key] = first[key];
          }
      }
      if (second) {
          for (var key$1 in second) {
              out[key$1] = second[key$1];
          }
      }
      return out;
  }

  var keyPrefix = '$';
  function getVNode(childFlags, children, className, flags, key, props, ref, type) {
      return {
          childFlags: childFlags,
          children: children,
          className: className,
          dom: null,
          flags: flags,
          key: key === void 0 ? null : key,
          parentVNode: null,
          props: props === void 0 ? null : props,
          ref: ref === void 0 ? null : ref,
          type: type
      };
  }
  function createVNode(flags, type, className, children, childFlags, props, key, ref) {
      var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;
      var vNode = getVNode(childFlag, children, className, flags, key, props, ref, type);
      if (childFlag === 0 /* UnknownChildren */) {
              normalizeChildren(vNode, vNode.children);
          }
      return vNode;
  }
  function createComponentVNode(flags, type, props, key, ref) {
      if ((flags & 2 /* ComponentUnknown */) > 0) {
          flags = type.prototype && isFunction$1(type.prototype.render) ? 4 /* ComponentClass */ : 8 /* ComponentFunction */;
      }
      // set default props
      var defaultProps = type.defaultProps;
      if (!isNullOrUndef(defaultProps)) {
          if (!props) {
              props = {}; // Props can be referenced and modified at application level so always create new object
          }
          for (var prop in defaultProps) {
              if (isUndefined$2(props[prop])) {
                  props[prop] = defaultProps[prop];
              }
          }
      }
      if ((flags & 8 /* ComponentFunction */) > 0) {
          var defaultHooks = type.defaultHooks;
          if (!isNullOrUndef(defaultHooks)) {
              if (!ref) {
                  // As ref cannot be referenced from application level, we can use the same refs object
                  ref = defaultHooks;
              } else {
                  for (var prop$1 in defaultHooks) {
                      if (isUndefined$2(ref[prop$1])) {
                          ref[prop$1] = defaultHooks[prop$1];
                      }
                  }
              }
          }
      }
      var vNode = getVNode(1 /* HasInvalidChildren */, null, null, flags, key, props, ref, type);
      var optsVNode = options.createVNode;
      if (isFunction$1(optsVNode)) {
          optsVNode(vNode);
      }
      return vNode;
  }
  function createTextVNode(text, key) {
      return getVNode(1 /* HasInvalidChildren */, isNullOrUndef(text) ? '' : text, null, 16 /* Text */, key, null, null, null);
  }
  function normalizeProps(vNode) {
      var props = vNode.props;
      if (props) {
          var flags = vNode.flags;
          if (flags & 481 /* Element */) {
                  if (props.children !== void 0 && isNullOrUndef(vNode.children)) {
                      normalizeChildren(vNode, props.children);
                  }
                  if (props.className !== void 0) {
                      vNode.className = props.className || null;
                      props.className = undefined;
                  }
              }
          if (props.key !== void 0) {
              vNode.key = props.key;
              props.key = undefined;
          }
          if (props.ref !== void 0) {
              if (flags & 8 /* ComponentFunction */) {
                      vNode.ref = combineFrom(vNode.ref, props.ref);
                  } else {
                  vNode.ref = props.ref;
              }
              props.ref = undefined;
          }
      }
      return vNode;
  }
  function directClone(vNodeToClone) {
      var newVNode;
      var flags = vNodeToClone.flags;
      if (flags & 14 /* Component */) {
              var props;
              var propsToClone = vNodeToClone.props;
              if (!isNull(propsToClone)) {
                  props = {};
                  for (var key in propsToClone) {
                      props[key] = propsToClone[key];
                  }
              }
              newVNode = createComponentVNode(flags, vNodeToClone.type, props, vNodeToClone.key, vNodeToClone.ref);
          } else if (flags & 481 /* Element */) {
              var children = vNodeToClone.children;
              newVNode = createVNode(flags, vNodeToClone.type, vNodeToClone.className, children, vNodeToClone.childFlags, vNodeToClone.props, vNodeToClone.key, vNodeToClone.ref);
          } else if (flags & 16 /* Text */) {
              newVNode = createTextVNode(vNodeToClone.children, vNodeToClone.key);
          } else if (flags & 1024 /* Portal */) {
              newVNode = vNodeToClone;
          }
      return newVNode;
  }
  function createVoidVNode() {
      return createTextVNode('', null);
  }
  function _normalizeVNodes(nodes, result, index, currentKey) {
      for (var len = nodes.length; index < len; index++) {
          var n = nodes[index];
          if (!isInvalid(n)) {
              var newKey = currentKey + keyPrefix + index;
              if (isArray$2(n)) {
                  _normalizeVNodes(n, result, 0, newKey);
              } else {
                  if (isStringOrNumber(n)) {
                      n = createTextVNode(n, newKey);
                  } else {
                      var oldKey = n.key;
                      var isPrefixedKey = isString$1(oldKey) && oldKey[0] === keyPrefix;
                      if (!isNull(n.dom) || isPrefixedKey) {
                          n = directClone(n);
                      }
                      if (isNull(oldKey) || isPrefixedKey) {
                          n.key = newKey;
                      } else {
                          n.key = currentKey + oldKey;
                      }
                  }
                  result.push(n);
              }
          }
      }
  }
  function normalizeChildren(vNode, children) {
      var newChildren;
      var newChildFlags = 1 /* HasInvalidChildren */;
      // Don't change children to match strict equal (===) true in patching
      if (isInvalid(children)) {
          newChildren = children;
      } else if (isString$1(children)) {
          newChildFlags = 2 /* HasVNodeChildren */;
          newChildren = createTextVNode(children);
      } else if (isNumber$1(children)) {
          newChildFlags = 2 /* HasVNodeChildren */;
          newChildren = createTextVNode(children + '');
      } else if (isArray$2(children)) {
          var len = children.length;
          if (len === 0) {
              newChildren = null;
              newChildFlags = 1 /* HasInvalidChildren */;
          } else {
              // we assign $ which basically means we've flagged this array for future note
              // if it comes back again, we need to clone it, as people are using it
              // in an immutable way
              // tslint:disable-next-line
              if (Object.isFrozen(children) || children['$'] === true) {
                  children = children.slice();
              }
              newChildFlags = 8 /* HasKeyedChildren */;
              for (var i = 0; i < len; i++) {
                  var n = children[i];
                  if (isInvalid(n) || isArray$2(n)) {
                      newChildren = newChildren || children.slice(0, i);
                      _normalizeVNodes(children, newChildren, i, '');
                      break;
                  } else if (isStringOrNumber(n)) {
                      newChildren = newChildren || children.slice(0, i);
                      newChildren.push(createTextVNode(n, keyPrefix + i));
                  } else {
                      var key = n.key;
                      var isNullDom = isNull(n.dom);
                      var isNullKey = isNull(key);
                      var isPrefixed = !isNullKey && key[0] === keyPrefix;
                      if (!isNullDom || isNullKey || isPrefixed) {
                          newChildren = newChildren || children.slice(0, i);
                          if (!isNullDom || isPrefixed) {
                              n = directClone(n);
                          }
                          if (isNullKey || isPrefixed) {
                              n.key = keyPrefix + i;
                          }
                          newChildren.push(n);
                      } else if (newChildren) {
                          newChildren.push(n);
                      }
                  }
              }
              newChildren = newChildren || children;
              newChildren.$ = true;
          }
      } else {
          newChildren = children;
          if (!isNull(children.dom)) {
              newChildren = directClone(children);
          }
          newChildFlags = 2 /* HasVNodeChildren */;
      }
      vNode.children = newChildren;
      vNode.childFlags = newChildFlags;
      return vNode;
  }
  var options = {
      afterMount: null,
      afterRender: null,
      afterUpdate: null,
      beforeRender: null,
      beforeUnmount: null,
      createVNode: null,
      roots: []
  };

  var xlinkNS = 'http://www.w3.org/1999/xlink';
  var xmlNS = 'http://www.w3.org/XML/1998/namespace';
  var svgNS = 'http://www.w3.org/2000/svg';
  var namespaces = {
      'xlink:actuate': xlinkNS,
      'xlink:arcrole': xlinkNS,
      'xlink:href': xlinkNS,
      'xlink:role': xlinkNS,
      'xlink:show': xlinkNS,
      'xlink:title': xlinkNS,
      'xlink:type': xlinkNS,
      'xml:base': xmlNS,
      'xml:lang': xmlNS,
      'xml:space': xmlNS
  };

  // We need EMPTY_OBJ defined in one place.
  // Its used for comparison so we cant inline it into shared
  var EMPTY_OBJ = {};
  var LIFECYCLE = [];
  function appendChild(parentDom, dom) {
      parentDom.appendChild(dom);
  }
  function insertOrAppend(parentDom, newNode, nextNode) {
      if (isNullOrUndef(nextNode)) {
          appendChild(parentDom, newNode);
      } else {
          parentDom.insertBefore(newNode, nextNode);
      }
  }
  function documentCreateElement(tag, isSVG) {
      if (isSVG === true) {
          return document.createElementNS(svgNS, tag);
      }
      return document.createElement(tag);
  }
  function replaceChild(parentDom, newDom, lastDom) {
      parentDom.replaceChild(newDom, lastDom);
  }
  function removeChild(parentDom, dom) {
      parentDom.removeChild(dom);
  }
  function callAll(arrayFn) {
      var listener;
      while ((listener = arrayFn.shift()) !== undefined) {
          listener();
      }
  }

  var attachedEventCounts = {};
  var attachedEvents = {};
  function handleEvent(name, nextEvent, dom) {
      var eventsLeft = attachedEventCounts[name];
      var eventsObject = dom.$EV;
      if (nextEvent) {
          if (!eventsLeft) {
              attachedEvents[name] = attachEventToDocument(name);
              attachedEventCounts[name] = 0;
          }
          if (!eventsObject) {
              eventsObject = dom.$EV = {};
          }
          if (!eventsObject[name]) {
              attachedEventCounts[name]++;
          }
          eventsObject[name] = nextEvent;
      } else if (eventsObject && eventsObject[name]) {
          attachedEventCounts[name]--;
          if (eventsLeft === 1) {
              document.removeEventListener(normalizeEventName(name), attachedEvents[name]);
              attachedEvents[name] = null;
          }
          eventsObject[name] = nextEvent;
      }
  }
  function dispatchEvents(event, target, isClick, name, eventData) {
      var dom = target;
      while (!isNull(dom)) {
          // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,
          // because the event listener is on document.body
          // Don't process clicks on disabled elements
          if (isClick && dom.disabled) {
              return;
          }
          var eventsObject = dom.$EV;
          if (eventsObject) {
              var currentEvent = eventsObject[name];
              if (currentEvent) {
                  // linkEvent object
                  eventData.dom = dom;
                  if (currentEvent.event) {
                      currentEvent.event(currentEvent.data, event);
                  } else {
                      currentEvent(event);
                  }
                  if (event.cancelBubble) {
                      return;
                  }
              }
          }
          dom = dom.parentNode;
      }
  }
  function normalizeEventName(name) {
      return name.substr(2).toLowerCase();
  }
  function stopPropagation$2() {
      this.cancelBubble = true;
      if (!this.immediatePropagationStopped) {
          this.stopImmediatePropagation();
      }
  }
  function attachEventToDocument(name) {
      var docEvent = function docEvent(event) {
          var type = event.type;
          var isClick = type === 'click' || type === 'dblclick';
          if (isClick && event.button !== 0) {
              // Firefox incorrectly triggers click event for mid/right mouse buttons.
              // This bug has been active for 12 years.
              // https://bugzilla.mozilla.org/show_bug.cgi?id=184051
              event.preventDefault();
              event.stopPropagation();
              return false;
          }
          event.stopPropagation = stopPropagation$2;
          // Event data needs to be object to save reference to currentTarget getter
          var eventData = {
              dom: document
          };
          Object.defineProperty(event, 'currentTarget', {
              configurable: true,
              get: function get() {
                  return eventData.dom;
              }
          });
          dispatchEvents(event, event.target, isClick, name, eventData);
          return;
      };
      document.addEventListener(normalizeEventName(name), docEvent);
      return docEvent;
  }

  function isSameInnerHTML(dom, innerHTML) {
      var tempdom = document.createElement('i');
      tempdom.innerHTML = innerHTML;
      return tempdom.innerHTML === dom.innerHTML;
  }
  function isSamePropsInnerHTML(dom, props) {
      return Boolean(props && props.dangerouslySetInnerHTML && props.dangerouslySetInnerHTML.__html && isSameInnerHTML(dom, props.dangerouslySetInnerHTML.__html));
  }

  function triggerEventListener(props, methodName, e) {
      if (props[methodName]) {
          var listener = props[methodName];
          if (listener.event) {
              listener.event(listener.data, e);
          } else {
              listener(e);
          }
      } else {
          var nativeListenerName = methodName.toLowerCase();
          if (props[nativeListenerName]) {
              props[nativeListenerName](e);
          }
      }
  }
  function createWrappedFunction(methodName, applyValue) {
      var fnMethod = function fnMethod(e) {
          e.stopPropagation();
          var vNode = this.$V;
          // If vNode is gone by the time event fires, no-op
          if (!vNode) {
              return;
          }
          var props = vNode.props || EMPTY_OBJ;
          var dom = vNode.dom;
          if (isString$1(methodName)) {
              triggerEventListener(props, methodName, e);
          } else {
              for (var i = 0; i < methodName.length; i++) {
                  triggerEventListener(props, methodName[i], e);
              }
          }
          if (isFunction$1(applyValue)) {
              var newVNode = this.$V;
              var newProps = newVNode.props || EMPTY_OBJ;
              applyValue(newProps, dom, false, newVNode);
          }
      };
      Object.defineProperty(fnMethod, 'wrapped', {
          configurable: false,
          enumerable: false,
          value: true,
          writable: false
      });
      return fnMethod;
  }

  function isCheckedType(type) {
      return type === 'checkbox' || type === 'radio';
  }
  var onTextInputChange = createWrappedFunction('onInput', applyValueInput);
  var wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);
  /* tslint:disable-next-line:no-empty */
  function emptywrapper(event) {
      event.stopPropagation();
  }
  emptywrapper.wrapped = true;
  function inputEvents(dom, nextPropsOrEmpty) {
      if (isCheckedType(nextPropsOrEmpty.type)) {
          dom.onchange = wrappedOnChange;
          dom.onclick = emptywrapper;
      } else {
          dom.oninput = onTextInputChange;
      }
  }
  function applyValueInput(nextPropsOrEmpty, dom) {
      var type = nextPropsOrEmpty.type;
      var value = nextPropsOrEmpty.value;
      var checked = nextPropsOrEmpty.checked;
      var multiple = nextPropsOrEmpty.multiple;
      var defaultValue = nextPropsOrEmpty.defaultValue;
      var hasValue = !isNullOrUndef(value);
      if (type && type !== dom.type) {
          dom.setAttribute('type', type);
      }
      if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {
          dom.multiple = multiple;
      }
      if (!isNullOrUndef(defaultValue) && !hasValue) {
          dom.defaultValue = defaultValue + '';
      }
      if (isCheckedType(type)) {
          if (hasValue) {
              dom.value = value;
          }
          if (!isNullOrUndef(checked)) {
              dom.checked = checked;
          }
      } else {
          if (hasValue && dom.value !== value) {
              dom.defaultValue = value;
              dom.value = value;
          } else if (!isNullOrUndef(checked)) {
              dom.checked = checked;
          }
      }
  }

  function updateChildOptionGroup(vNode, value) {
      var type = vNode.type;
      if (type === 'optgroup') {
          var children = vNode.children;
          var childFlags = vNode.childFlags;
          if (childFlags & 12 /* MultipleChildren */) {
                  for (var i = 0, len = children.length; i < len; i++) {
                      updateChildOption(children[i], value);
                  }
              } else if (childFlags === 2 /* HasVNodeChildren */) {
                  updateChildOption(children, value);
              }
      } else {
          updateChildOption(vNode, value);
      }
  }
  function updateChildOption(vNode, value) {
      var props = vNode.props || EMPTY_OBJ;
      var dom = vNode.dom;
      // we do this as multiple may have changed
      dom.value = props.value;
      if (isArray$2(value) && value.indexOf(props.value) !== -1 || props.value === value) {
          dom.selected = true;
      } else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {
          dom.selected = props.selected || false;
      }
  }
  var onSelectChange = createWrappedFunction('onChange', applyValueSelect);
  function selectEvents(dom) {
      dom.onchange = onSelectChange;
  }
  function applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {
      var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);
      if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {
          dom.multiple = multiplePropInBoolean;
      }
      var childFlags = vNode.childFlags;
      if ((childFlags & 1 /* HasInvalidChildren */) === 0) {
          var children = vNode.children;
          var value = nextPropsOrEmpty.value;
          if (mounting && isNullOrUndef(value)) {
              value = nextPropsOrEmpty.defaultValue;
          }
          if (childFlags & 12 /* MultipleChildren */) {
                  for (var i = 0, len = children.length; i < len; i++) {
                      updateChildOptionGroup(children[i], value);
                  }
              } else if (childFlags === 2 /* HasVNodeChildren */) {
                  updateChildOptionGroup(children, value);
              }
      }
  }

  var onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);
  var wrappedOnChange$1 = createWrappedFunction('onChange');
  function textAreaEvents(dom, nextPropsOrEmpty) {
      dom.oninput = onTextareaInputChange;
      if (nextPropsOrEmpty.onChange) {
          dom.onchange = wrappedOnChange$1;
      }
  }
  function applyValueTextArea(nextPropsOrEmpty, dom, mounting) {
      var value = nextPropsOrEmpty.value;
      var domValue = dom.value;
      if (isNullOrUndef(value)) {
          if (mounting) {
              var defaultValue = nextPropsOrEmpty.defaultValue;
              if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {
                  dom.defaultValue = defaultValue;
                  dom.value = defaultValue;
              }
          }
      } else if (domValue !== value) {
          /* There is value so keep it controlled */
          dom.defaultValue = value;
          dom.value = value;
      }
  }

  /**
   * There is currently no support for switching same input between controlled and nonControlled
   * If that ever becomes a real issue, then re design controlled elements
   * Currently user must choose either controlled or non-controlled and stick with that
   */
  function processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
      if (flags & 64 /* InputElement */) {
              applyValueInput(nextPropsOrEmpty, dom);
          } else if (flags & 256 /* SelectElement */) {
              applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);
          } else if (flags & 128 /* TextareaElement */) {
              applyValueTextArea(nextPropsOrEmpty, dom, mounting);
          }
      if (isControlled) {
          dom.$V = vNode;
      }
  }
  function addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {
      if (flags & 64 /* InputElement */) {
              inputEvents(dom, nextPropsOrEmpty);
          } else if (flags & 256 /* SelectElement */) {
              selectEvents(dom);
          } else if (flags & 128 /* TextareaElement */) {
              textAreaEvents(dom, nextPropsOrEmpty);
          }
  }
  function isControlledFormElement(nextPropsOrEmpty) {
      return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);
  }

  function remove$3(vNode, parentDom) {
      unmount(vNode);
      if (!isNull(parentDom)) {
          removeChild(parentDom, vNode.dom);
          // Let carbage collector free memory
          vNode.dom = null;
      }
  }
  function unmount(vNode) {
      var flags = vNode.flags;
      if (flags & 481 /* Element */) {
              var ref = vNode.ref;
              var props = vNode.props;
              if (isFunction$1(ref)) {
                  ref(null);
              }
              var children = vNode.children;
              var childFlags = vNode.childFlags;
              if (childFlags & 12 /* MultipleChildren */) {
                      unmountAllChildren(children);
                  } else if (childFlags === 2 /* HasVNodeChildren */) {
                      unmount(children);
                  }
              if (!isNull(props)) {
                  for (var name in props) {
                      switch (name) {
                          case 'onClick':
                          case 'onDblClick':
                          case 'onFocusIn':
                          case 'onFocusOut':
                          case 'onKeyDown':
                          case 'onKeyPress':
                          case 'onKeyUp':
                          case 'onMouseDown':
                          case 'onMouseMove':
                          case 'onMouseUp':
                          case 'onSubmit':
                          case 'onTouchEnd':
                          case 'onTouchMove':
                          case 'onTouchStart':
                              handleEvent(name, null, vNode.dom);
                              break;
                          default:
                              break;
                      }
                  }
              }
          } else if (flags & 14 /* Component */) {
              var instance = vNode.children;
              var ref$1 = vNode.ref;
              if (flags & 4 /* ComponentClass */) {
                      if (isFunction$1(options.beforeUnmount)) {
                          options.beforeUnmount(vNode);
                      }
                      if (isFunction$1(instance.componentWillUnmount)) {
                          instance.componentWillUnmount();
                      }
                      if (isFunction$1(ref$1)) {
                          ref$1(null);
                      }
                      instance.$UN = true;
                      unmount(instance.$LI);
                  } else {
                  if (!isNullOrUndef(ref$1) && isFunction$1(ref$1.onComponentWillUnmount)) {
                      ref$1.onComponentWillUnmount(vNode.dom, vNode.props || EMPTY_OBJ);
                  }
                  unmount(instance);
              }
          } else if (flags & 1024 /* Portal */) {
              var children$1 = vNode.children;
              if (!isNull(children$1) && isObject$1(children$1)) {
                  remove$3(children$1, vNode.type);
              }
          }
  }
  function unmountAllChildren(children) {
      for (var i = 0, len = children.length; i < len; i++) {
          unmount(children[i]);
      }
  }
  function removeAllChildren(dom, children) {
      unmountAllChildren(children);
      dom.textContent = '';
  }

  function createLinkEvent(linkEvent, nextValue) {
      return function (e) {
          linkEvent(nextValue.data, e);
      };
  }
  function patchEvent(name, lastValue, nextValue, dom) {
      var nameLowerCase = name.toLowerCase();
      if (!isFunction$1(nextValue) && !isNullOrUndef(nextValue)) {
          var linkEvent = nextValue.event;
          if (linkEvent && isFunction$1(linkEvent)) {
              dom[nameLowerCase] = createLinkEvent(linkEvent, nextValue);
          }
      } else {
          var domEvent = dom[nameLowerCase];
          // if the function is wrapped, that means it's been controlled by a wrapper
          if (!domEvent || !domEvent.wrapped) {
              dom[nameLowerCase] = nextValue;
          }
      }
  }
  function getNumberStyleValue(style, value) {
      switch (style) {
          case 'animationIterationCount':
          case 'borderImageOutset':
          case 'borderImageSlice':
          case 'borderImageWidth':
          case 'boxFlex':
          case 'boxFlexGroup':
          case 'boxOrdinalGroup':
          case 'columnCount':
          case 'fillOpacity':
          case 'flex':
          case 'flexGrow':
          case 'flexNegative':
          case 'flexOrder':
          case 'flexPositive':
          case 'flexShrink':
          case 'floodOpacity':
          case 'fontWeight':
          case 'gridColumn':
          case 'gridRow':
          case 'lineClamp':
          case 'lineHeight':
          case 'opacity':
          case 'order':
          case 'orphans':
          case 'stopOpacity':
          case 'strokeDasharray':
          case 'strokeDashoffset':
          case 'strokeMiterlimit':
          case 'strokeOpacity':
          case 'strokeWidth':
          case 'tabSize':
          case 'widows':
          case 'zIndex':
          case 'zoom':
              return value;
          default:
              return value + 'px';
      }
  }
  // We are assuming here that we come from patchProp routine
  // -nextAttrValue cannot be null or undefined
  function patchStyle(lastAttrValue, nextAttrValue, dom) {
      var domStyle = dom.style;
      var style;
      var value;
      if (isString$1(nextAttrValue)) {
          domStyle.cssText = nextAttrValue;
          return;
      }
      if (!isNullOrUndef(lastAttrValue) && !isString$1(lastAttrValue)) {
          for (style in nextAttrValue) {
              // do not add a hasOwnProperty check here, it affects performance
              value = nextAttrValue[style];
              if (value !== lastAttrValue[style]) {
                  domStyle[style] = isNumber$1(value) ? getNumberStyleValue(style, value) : value;
              }
          }
          for (style in lastAttrValue) {
              if (isNullOrUndef(nextAttrValue[style])) {
                  domStyle[style] = '';
              }
          }
      } else {
          for (style in nextAttrValue) {
              value = nextAttrValue[style];
              domStyle[style] = isNumber$1(value) ? getNumberStyleValue(style, value) : value;
          }
      }
  }
  function patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {
      switch (prop) {
          case 'onClick':
          case 'onDblClick':
          case 'onFocusIn':
          case 'onFocusOut':
          case 'onKeyDown':
          case 'onKeyPress':
          case 'onKeyUp':
          case 'onMouseDown':
          case 'onMouseMove':
          case 'onMouseUp':
          case 'onSubmit':
          case 'onTouchEnd':
          case 'onTouchMove':
          case 'onTouchStart':
              handleEvent(prop, nextValue, dom);
              break;
          case 'children':
          case 'childrenType':
          case 'className':
          case 'defaultValue':
          case 'key':
          case 'multiple':
          case 'ref':
              return;
          case 'allowfullscreen':
          case 'autoFocus':
          case 'autoplay':
          case 'capture':
          case 'checked':
          case 'controls':
          case 'default':
          case 'disabled':
          case 'hidden':
          case 'indeterminate':
          case 'loop':
          case 'muted':
          case 'novalidate':
          case 'open':
          case 'readOnly':
          case 'required':
          case 'reversed':
          case 'scoped':
          case 'seamless':
          case 'selected':
              prop = prop === 'autoFocus' ? prop.toLowerCase() : prop;
              dom[prop] = !!nextValue;
              break;
          case 'defaultChecked':
          case 'value':
          case 'volume':
              if (hasControlledValue && prop === 'value') {
                  return;
              }
              var value = isNullOrUndef(nextValue) ? '' : nextValue;
              if (dom[prop] !== value) {
                  dom[prop] = value;
              }
              break;
          case 'dangerouslySetInnerHTML':
              var lastHtml = lastValue && lastValue.__html || '';
              var nextHtml = nextValue && nextValue.__html || '';
              if (lastHtml !== nextHtml) {
                  if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {
                      if (!isNull(lastVNode)) {
                          if (lastVNode.childFlags & 12 /* MultipleChildren */) {
                                  unmountAllChildren(lastVNode.children);
                              } else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {
                                  unmount(lastVNode.children);
                              }
                          lastVNode.children = null;
                          lastVNode.childFlags = 1 /* HasInvalidChildren */;
                      }
                      dom.innerHTML = nextHtml;
                  }
              }
              break;
          default:
              if (prop[0] === 'o' && prop[1] === 'n') {
                  patchEvent(prop, lastValue, nextValue, dom);
              } else if (isNullOrUndef(nextValue)) {
                  dom.removeAttribute(prop);
              } else if (prop === 'style') {
                  patchStyle(lastValue, nextValue, dom);
              } else if (isSVG && namespaces[prop]) {
                  // We optimize for NS being boolean. Its 99.9% time false
                  // If we end up in this path we can read property again
                  dom.setAttributeNS(namespaces[prop], prop, nextValue);
              } else {
                  dom.setAttribute(prop, nextValue);
              }
              break;
      }
  }
  function mountProps(vNode, flags, props, dom, isSVG) {
      var hasControlledValue = false;
      var isFormElement = (flags & 448 /* FormElement */) > 0;
      if (isFormElement) {
          hasControlledValue = isControlledFormElement(props);
          if (hasControlledValue) {
              addFormElementEventHandlers(flags, dom, props);
          }
      }
      for (var prop in props) {
          // do not add a hasOwnProperty check here, it affects performance
          patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);
      }
      if (isFormElement) {
          processElement(flags, vNode, dom, props, true, hasControlledValue);
      }
  }

  function createClassComponentInstance(vNode, Component, props, context) {
      var instance = new Component(props, context);
      vNode.children = instance;
      instance.$V = vNode;
      instance.$BS = false;
      instance.context = context;
      if (instance.props === EMPTY_OBJ) {
          instance.props = props;
      }
      instance.$UN = false;
      if (isFunction$1(instance.componentWillMount)) {
          instance.$BR = true;
          instance.componentWillMount();
          if (instance.$PSS) {
              var state = instance.state;
              var pending = instance.$PS;
              if (isNull(state)) {
                  instance.state = pending;
              } else {
                  for (var key in pending) {
                      state[key] = pending[key];
                  }
              }
              instance.$PSS = false;
              instance.$PS = null;
          }
          instance.$BR = false;
      }
      if (isFunction$1(options.beforeRender)) {
          options.beforeRender(instance);
      }
      var input = handleComponentInput(instance.render(props, instance.state, context), vNode);
      var childContext;
      if (isFunction$1(instance.getChildContext)) {
          childContext = instance.getChildContext();
      }
      if (isNullOrUndef(childContext)) {
          instance.$CX = context;
      } else {
          instance.$CX = combineFrom(context, childContext);
      }
      if (isFunction$1(options.afterRender)) {
          options.afterRender(instance);
      }
      instance.$LI = input;
      return instance;
  }
  function handleComponentInput(input, componentVNode) {
      if (isInvalid(input)) {
          input = createVoidVNode();
      } else if (isStringOrNumber(input)) {
          input = createTextVNode(input, null);
      } else {
          if (input.dom) {
              input = directClone(input);
          }
          if (input.flags & 14 /* Component */) {
                  // if we have an input that is also a component, we run into a tricky situation
                  // where the root vNode needs to always have the correct DOM entry
                  // we can optimise this in the future, but this gets us out of a lot of issues
                  input.parentVNode = componentVNode;
              }
      }
      return input;
  }

  function mount(vNode, parentDom, lifecycle, context, isSVG) {
      var flags = vNode.flags;
      if (flags & 481 /* Element */) {
              return mountElement(vNode, parentDom, lifecycle, context, isSVG);
          }
      if (flags & 14 /* Component */) {
              return mountComponent(vNode, parentDom, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0);
          }
      if (flags & 512 /* Void */ || flags & 16 /* Text */) {
              return mountText(vNode, parentDom);
          }
      if (flags & 1024 /* Portal */) {
              mount(vNode.children, vNode.type, lifecycle, context, false);
              return vNode.dom = mountText(createVoidVNode(), parentDom);
          }
  }
  function mountText(vNode, parentDom) {
      var dom = vNode.dom = document.createTextNode(vNode.children);
      if (!isNull(parentDom)) {
          appendChild(parentDom, dom);
      }
      return dom;
  }
  function mountElement(vNode, parentDom, lifecycle, context, isSVG) {
      var flags = vNode.flags;
      var children = vNode.children;
      var props = vNode.props;
      var className = vNode.className;
      var ref = vNode.ref;
      var childFlags = vNode.childFlags;
      isSVG = isSVG || (flags & 32 /* SvgElement */) > 0;
      var dom = documentCreateElement(vNode.type, isSVG);
      vNode.dom = dom;
      if (!isNullOrUndef(className) && className !== '') {
          if (isSVG) {
              dom.setAttribute('class', className);
          } else {
              dom.className = className;
          }
      }
      if (!isNull(parentDom)) {
          appendChild(parentDom, dom);
      }
      if ((childFlags & 1 /* HasInvalidChildren */) === 0) {
          var childrenIsSVG = isSVG === true && vNode.type !== 'foreignObject';
          if (childFlags === 2 /* HasVNodeChildren */) {
                  mount(children, dom, lifecycle, context, childrenIsSVG);
              } else if (childFlags & 12 /* MultipleChildren */) {
                  mountArrayChildren(children, dom, lifecycle, context, childrenIsSVG);
              }
      }
      if (!isNull(props)) {
          mountProps(vNode, flags, props, dom, isSVG);
      }
      if (isFunction$1(ref)) {
          mountRef(dom, ref, lifecycle);
      }
      return dom;
  }
  function mountArrayChildren(children, dom, lifecycle, context, isSVG) {
      for (var i = 0, len = children.length; i < len; i++) {
          var child = children[i];
          if (!isNull(child.dom)) {
              children[i] = child = directClone(child);
          }
          mount(child, dom, lifecycle, context, isSVG);
      }
  }
  function mountComponent(vNode, parentDom, lifecycle, context, isSVG, isClass) {
      var dom;
      var type = vNode.type;
      var props = vNode.props || EMPTY_OBJ;
      var ref = vNode.ref;
      if (isClass) {
          var instance = createClassComponentInstance(vNode, type, props, context);
          vNode.dom = dom = mount(instance.$LI, null, lifecycle, instance.$CX, isSVG);
          mountClassComponentCallbacks(vNode, ref, instance, lifecycle);
          instance.$UPD = false;
      } else {
          var input = handleComponentInput(type(props, context), vNode);
          vNode.children = input;
          vNode.dom = dom = mount(input, null, lifecycle, context, isSVG);
          mountFunctionalComponentCallbacks(props, ref, dom, lifecycle);
      }
      if (!isNull(parentDom)) {
          appendChild(parentDom, dom);
      }
      return dom;
  }
  function createClassMountCallback(instance, hasAfterMount, afterMount, vNode, hasDidMount) {
      return function () {
          instance.$UPD = true;
          if (hasAfterMount) {
              afterMount(vNode);
          }
          if (hasDidMount) {
              instance.componentDidMount();
          }
          instance.$UPD = false;
      };
  }
  function mountClassComponentCallbacks(vNode, ref, instance, lifecycle) {
      if (isFunction$1(ref)) {
          ref(instance);
      }
      var hasDidMount = isFunction$1(instance.componentDidMount);
      var afterMount = options.afterMount;
      var hasAfterMount = isFunction$1(afterMount);
      if (hasDidMount || hasAfterMount) {
          lifecycle.push(createClassMountCallback(instance, hasAfterMount, afterMount, vNode, hasDidMount));
      }
  }
  // Create did mount callback lazily to avoid creating function context if not needed
  function createOnMountCallback(ref, dom, props) {
      return function () {
          return ref.onComponentDidMount(dom, props);
      };
  }
  function mountFunctionalComponentCallbacks(props, ref, dom, lifecycle) {
      if (!isNullOrUndef(ref)) {
          if (isFunction$1(ref.onComponentWillMount)) {
              ref.onComponentWillMount(props);
          }
          if (isFunction$1(ref.onComponentDidMount)) {
              lifecycle.push(createOnMountCallback(ref, dom, props));
          }
      }
  }
  function mountRef(dom, value, lifecycle) {
      lifecycle.push(function () {
          return value(dom);
      });
  }

  function hydrateComponent(vNode, dom, lifecycle, context, isSVG, isClass) {
      var type = vNode.type;
      var ref = vNode.ref;
      var props = vNode.props || EMPTY_OBJ;
      if (isClass) {
          var instance = createClassComponentInstance(vNode, type, props, context);
          var input = instance.$LI;
          hydrateVNode(input, dom, lifecycle, instance.$CX, isSVG);
          vNode.dom = input.dom;
          mountClassComponentCallbacks(vNode, ref, instance, lifecycle);
          instance.$UPD = false; // Mount finished allow going sync
      } else {
          var input$1 = handleComponentInput(type(props, context), vNode);
          hydrateVNode(input$1, dom, lifecycle, context, isSVG);
          vNode.children = input$1;
          vNode.dom = input$1.dom;
          mountFunctionalComponentCallbacks(props, ref, dom, lifecycle);
      }
  }
  function hydrateElement(vNode, dom, lifecycle, context, isSVG) {
      var children = vNode.children;
      var props = vNode.props;
      var className = vNode.className;
      var flags = vNode.flags;
      var ref = vNode.ref;
      isSVG = isSVG || (flags & 32 /* SvgElement */) > 0;
      if (dom.nodeType !== 1 || dom.tagName.toLowerCase() !== vNode.type) {
          var newDom = mountElement(vNode, null, lifecycle, context, isSVG);
          vNode.dom = newDom;
          replaceChild(dom.parentNode, newDom, dom);
      } else {
          vNode.dom = dom;
          var childNode = dom.firstChild;
          var childFlags = vNode.childFlags;
          if ((childFlags & 1 /* HasInvalidChildren */) === 0) {
              var nextSibling = null;
              while (childNode) {
                  nextSibling = childNode.nextSibling;
                  if (childNode.nodeType === 8) {
                      if (childNode.data === '!') {
                          dom.replaceChild(document.createTextNode(''), childNode);
                      } else {
                          dom.removeChild(childNode);
                      }
                  }
                  childNode = nextSibling;
              }
              childNode = dom.firstChild;
              if (childFlags === 2 /* HasVNodeChildren */) {
                      if (isNull(childNode)) {
                          mount(children, dom, lifecycle, context, isSVG);
                      } else {
                          nextSibling = childNode.nextSibling;
                          hydrateVNode(children, childNode, lifecycle, context, isSVG);
                          childNode = nextSibling;
                      }
                  } else if (childFlags & 12 /* MultipleChildren */) {
                      for (var i = 0, len = children.length; i < len; i++) {
                          var child = children[i];
                          if (isNull(childNode)) {
                              mount(child, dom, lifecycle, context, isSVG);
                          } else {
                              nextSibling = childNode.nextSibling;
                              hydrateVNode(child, childNode, lifecycle, context, isSVG);
                              childNode = nextSibling;
                          }
                      }
                  }
              // clear any other DOM nodes, there should be only a single entry for the root
              while (childNode) {
                  nextSibling = childNode.nextSibling;
                  dom.removeChild(childNode);
                  childNode = nextSibling;
              }
          } else if (!isNull(dom.firstChild) && !isSamePropsInnerHTML(dom, props)) {
              dom.textContent = ''; // dom has content, but VNode has no children remove everything from DOM
              if (flags & 448 /* FormElement */) {
                      // If element is form element, we need to clear defaultValue also
                      dom.defaultValue = '';
                  }
          }
          if (!isNull(props)) {
              mountProps(vNode, flags, props, dom, isSVG);
          }
          if (isNullOrUndef(className)) {
              if (dom.className !== '') {
                  dom.removeAttribute('class');
              }
          } else if (isSVG) {
              dom.setAttribute('class', className);
          } else {
              dom.className = className;
          }
          if (isFunction$1(ref)) {
              mountRef(dom, ref, lifecycle);
          }
      }
  }
  function hydrateText(vNode, dom) {
      if (dom.nodeType !== 3) {
          var newDom = mountText(vNode, null);
          vNode.dom = newDom;
          replaceChild(dom.parentNode, newDom, dom);
      } else {
          var text = vNode.children;
          if (dom.nodeValue !== text) {
              dom.nodeValue = text;
          }
          vNode.dom = dom;
      }
  }
  function hydrateVNode(vNode, dom, lifecycle, context, isSVG) {
      var flags = vNode.flags;
      if (flags & 14 /* Component */) {
              hydrateComponent(vNode, dom, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0);
          } else if (flags & 481 /* Element */) {
              hydrateElement(vNode, dom, lifecycle, context, isSVG);
          } else if (flags & 16 /* Text */) {
              hydrateText(vNode, dom);
          } else if (flags & 512 /* Void */) {
              vNode.dom = dom;
          } else {
          throwError();
      }
  }
  function hydrate(input, parentDom, callback) {
      var dom = parentDom.firstChild;
      if (!isNull(dom)) {
          if (!isInvalid(input)) {
              hydrateVNode(input, dom, LIFECYCLE, EMPTY_OBJ, false);
          }
          dom = parentDom.firstChild;
          // clear any other DOM nodes, there should be only a single entry for the root
          while (dom = dom.nextSibling) {
              parentDom.removeChild(dom);
          }
      }
      if (LIFECYCLE.length > 0) {
          callAll(LIFECYCLE);
      }
      if (!parentDom.$V) {
          options.roots.push(parentDom);
      }
      parentDom.$V = input;
      if (isFunction$1(callback)) {
          callback();
      }
  }

  function replaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, isSVG) {
      unmount(lastNode);
      replaceChild(parentDom, mount(nextNode, null, lifecycle, context, isSVG), lastNode.dom);
  }
  function patch(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG) {
      if (lastVNode !== nextVNode) {
          var nextFlags = nextVNode.flags | 0;
          if (lastVNode.flags !== nextFlags || nextFlags & 2048 /* ReCreate */) {
                  replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG);
              } else if (nextFlags & 481 /* Element */) {
                  patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG);
              } else if (nextFlags & 14 /* Component */) {
                  patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, (nextFlags & 4 /* ComponentClass */) > 0);
              } else if (nextFlags & 16 /* Text */) {
                  patchText(lastVNode, nextVNode, parentDom);
              } else if (nextFlags & 512 /* Void */) {
                  nextVNode.dom = lastVNode.dom;
              } else {
              // Portal
              patchPortal(lastVNode, nextVNode, lifecycle, context);
          }
      }
  }
  function patchPortal(lastVNode, nextVNode, lifecycle, context) {
      var lastContainer = lastVNode.type;
      var nextContainer = nextVNode.type;
      var nextChildren = nextVNode.children;
      patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, lifecycle, context, false);
      nextVNode.dom = lastVNode.dom;
      if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {
          var node = nextChildren.dom;
          lastContainer.removeChild(node);
          nextContainer.appendChild(node);
      }
  }
  function patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG) {
      var nextTag = nextVNode.type;
      if (lastVNode.type !== nextTag) {
          replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG);
      } else {
          var dom = lastVNode.dom;
          var nextFlags = nextVNode.flags;
          var lastProps = lastVNode.props;
          var nextProps = nextVNode.props;
          var isFormElement = false;
          var hasControlledValue = false;
          var nextPropsOrEmpty;
          nextVNode.dom = dom;
          isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;
          // inlined patchProps  -- starts --
          if (lastProps !== nextProps) {
              var lastPropsOrEmpty = lastProps || EMPTY_OBJ;
              nextPropsOrEmpty = nextProps || EMPTY_OBJ;
              if (nextPropsOrEmpty !== EMPTY_OBJ) {
                  isFormElement = (nextFlags & 448 /* FormElement */) > 0;
                  if (isFormElement) {
                      hasControlledValue = isControlledFormElement(nextPropsOrEmpty);
                  }
                  for (var prop in nextPropsOrEmpty) {
                      var lastValue = lastPropsOrEmpty[prop];
                      var nextValue = nextPropsOrEmpty[prop];
                      if (lastValue !== nextValue) {
                          patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);
                      }
                  }
              }
              if (lastPropsOrEmpty !== EMPTY_OBJ) {
                  for (var prop$1 in lastPropsOrEmpty) {
                      // do not add a hasOwnProperty check here, it affects performance
                      if (!nextPropsOrEmpty.hasOwnProperty(prop$1) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {
                          patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);
                      }
                  }
              }
          }
          var lastChildren = lastVNode.children;
          var nextChildren = nextVNode.children;
          var nextRef = nextVNode.ref;
          var lastClassName = lastVNode.className;
          var nextClassName = nextVNode.className;
          if (lastChildren !== nextChildren) {
              patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastChildren, nextChildren, dom, lifecycle, context, isSVG && nextTag !== 'foreignObject');
          }
          if (isFormElement) {
              processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);
          }
          // inlined patchProps  -- ends --
          if (lastClassName !== nextClassName) {
              if (isNullOrUndef(nextClassName)) {
                  dom.removeAttribute('class');
              } else if (isSVG) {
                  dom.setAttribute('class', nextClassName);
              } else {
                  dom.className = nextClassName;
              }
          }
          if (isFunction$1(nextRef) && lastVNode.ref !== nextRef) {
              mountRef(dom, nextRef, lifecycle);
          }
      }
  }
  function patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, lifecycle, context, isSVG) {
      switch (lastChildFlags) {
          case 2 /* HasVNodeChildren */:
              switch (nextChildFlags) {
                  case 2 /* HasVNodeChildren */:
                      patch(lastChildren, nextChildren, parentDOM, lifecycle, context, isSVG);
                      break;
                  case 1 /* HasInvalidChildren */:
                      remove$3(lastChildren, parentDOM);
                      break;
                  default:
                      remove$3(lastChildren, parentDOM);
                      mountArrayChildren(nextChildren, parentDOM, lifecycle, context, isSVG);
                      break;
              }
              break;
          case 1 /* HasInvalidChildren */:
              switch (nextChildFlags) {
                  case 2 /* HasVNodeChildren */:
                      mount(nextChildren, parentDOM, lifecycle, context, isSVG);
                      break;
                  case 1 /* HasInvalidChildren */:
                      break;
                  default:
                      mountArrayChildren(nextChildren, parentDOM, lifecycle, context, isSVG);
                      break;
              }
              break;
          default:
              if (nextChildFlags & 12 /* MultipleChildren */) {
                      var lastLength = lastChildren.length;
                      var nextLength = nextChildren.length;
                      // Fast path's for both algorithms
                      if (lastLength === 0) {
                          if (nextLength > 0) {
                              mountArrayChildren(nextChildren, parentDOM, lifecycle, context, isSVG);
                          }
                      } else if (nextLength === 0) {
                          removeAllChildren(parentDOM, lastChildren);
                      } else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {
                              patchKeyedChildren(lastChildren, nextChildren, parentDOM, lifecycle, context, isSVG, lastLength, nextLength);
                          } else {
                          patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, lifecycle, context, isSVG, lastLength, nextLength);
                      }
                  } else if (nextChildFlags === 1 /* HasInvalidChildren */) {
                      removeAllChildren(parentDOM, lastChildren);
                  } else {
                  removeAllChildren(parentDOM, lastChildren);
                  mount(nextChildren, parentDOM, lifecycle, context, isSVG);
              }
              break;
      }
  }
  function updateClassComponent(instance, nextState, nextVNode, nextProps, parentDom, lifecycle, context, isSVG, force, fromSetState) {
      var lastState = instance.state;
      var lastProps = instance.props;
      nextVNode.children = instance;
      var renderOutput;
      if (instance.$UN) {
          return;
      }
      if (lastProps !== nextProps || nextProps === EMPTY_OBJ) {
          if (!fromSetState && isFunction$1(instance.componentWillReceiveProps)) {
              instance.$BR = true;
              instance.componentWillReceiveProps(nextProps, context);
              // If instance component was removed during its own update do nothing...
              if (instance.$UN) {
                  return;
              }
              instance.$BR = false;
          }
          if (instance.$PSS) {
              nextState = combineFrom(nextState, instance.$PS);
              instance.$PSS = false;
              instance.$PS = null;
          }
      }
      /* Update if scu is not defined, or it returns truthy value or force */
      var hasSCU = isFunction$1(instance.shouldComponentUpdate);
      if (force || !hasSCU || hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context)) {
          if (isFunction$1(instance.componentWillUpdate)) {
              instance.$BS = true;
              instance.componentWillUpdate(nextProps, nextState, context);
              instance.$BS = false;
          }
          instance.props = nextProps;
          instance.state = nextState;
          instance.context = context;
          if (isFunction$1(options.beforeRender)) {
              options.beforeRender(instance);
          }
          renderOutput = instance.render(nextProps, nextState, context);
          if (isFunction$1(options.afterRender)) {
              options.afterRender(instance);
          }
          var didUpdate = renderOutput !== NO_OP;
          var childContext;
          if (isFunction$1(instance.getChildContext)) {
              childContext = instance.getChildContext();
          }
          if (isNullOrUndef(childContext)) {
              childContext = context;
          } else {
              childContext = combineFrom(context, childContext);
          }
          instance.$CX = childContext;
          if (didUpdate) {
              var lastInput = instance.$LI;
              var nextInput = instance.$LI = handleComponentInput(renderOutput, nextVNode);
              patch(lastInput, nextInput, parentDom, lifecycle, childContext, isSVG);
              if (isFunction$1(instance.componentDidUpdate)) {
                  instance.componentDidUpdate(lastProps, lastState);
              }
              if (isFunction$1(options.afterUpdate)) {
                  options.afterUpdate(nextVNode);
              }
          }
      } else {
          instance.props = nextProps;
          instance.state = nextState;
          instance.context = context;
      }
      nextVNode.dom = instance.$LI.dom;
  }
  function patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass) {
      var nextType = nextVNode.type;
      var lastKey = lastVNode.key;
      var nextKey = nextVNode.key;
      if (lastVNode.type !== nextType || lastKey !== nextKey) {
          replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG);
      } else {
          var nextProps = nextVNode.props || EMPTY_OBJ;
          if (isClass) {
              var instance = lastVNode.children;
              instance.$UPD = true;
              updateClassComponent(instance, instance.state, nextVNode, nextProps, parentDom, lifecycle, context, isSVG, false, false);
              instance.$V = nextVNode;
              instance.$UPD = false;
          } else {
              var shouldUpdate = true;
              var lastProps = lastVNode.props;
              var nextHooks = nextVNode.ref;
              var nextHooksDefined = !isNullOrUndef(nextHooks);
              var lastInput = lastVNode.children;
              nextVNode.dom = lastVNode.dom;
              nextVNode.children = lastInput;
              if (nextHooksDefined && isFunction$1(nextHooks.onComponentShouldUpdate)) {
                  shouldUpdate = nextHooks.onComponentShouldUpdate(lastProps, nextProps);
              }
              if (shouldUpdate !== false) {
                  if (nextHooksDefined && isFunction$1(nextHooks.onComponentWillUpdate)) {
                      nextHooks.onComponentWillUpdate(lastProps, nextProps);
                  }
                  var nextInput = nextType(nextProps, context);
                  if (nextInput !== NO_OP) {
                      nextInput = handleComponentInput(nextInput, nextVNode);
                      patch(lastInput, nextInput, parentDom, lifecycle, context, isSVG);
                      nextVNode.children = nextInput;
                      nextVNode.dom = nextInput.dom;
                      if (nextHooksDefined && isFunction$1(nextHooks.onComponentDidUpdate)) {
                          nextHooks.onComponentDidUpdate(lastProps, nextProps);
                      }
                  }
              } else if (lastInput.flags & 14 /* Component */) {
                      lastInput.parentVNode = nextVNode;
                  }
          }
      }
  }
  function patchText(lastVNode, nextVNode, parentDom) {
      var nextText = nextVNode.children;
      var textNode = parentDom.firstChild;
      var dom;
      // Guard against external change on DOM node.
      if (isNull(textNode)) {
          parentDom.textContent = nextText;
          dom = parentDom.firstChild;
      } else {
          dom = lastVNode.dom;
          if (nextText !== lastVNode.children) {
              dom.nodeValue = nextText;
          }
      }
      nextVNode.dom = dom;
  }
  function patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, lastChildrenLength, nextChildrenLength) {
      var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;
      var i = 0;
      var nextChild;
      for (; i < commonLength; i++) {
          nextChild = nextChildren[i];
          if (nextChild.dom) {
              nextChild = nextChildren[i] = directClone(nextChild);
          }
          patch(lastChildren[i], nextChild, dom, lifecycle, context, isSVG);
      }
      if (lastChildrenLength < nextChildrenLength) {
          for (i = commonLength; i < nextChildrenLength; i++) {
              nextChild = nextChildren[i];
              if (nextChild.dom) {
                  nextChild = nextChildren[i] = directClone(nextChild);
              }
              mount(nextChild, dom, lifecycle, context, isSVG);
          }
      } else if (lastChildrenLength > nextChildrenLength) {
          for (i = commonLength; i < lastChildrenLength; i++) {
              remove$3(lastChildren[i], dom);
          }
      }
  }
  function patchKeyedChildren(a, b, dom, lifecycle, context, isSVG, aLength, bLength) {
      var aEnd = aLength - 1;
      var bEnd = bLength - 1;
      var aStart = 0;
      var bStart = 0;
      var i;
      var j;
      var aNode = a[aStart];
      var bNode = b[bStart];
      var nextNode;
      var nextPos;
      // Step 1
      // tslint:disable-next-line
      outer: {
          // Sync nodes with the same key at the beginning.
          while (aNode.key === bNode.key) {
              if (bNode.dom) {
                  b[bStart] = bNode = directClone(bNode);
              }
              patch(aNode, bNode, dom, lifecycle, context, isSVG);
              aStart++;
              bStart++;
              if (aStart > aEnd || bStart > bEnd) {
                  break outer;
              }
              aNode = a[aStart];
              bNode = b[bStart];
          }
          aNode = a[aEnd];
          bNode = b[bEnd];
          // Sync nodes with the same key at the end.
          while (aNode.key === bNode.key) {
              if (bNode.dom) {
                  b[bEnd] = bNode = directClone(bNode);
              }
              patch(aNode, bNode, dom, lifecycle, context, isSVG);
              aEnd--;
              bEnd--;
              if (aStart > aEnd || bStart > bEnd) {
                  break outer;
              }
              aNode = a[aEnd];
              bNode = b[bEnd];
          }
      }
      if (aStart > aEnd) {
          if (bStart <= bEnd) {
              nextPos = bEnd + 1;
              nextNode = nextPos < bLength ? b[nextPos].dom : null;
              while (bStart <= bEnd) {
                  bNode = b[bStart];
                  if (bNode.dom) {
                      b[bStart] = bNode = directClone(bNode);
                  }
                  bStart++;
                  insertOrAppend(dom, mount(bNode, null, lifecycle, context, isSVG), nextNode);
              }
          }
      } else if (bStart > bEnd) {
          while (aStart <= aEnd) {
              remove$3(a[aStart++], dom);
          }
      } else {
          var aLeft = aEnd - aStart + 1;
          var bLeft = bEnd - bStart + 1;
          var sources = [];
          for (i = 0; i < bLeft; i++) {
              sources.push(0);
          }
          // Keep track if its possible to remove whole DOM using textContent = '';
          var canRemoveWholeContent = aLeft === aLength;
          var moved = false;
          var pos = 0;
          var patched = 0;
          // When sizes are small, just loop them through
          if (bLength < 4 || (aLeft | bLeft) < 32) {
              for (i = aStart; i <= aEnd; i++) {
                  aNode = a[i];
                  if (patched < bLeft) {
                      for (j = bStart; j <= bEnd; j++) {
                          bNode = b[j];
                          if (aNode.key === bNode.key) {
                              sources[j - bStart] = i + 1;
                              if (canRemoveWholeContent) {
                                  canRemoveWholeContent = false;
                                  while (i > aStart) {
                                      remove$3(a[aStart++], dom);
                                  }
                              }
                              if (pos > j) {
                                  moved = true;
                              } else {
                                  pos = j;
                              }
                              if (bNode.dom) {
                                  b[j] = bNode = directClone(bNode);
                              }
                              patch(aNode, bNode, dom, lifecycle, context, isSVG);
                              patched++;
                              break;
                          }
                      }
                      if (!canRemoveWholeContent && j > bEnd) {
                          remove$3(aNode, dom);
                      }
                  } else if (!canRemoveWholeContent) {
                      remove$3(aNode, dom);
                  }
              }
          } else {
              var keyIndex = {};
              // Map keys by their index
              for (i = bStart; i <= bEnd; i++) {
                  keyIndex[b[i].key] = i;
              }
              // Try to patch same keys
              for (i = aStart; i <= aEnd; i++) {
                  aNode = a[i];
                  if (patched < bLeft) {
                      j = keyIndex[aNode.key];
                      if (j !== void 0) {
                          if (canRemoveWholeContent) {
                              canRemoveWholeContent = false;
                              while (i > aStart) {
                                  remove$3(a[aStart++], dom);
                              }
                          }
                          bNode = b[j];
                          sources[j - bStart] = i + 1;
                          if (pos > j) {
                              moved = true;
                          } else {
                              pos = j;
                          }
                          if (bNode.dom) {
                              b[j] = bNode = directClone(bNode);
                          }
                          patch(aNode, bNode, dom, lifecycle, context, isSVG);
                          patched++;
                      } else if (!canRemoveWholeContent) {
                          remove$3(aNode, dom);
                      }
                  } else if (!canRemoveWholeContent) {
                      remove$3(aNode, dom);
                  }
              }
          }
          // fast-path: if nothing patched remove all old and add all new
          if (canRemoveWholeContent) {
              removeAllChildren(dom, a);
              mountArrayChildren(b, dom, lifecycle, context, isSVG);
          } else {
              if (moved) {
                  var seq = lis_algorithm(sources);
                  j = seq.length - 1;
                  for (i = bLeft - 1; i >= 0; i--) {
                      if (sources[i] === 0) {
                          pos = i + bStart;
                          bNode = b[pos];
                          if (bNode.dom) {
                              b[pos] = bNode = directClone(bNode);
                          }
                          nextPos = pos + 1;
                          insertOrAppend(dom, mount(bNode, null, lifecycle, context, isSVG), nextPos < bLength ? b[nextPos].dom : null);
                      } else if (j < 0 || i !== seq[j]) {
                          pos = i + bStart;
                          bNode = b[pos];
                          nextPos = pos + 1;
                          insertOrAppend(dom, bNode.dom, nextPos < bLength ? b[nextPos].dom : null);
                      } else {
                          j--;
                      }
                  }
              } else if (patched !== bLeft) {
                  // when patched count doesn't match b length we need to insert those new ones
                  // loop backwards so we can use insertBefore
                  for (i = bLeft - 1; i >= 0; i--) {
                      if (sources[i] === 0) {
                          pos = i + bStart;
                          bNode = b[pos];
                          if (bNode.dom) {
                              b[pos] = bNode = directClone(bNode);
                          }
                          nextPos = pos + 1;
                          insertOrAppend(dom, mount(bNode, null, lifecycle, context, isSVG), nextPos < bLength ? b[nextPos].dom : null);
                      }
                  }
              }
          }
      }
  }
  // https://en.wikipedia.org/wiki/Longest_increasing_subsequence
  function lis_algorithm(arr) {
      var p = arr.slice();
      var result = [0];
      var i;
      var j;
      var u;
      var v;
      var c;
      var len = arr.length;
      for (i = 0; i < len; i++) {
          var arrI = arr[i];
          if (arrI !== 0) {
              j = result[result.length - 1];
              if (arr[j] < arrI) {
                  p[i] = j;
                  result.push(i);
                  continue;
              }
              u = 0;
              v = result.length - 1;
              while (u < v) {
                  c = (u + v) / 2 | 0;
                  if (arr[result[c]] < arrI) {
                      u = c + 1;
                  } else {
                      v = c;
                  }
              }
              if (arrI < arr[result[u]]) {
                  if (u > 0) {
                      p[i] = result[u - 1];
                  }
                  result[u] = i;
              }
          }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
          result[u] = v;
          v = p[v];
      }
      return result;
  }

  var roots = options.roots;
  var documentBody = isBrowser ? document.body : null;
  function render(input, parentDom, callback) {
      if (input === NO_OP) {
          return;
      }
      var rootLen = roots.length;
      var rootInput;
      var index;
      for (index = 0; index < rootLen; index++) {
          if (roots[index] === parentDom) {
              rootInput = parentDom.$V;
              break;
          }
      }
      if (isUndefined$2(rootInput)) {
          if (!isInvalid(input)) {
              if (input.dom) {
                  input = directClone(input);
              }
              if (isNull(parentDom.firstChild)) {
                  mount(input, parentDom, LIFECYCLE, EMPTY_OBJ, false);
                  parentDom.$V = input;
                  roots.push(parentDom);
              } else {
                  hydrate(input, parentDom);
              }
              rootInput = input;
          }
      } else {
          if (isNullOrUndef(input)) {
              remove$3(rootInput, parentDom);
              roots.splice(index, 1);
          } else {
              if (input.dom) {
                  input = directClone(input);
              }
              patch(rootInput, input, parentDom, LIFECYCLE, EMPTY_OBJ, false);
              rootInput = parentDom.$V = input;
          }
      }
      if (LIFECYCLE.length > 0) {
          callAll(LIFECYCLE);
      }
      if (isFunction$1(callback)) {
          callback();
      }
      if (rootInput && rootInput.flags & 14 /* Component */) {
              return rootInput.children;
          }
  }
  function createPortal(children, container) {
      return createVNode(1024 /* Portal */, container, null, children, 0 /* UnknownChildren */, null, isInvalid(children) ? null : children.key, null);
  }

  var resolvedPromise = typeof Promise === 'undefined' ? null : Promise.resolve();
  // raf.bind(window) is needed to work around bug in IE10-IE11 strict mode (TypeError: Invalid calling object)
  var fallbackMethod = typeof requestAnimationFrame === 'undefined' ? setTimeout : requestAnimationFrame.bind(window);
  function nextTick(fn) {
      if (resolvedPromise) {
          return resolvedPromise.then(fn);
      }
      return fallbackMethod(fn);
  }
  function queueStateChanges(component, newState, callback) {
      if (isFunction$1(newState)) {
          newState = newState(component.state, component.props, component.context);
      }
      var pending = component.$PS;
      if (isNullOrUndef(pending)) {
          component.$PS = newState;
      } else {
          for (var stateKey in newState) {
              pending[stateKey] = newState[stateKey];
          }
      }
      if (!component.$PSS && !component.$BR) {
          if (!component.$UPD) {
              component.$PSS = true;
              component.$UPD = true;
              applyState(component, false, callback);
              component.$UPD = false;
          } else {
              // Async
              var queue = component.$QU;
              if (isNull(queue)) {
                  queue = component.$QU = [];
                  nextTick(promiseCallback(component, queue));
              }
              if (isFunction$1(callback)) {
                  queue.push(callback);
              }
          }
      } else {
          component.$PSS = true;
          if (component.$BR && isFunction$1(callback)) {
              LIFECYCLE.push(callback.bind(component));
          }
      }
  }
  function promiseCallback(component, queue) {
      return function () {
          component.$QU = null;
          component.$UPD = true;
          applyState(component, false, function () {
              for (var i = 0, len = queue.length; i < len; i++) {
                  queue[i].call(component);
              }
          });
          component.$UPD = false;
      };
  }
  function applyState(component, force, callback) {
      if (component.$UN) {
          return;
      }
      if (force || !component.$BR) {
          component.$PSS = false;
          var pendingState = component.$PS;
          var prevState = component.state;
          var nextState = combineFrom(prevState, pendingState);
          var props = component.props;
          var context = component.context;
          component.$PS = null;
          var vNode = component.$V;
          var lastInput = component.$LI;
          var parentDom = lastInput.dom && lastInput.dom.parentNode;
          updateClassComponent(component, nextState, vNode, props, parentDom, LIFECYCLE, context, (vNode.flags & 32 /* SvgElement */) > 0, force, true);
          if (component.$UN) {
              return;
          }
          if ((component.$LI.flags & 1024 /* Portal */) === 0) {
              var dom = component.$LI.dom;
              while (!isNull(vNode = vNode.parentVNode)) {
                  if ((vNode.flags & 14 /* Component */) > 0) {
                      vNode.dom = dom;
                  }
              }
          }
          if (LIFECYCLE.length > 0) {
              callAll(LIFECYCLE);
          }
      } else {
          component.state = component.$PS;
          component.$PS = null;
      }
      if (isFunction$1(callback)) {
          callback.call(component);
      }
  }
  var Component = function Component(props, context) {
      this.state = null;
      // Internal properties
      this.$BR = false; // BLOCK RENDER
      this.$BS = true; // BLOCK STATE
      this.$PSS = false; // PENDING SET STATE
      this.$PS = null; // PENDING STATE (PARTIAL or FULL)
      this.$LI = null; // LAST INPUT
      this.$V = null; // VNODE
      this.$UN = false; // UNMOUNTED
      this.$CX = null; // CHILDCONTEXT
      this.$UPD = true; // UPDATING
      this.$QU = null; // QUEUE
      /** @type {object} */
      this.props = props || EMPTY_OBJ;
      /** @type {object} */
      this.context = context || EMPTY_OBJ; // context should not be mutable
  };
  Component.prototype.forceUpdate = function forceUpdate(callback) {
      if (this.$UN) {
          return;
      }
      applyState(this, true, callback);
  };
  Component.prototype.setState = function setState(newState, callback) {
      if (this.$UN) {
          return;
      }
      if (!this.$BS) {
          queueStateChanges(this, newState, callback);
      } else {
          return;
      }
  };
  // tslint:disable-next-line:no-empty
  Component.prototype.render = function render(nextProps, nextState, nextContext) {};
  // Public
  Component.defaultProps = null;

  var JSX = /*#__PURE__*/Object.freeze({});

  var _typeof$11 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$7 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$8(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$2(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$11(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$11(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var TableComponent = function (_Component) {
    _inherits$2(TableComponent, _Component);

    function TableComponent(props) {
      _classCallCheck$8(this, TableComponent);

      var _this = _possibleConstructorReturn$2(this, (TableComponent.__proto__ || Object.getPrototypeOf(TableComponent)).call(this, props));

      var injector = _this._injector = props.injector;

      _this._sheet = injector.get('sheet');
      _this._changeSupport = injector.get('changeSupport');
      _this._components = injector.get('components');

      _this.onElementsChanged = _this.onElementsChanged.bind(_this);
      return _this;
    }

    _createClass$7(TableComponent, [{
      key: 'onElementsChanged',
      value: function onElementsChanged() {
        this.forceUpdate();
      }
    }, {
      key: 'getChildContext',
      value: function getChildContext() {
        return {
          changeSupport: this._changeSupport,
          components: this._components,
          injector: this._injector
        };
      }
    }, {
      key: 'componentWillMount',
      value: function componentWillMount() {
        var _sheet$getRoot = this._sheet.getRoot(),
            id = _sheet$getRoot.id;

        this._changeSupport.onElementsChanged(id, this.onElementsChanged);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        var _sheet$getRoot2 = this._sheet.getRoot(),
            id = _sheet$getRoot2.id;

        this._changeSupport.offElementsChanged(id, this.onElementsChanged);
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _sheet$getRoot3 = this._sheet.getRoot(),
            rows = _sheet$getRoot3.rows,
            cols = _sheet$getRoot3.cols;

        var beforeTableComponents = this._components.getComponents('table.before');
        var afterTableComponents = this._components.getComponents('table.after');

        var Head = this._components.getComponent('table.head');
        var Body = this._components.getComponent('table.body');
        var Foot = this._components.getComponent('table.foot');

        return createVNode(1, 'div', 'tjs-container', [beforeTableComponents && beforeTableComponents.map(function (Component$$1, index) {
          return createComponentVNode(2, Component$$1, null, index);
        }), createVNode(1, 'table', 'tjs-table', [Head && createComponentVNode(2, Head, {
          'rows': rows,
          'cols': cols
        }), Body && createComponentVNode(2, Body, {
          'rows': rows,
          'cols': cols
        }), Foot && createComponentVNode(2, Foot, {
          'rows': rows,
          'cols': cols
        })], 0), afterTableComponents && afterTableComponents.map(function (Component$$1, index) {
          return createComponentVNode(2, Component$$1, null, index);
        })], 0);
      }
    }]);

    return TableComponent;
  }(Component);

  var _createClass$8 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$9(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Renderer = function () {
    function Renderer(changeSupport, components, config, eventBus, injector) {
      _classCallCheck$9(this, Renderer);

      var container = config.container;

      this._container = container;

      eventBus.on('root.added', function () {
        render(createComponentVNode(2, TableComponent, {
          'injector': injector
        }), container);
      });

      eventBus.on('root.remove', function () {
        render(null, container);
      });
    }

    _createClass$8(Renderer, [{
      key: 'getContainer',
      value: function getContainer() {
        return this._container;
      }
    }]);

    return Renderer;
  }();

  Renderer.$inject = ['changeSupport', 'components', 'config.renderer', 'eventBus', 'injector'];

  var renderModule = {
    __init__: ['changeSupport', 'components', 'renderer'],
    changeSupport: ['type', ChangeSupport$1],
    components: ['type', Components],
    renderer: ['type', Renderer]
  };

  var _createClass$9 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$10(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Sheet = function () {
    function Sheet(elementRegistry, eventBus) {
      var _this = this;

      _classCallCheck$10(this, Sheet);

      this._elementRegistry = elementRegistry;
      this._eventBus = eventBus;

      this._root = null;

      eventBus.on('table.clear', function () {
        _this.setRoot(null);
      });
    }

    _createClass$9(Sheet, [{
      key: 'setRoot',
      value: function setRoot(root) {
        if (this._root) {
          var oldRoot = this._root;

          this._eventBus.fire('root.remove', { root: oldRoot });

          this._root = null;

          this._eventBus.fire('root.removed', { root: oldRoot });
        }

        if (root) {
          this._eventBus.fire('root.add', { root: root });
        }

        this._root = root;

        if (root) {
          this._eventBus.fire('root.added', { root: root });
        }
      }
    }, {
      key: 'getRoot',
      value: function getRoot() {
        if (!this._root) {
          this.setRoot({
            id: '__implicitroot',
            rows: [],
            cols: []
          });
        }

        return this._root;
      }

      /**
       * Add row to sheet.
       *
       * @param {Object} row - Row.
       */

    }, {
      key: 'addRow',
      value: function addRow(row, index) {
        var _this2 = this;

        var root = this.getRoot();

        if (root.cols.length != row.cells.length) {
          throw new Error('number of cells is not equal to number of cols');
        }

        if (typeof index === 'undefined') {
          index = root.rows.length;
        }

        addAtIndex(index, root.rows, row);
        row.root = root;

        this._elementRegistry.add(row);

        row.cells.forEach(function (cell, idx) {
          _this2._elementRegistry.add(cell);

          cell.row = row;
          cell.col = root.cols[idx];

          addAtIndex(index, root.cols[idx].cells, cell);
        });

        this._eventBus.fire('row.add', { row: row });

        return row;
      }

      /**
       * Remove row from sheet.
       *
       * @param {Object|string} row - Row or row ID.
       */

    }, {
      key: 'removeRow',
      value: function removeRow(row) {
        var _this3 = this;

        var root = this.getRoot();

        if (typeof row === 'string') {
          row = this._elementRegistry.get(row);
        }

        var index = root.rows.indexOf(row);

        if (index === -1) {
          return;
        }

        removeAtIndex(index, root.rows);
        row.root = undefined;

        this._elementRegistry.remove(row);

        row.cells.forEach(function (cell, idx) {
          _this3._elementRegistry.remove(cell);

          cell.col = undefined;

          removeAtIndex(index, root.cols[idx].cells);
        });

        this._eventBus.fire('row.remove', { row: row });
      }

      /**
       * Add col to sheet.
       *
       * @param {Object} col
       * @param {Number} [index]
       */

    }, {
      key: 'addCol',
      value: function addCol(col, index) {
        var _this4 = this;

        var root = this.getRoot();

        this._elementRegistry.add(col);

        if (root.rows.length != col.cells.length) {
          throw new Error('number of cells is not equal to number of rows');
        }

        if (typeof index === 'undefined') {
          index = root.cols.length;
        }

        addAtIndex(index, root.cols, col);
        col.root = root;

        col.cells.forEach(function (cell, idx) {
          _this4._elementRegistry.add(cell);

          cell.col = col;
          cell.row = root.rows[idx];

          addAtIndex(index, root.rows[idx].cells, cell);
        });

        this._eventBus.fire('col.add', { col: col });

        return col;
      }

      /**
       * Remove col from sheet.
       *
       * @param {Object|string} col - Col or col ID.
       */

    }, {
      key: 'removeCol',
      value: function removeCol(col) {
        var _this5 = this;

        var root = this.getRoot();

        if (typeof col === 'string') {
          col = this._elementRegistry.get(col);
        }

        var index = root.cols.indexOf(col);

        if (index === -1) {
          return;
        }

        removeAtIndex(index, root.cols);
        col.root = undefined;

        this._elementRegistry.remove(col);

        col.cells.forEach(function (cell, idx) {
          _this5._elementRegistry.remove(cell);

          cell.row = undefined;

          removeAtIndex(index, root.rows[idx].cells);
        });

        this._eventBus.fire('col.remove', { col: col });
      }
    }, {
      key: 'resized',
      value: function resized() {
        this._eventBus.fire('sheet.resized');
      }
    }]);

    return Sheet;
  }();

  Sheet.$inject = ['elementRegistry', 'eventBus'];

  // helpers /////////////

  /**
   * Insert value
   *
   * @param {number} index - Index to insert value at.
   * @param {Array} array - Array to insert value into.
   * @param {*} value - Value to insert.
   */
  function addAtIndex(index, array, value) {
    return array.splice(index, 0, value);
  }

  /**
   *
   * @param {number} index - Index to remove.
   * @param {Array} array - Array to remove from.
   */
  function removeAtIndex(index, array) {
    return array.splice(index, 1);
  }

  var core = {
    __depends__: [renderModule],
    __init__: ['elementFactory', 'sheet'],
    elementFactory: ['type', ElementFactory$2],
    elementRegistry: ['type', ElementRegistry$1],
    eventBus: ['type', EventBus],
    sheet: ['type', Sheet]
  };

  var _createClass$10 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _objectWithoutProperties$1(obj, keys) {
    var target = {};for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
    }return target;
  }

  function _classCallCheck$11(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Table = function () {
    function Table() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck$11(this, Table);

      var injector = options.injector;

      if (!injector) {
        var _init2 = this._init(options),
            modules = _init2.modules,
            config = _init2.config;

        injector = createInjector$1(config, modules);
      }

      this.get = injector.get;

      this.invoke = injector.invoke;

      this.get('eventBus').fire('table.init');
      this.get('eventBus').fire('diagram.init');
    }

    /**
     * Intialize table and return modules and config used for creation.
     *
     * @param  {Object} options
     *
     * @return {Object} { modules=[], config }
     */

    _createClass$10(Table, [{
      key: '_init',
      value: function _init(options) {
        var modules = options.modules,
            config = _objectWithoutProperties$1(options, ['modules']);

        return { modules: modules, config: config };
      }

      /**
       * Destroys the table. This results in removing the attachment from the container.
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        var eventBus = this.get('eventBus');

        eventBus.fire('table.destroy');
        eventBus.fire('diagram.destroy');
      }

      /**
       * Clears the table. Should be used to reset the state of any stateful services.
       */

    }, {
      key: 'clear',
      value: function clear() {
        var eventBus = this.get('eventBus');

        eventBus.fire('table.clear');
        eventBus.fire('diagram.clear');
      }
    }]);

    return Table;
  }();
  function bootstrap$1(bootstrapModules) {

    var modules = [],
        components = [];

    function hasModule(m) {
      return modules.indexOf(m) >= 0;
    }

    function addModule(m) {
      modules.push(m);
    }

    function visit(m) {
      if (hasModule(m)) {
        return;
      }

      (m.__depends__ || []).forEach(visit);

      if (hasModule(m)) {
        return;
      }

      addModule(m);

      (m.__init__ || []).forEach(function (c) {
        components.push(c);
      });
    }

    bootstrapModules.forEach(visit);

    var injector = new Injector(modules);

    components.forEach(function (c) {

      try {
        // eagerly resolve component (fn or string)
        injector[typeof c === 'string' ? 'get' : 'invoke'](c);
      } catch (e) {
        console.error('Failed to instantiate component');
        console.error(e.stack);

        throw e;
      }
    });

    return injector;
  }

  function createInjector$1(config, modules) {
    var bootstrapModules = [{
      config: ['value', config]
    }, core].concat(modules || []);

    return bootstrap$1(bootstrapModules);
  }

  function elementToString(element) {
    if (!element) {
      return '<null>';
    }

    var id = element.id ? ' id="' + element.id + '"' : '';

    return '<' + element.$type + id + ' />';
  }

  function TableTreeWalker(handler, options) {

    function visit(element, ctx, definitions) {

      var gfx = element.gfx;

      // avoid multiple rendering of elements
      if (gfx) {
        throw new Error('already rendered ' + elementToString(element));
      }

      // call handler
      return handler.element(element, ctx, definitions);
    }

    function visitTable(element) {
      return handler.table(element);
    }

    // Semantic handling //////////////////////

    function handleDecision(decision) {

      if (!decision.id) {
        decision.id = 'decision';
      }

      var table = decision.decisionTable;

      if (table) {

        if (!table.output) {
          throw new Error('missing output for ' + elementToString(table));
        }

        var ctx = visitTable(table);

        if (table.input) {
          handleClauses(table.input, ctx, table);
        }

        handleClauses(table.output, ctx, table);

        // if any input or output clauses (columns) were added
        // make sure that for each rule the according input/output entry is created
        handleRules(table.rule, ctx, table);
      } else {
        throw new Error('no table for ' + elementToString(decision));
      }
    }

    function handleClauses(clauses, context, definitions) {
      forEach(clauses, function (e) {
        visit(e, context, definitions);
      });
    }

    function handleRules(rules, context, definitions) {
      forEach(rules, function (e) {
        visit(e, context, definitions);

        handleEntry(e.inputEntry, e);

        handleEntry(e.outputEntry, e);
      });
    }

    function handleEntry(entry, context, definitions) {
      forEach(entry, function (e) {
        visit(e, context, definitions);
      });
    }

    // API //////////////////////

    return {
      handleDecision: handleDecision
    };
  }

  /**
   * Import the decision table into a table.
   *
   * Errors and warnings are reported through the specified callback.
   *
   * @param  {decisionTable} decisionTable instance of DecisionTable
   * @param  {ModdleElement} decision moddle element
   * @param  {Function} done
   *         the callback, invoked with (err, [ warning ]) once the import is done
   */
  function importDecision(decisionTable, decision, done) {
    var importer = decisionTable.get('tableImporter'),
        eventBus = decisionTable.get('eventBus'),
        sheet = decisionTable.get('sheet');

    var hasModeling = decisionTable.get('modeling', false);

    var error = void 0,
        warnings = [];

    function render(decision) {

      var visitor = {
        create: function create(type, parent, clause, rule) {
          return importer.create(type, parent, clause, rule);
        },
        table: function table(element) {
          return importer.add(element);
        },
        element: function element(_element, parentShape, definitions) {
          return importer.add(_element, parentShape, definitions);
        },
        error: function error(message, context) {
          warnings.push({ message: message, context: context });
        }
      };

      var walker = new TableTreeWalker(visitor, { canAddMissingEntries: hasModeling });

      // import
      walker.handleDecision(decision);
    }

    eventBus.fire('import.render.start', { decision: decision });

    try {
      render(decision);
    } catch (e) {
      error = e;
    }

    eventBus.fire('import.render.complete', {
      error: error,
      warnings: warnings
    });

    eventBus.fire('elements.changed', {
      elements: [sheet.getRoot()]
    });

    done(error, warnings);
  }

  function AnnotationHeader() {
    return createVNode(1, "th", "annotation header", createTextVNode("Annotation"), 2, {
      "rowspan": "3"
    });
  }

  var _typeof2$2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _typeof$12 = typeof Symbol === "function" && _typeof2$2(Symbol.iterator) === "symbol" ? function (obj) {
    return typeof obj === "undefined" ? "undefined" : _typeof2$2(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2$2(obj);
  };

  var _extends$3 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }return obj;
  }

  function _toConsumableArray$4(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function newSet() {
    return {
      elements: [],
      index: {}
    };
  }

  function add$2(set, element) {
    var elements = set.elements,
        index = set.index;

    if (index[element]) {
      return set;
    } else {
      return {
        elements: [].concat(_toConsumableArray$4(elements), [element]),
        index: _extends$3({}, index, _defineProperty({}, element, true))
      };
    }
  }

  function join(set, separator) {
    return set.elements.join(separator);
  }

  function classNames() {

    var set = newSet();

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    args.forEach(function (item) {
      var type = typeof item === 'undefined' ? 'undefined' : _typeof$12(item);

      if (type === 'string' && item.length > 0) {
        set = add$2(set, item);
      } else if (type === 'object' && item !== null) {

        Object.keys(item).forEach(function (key) {
          var value = item[key];

          if (value) {
            set = add$2(set, key);
          }
        });
      }
    });

    return join(set, ' ');
  }

  function _toConsumableArray$5(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function inject(component) {

    var Type = component.constructor;

    return injectType(Type, component);
  }

  function injectType(Type, component) {

    var annotation = Type.$inject;

    if (!annotation) {
      return;
    }

    var injector = component.context.injector;

    var setupFn = [].concat(_toConsumableArray$5(annotation), [function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      for (var idx in args) {
        var name = annotation[idx];
        var value = args[idx];

        component[name] = value;
      }
    }]);

    injector.invoke(setupFn);
  }

  /**
   * Composes a number of functions.
   *
   * All receive the the same arguments; the chain is interruped as soon
   * as one function returns a value.
   *
   * @param  {Object}    self
   * @param  {...Function} fns
   *
   * @return {Object}
   */
  function compose(self) {
    for (var _len = arguments.length, fns = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      fns[_key - 1] = arguments[_key];
    }

    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var result = void 0;

      fns.forEach(function (fn) {

        result = fn.call.apply(fn, [self].concat(args));

        if (typeof result !== 'undefined') {
          return false;
        }
      });

      return result;
    }.bind(self);
  }

  /**
   * A Component and injection aware mixin mechanism.
   *
   * @param {Component} component
   * @param {Object|Function} mixinDef
   */
  function mixin(component, mixinDef) {

    Object.keys(mixinDef).forEach(function (key) {

      if (key === '$inject' || key === '__init') {
        return;
      }

      var mixinFn = mixinDef[key];

      if (key === 'constructor') {
        mixinFn.call(component, component.props, component.context);
      }

      var componentFn = component[key];

      if (typeof componentFn !== 'undefined') {
        if (typeof componentFn !== 'function') {
          throw new Error('failed to mixin <' + key + '>: cannot combine with non-fn component value');
        }

        component[key] = compose(component, componentFn, mixinFn);
      } else {
        component[key] = mixinFn.bind(component);
      }
    });

    if ('$inject' in mixinDef) {
      injectType(mixinDef, component);
    }

    // call initializer
    if ('__init' in mixinDef) {
      mixinDef.__init.call(component, component.props, component.context);
    }
  }

  /**
   * A mixin to make an element _selection aware_.
   */
  var SelectionAware = {
    getSelectionClasses: function getSelectionClasses() {
      var _state = this.state,
          selected = _state.selected,
          selectedSecondary = _state.selectedSecondary,
          focussed = _state.focussed;

      return classNames({
        'selected': selected,
        'selected-secondary': selectedSecondary,
        'focussed': focussed
      });
    },
    selectionChanged: function selectionChanged(newSelection) {

      // newSelection = { selected, selectedSecondary, focussed }
      this.setState(newSelection);
    },
    componentWillUpdate: function componentWillUpdate(newProps) {
      if (newProps.elementId !== this.props.elementId) {
        this.updateSelectionSubscription(false);
      }
    },
    componentDidUpdate: function componentDidUpdate(oldProps) {

      if (oldProps.elementId !== this.props.elementId) {
        this.updateSelectionSubscription(true);
      }
    },
    componentDidMount: function componentDidMount() {
      this.updateSelectionSubscription(true);
    },
    componentWillUnmount: function componentWillUnmount() {
      this.updateSelectionSubscription(false);
    },
    updateSelectionSubscription: function updateSelectionSubscription(enable) {
      var elementId = this.props.elementId;

      if (!elementId) {
        return;
      }

      if (elementId) {
        this.eventBus[enable ? 'on' : 'off']('selection.' + elementId + '.changed', this.selectionChanged);
      }
    }
  };

  SelectionAware.$inject = ['eventBus'];

  var _typeof$13 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _extends$4 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass$11 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _objectWithoutProperties$2(obj, keys) {
    var target = {};for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
    }return target;
  }

  function _classCallCheck$12(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$3(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$13(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$3(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$13(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var BaseCell = function (_Component) {
    _inherits$3(BaseCell, _Component);

    function BaseCell(props, context) {
      _classCallCheck$12(this, BaseCell);

      var _this = _possibleConstructorReturn$3(this, (BaseCell.__proto__ || Object.getPrototypeOf(BaseCell)).call(this, props, context));

      mixin(_this, SelectionAware);

      inject(_this);
      return _this;
    }

    _createClass$11(BaseCell, [{
      key: 'getRenderProps',
      value: function getRenderProps() {
        var _props = this.props,
            className = _props.className,
            elementId = _props.elementId,
            coords = _props.coords,
            props = _objectWithoutProperties$2(_props, ['className', 'elementId', 'coords']);

        for (var _len = arguments.length, cls = Array(_len), _key = 0; _key < _len; _key++) {
          cls[_key] = arguments[_key];
        }

        var baseProps = {
          className: classNames.apply(undefined, cls.concat([this.getSelectionClasses(), className]))
        };

        if (elementId) {
          baseProps['data-element-id'] = elementId;
        }

        if (coords) {
          baseProps['data-coords'] = coords;
        }

        return _extends$4({}, baseProps, props);
      }
    }]);

    return BaseCell;
  }(Component);

  var _typeof$14 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _extends$5 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass$12 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$13(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$4(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$14(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$4(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$14(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var HeaderCell = function (_BaseCell) {
    _inherits$4(HeaderCell, _BaseCell);

    function HeaderCell(props, context) {
      _classCallCheck$13(this, HeaderCell);

      var _this = _possibleConstructorReturn$4(this, (HeaderCell.__proto__ || Object.getPrototypeOf(HeaderCell)).call(this, props, context));

      _this.state = {};
      return _this;
    }

    _createClass$12(HeaderCell, [{
      key: 'render',
      value: function render$$1() {
        var children = this.props.children;

        var props = this.getRenderProps('cell');

        return normalizeProps(createVNode(1, 'td', null, children, 0, _extends$5({}, props)));
      }
    }]);

    return HeaderCell;
  }(BaseCell);

  var _typeof$15 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$13 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$14(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$5(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$15(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$5(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$15(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var DiContainer = function (_Component) {
    _inherits$5(DiContainer, _Component);

    function DiContainer() {
      _classCallCheck$14(this, DiContainer);

      return _possibleConstructorReturn$5(this, (DiContainer.__proto__ || Object.getPrototypeOf(DiContainer)).apply(this, arguments));
    }

    _createClass$13(DiContainer, [{
      key: 'getChildContext',
      value: function getChildContext() {

        return {
          injector: this.props.injector
        };
      }
    }, {
      key: 'render',
      value: function render$$1() {
        return this.props.children;
      }
    }]);

    return DiContainer;
  }(Component);

  var _typeof$16 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _extends$6 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass$14 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$15(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$6(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$16(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$6(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$16(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var HeaderCell$1 = function (_BaseCell) {
    _inherits$6(HeaderCell, _BaseCell);

    function HeaderCell(props, context) {
      _classCallCheck$15(this, HeaderCell);

      var _this = _possibleConstructorReturn$6(this, (HeaderCell.__proto__ || Object.getPrototypeOf(HeaderCell)).call(this, props, context));

      _this.state = {};
      return _this;
    }

    _createClass$14(HeaderCell, [{
      key: 'render',
      value: function render$$1() {
        var children = this.props.children;

        var props = this.getRenderProps('cell', 'header-cell');

        return normalizeProps(createVNode(1, 'th', null, children, 0, _extends$6({}, props)));
      }
    }]);

    return HeaderCell;
  }(BaseCell);

  function AnnotationCell(props) {
    var row = props.row;
    var _row$businessObject = row.businessObject,
        id = _row$businessObject.id,
        description = _row$businessObject.description;

    return createComponentVNode(2, HeaderCell, {
      'className': 'annotation',
      'elementId': id + '__annotation',
      children: description || '-'
    });
  }

  function AnnotationsProvider(components) {

    components.onGetComponent('cell', function (_ref) {
      var cellType = _ref.cellType;

      if (cellType === 'after-label-cells') {
        return AnnotationHeader;
      } else if (cellType === 'after-rule-cells') {
        return AnnotationCell;
      }
    });
  }

  AnnotationsProvider.$inject = ['components'];

  var annotationsModule = {
    __init__: ['annotationsProvider'],
    annotationsProvider: ['type', AnnotationsProvider]
  };

  var _createClass$15 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _toConsumableArray$6(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function _classCallCheck$16(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function elementData$1(semantic, attrs) {
    return assign({
      id: semantic.id,
      type: semantic.$type,
      businessObject: semantic
    }, attrs);
  }

  var TableImporter = function () {
    function TableImporter(elementFactory, eventBus, sheet) {
      _classCallCheck$16(this, TableImporter);

      this._elementFactory = elementFactory;
      this._eventBus = eventBus;
      this._sheet = sheet;
    }

    /**
     * Add DMN element.
     */

    _createClass$15(TableImporter, [{
      key: 'add',
      value: function add(semantic) {
        var _this = this;

        var element = void 0;

        // decision table
        if (is(semantic, 'dmn:DecisionTable')) {
          element = this._elementFactory.createRoot(elementData$1(semantic));

          this._sheet.setRoot(element);
        }

        // input clause
        else if (is(semantic, 'dmn:InputClause')) {
            element = this._elementFactory.createCol(elementData$1(semantic));

            this._sheet.addCol(element);
          }

          // output clause
          else if (is(semantic, 'dmn:OutputClause')) {
              element = this._elementFactory.createCol(elementData$1(semantic));

              this._sheet.addCol(element);
            }

            // rule
            else if (is(semantic, 'dmn:DecisionRule')) {
                if (!semantic.inputEntry) {
                  semantic.inputEntry = [];
                }

                if (!semantic.outputEntry) {
                  semantic.outputEntry = [];
                }

                var cells = [].concat(_toConsumableArray$6(semantic.inputEntry), _toConsumableArray$6(semantic.outputEntry)).map(function (entry) {
                  return _this._elementFactory.createCell(elementData$1(entry));
                });

                element = this._elementFactory.createRow(assign(elementData$1(semantic), {
                  cells: cells
                }));

                this._sheet.addRow(element);
              }

        this._eventBus.fire('dmnElement.added', { element: element });

        return element;
      }
    }]);

    return TableImporter;
  }();

  TableImporter.$inject = ['elementFactory', 'eventBus', 'sheet'];

  var importModule = {
    tableImporter: ['type', TableImporter]
  };

  var coreModule = {
    __depends__: [importModule, renderModule]
  };

  var _extends$7 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  function _objectWithoutProperties$3(obj, keys) {
    var target = {};for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
    }return target;
  }

  /**
   * A simple slot extension, built upon the components service.
   *
   * @type {Object}
   */
  var ComponentWithSlots = {
    slotFill: function slotFill(slotProps, DefaultFill) {
      var type = slotProps.type,
          context = slotProps.context,
          props = _objectWithoutProperties$3(slotProps, ['type', 'context']);

      var Fill = this.components.getComponent(type, context) || DefaultFill;

      if (Fill) {
        return normalizeProps(createComponentVNode(2, Fill, _extends$7({}, context, props)));
      }

      return null;
    },
    slotFills: function slotFills(slotProps) {
      var type = slotProps.type,
          context = slotProps.context,
          props = _objectWithoutProperties$3(slotProps, ['type', 'context']);

      var fills = this.components.getComponents(type, context);

      return fills.map(function (Fill) {
        return normalizeProps(createComponentVNode(2, Fill, _extends$7({}, context, props)));
      });
    }
  };

  ComponentWithSlots.$inject = ['components'];

  var _typeof$17 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$16 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$17(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$7(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$17(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$7(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$17(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var DecisionTableHead = function (_Component) {
    _inherits$7(DecisionTableHead, _Component);

    function DecisionTableHead(props, context) {
      _classCallCheck$17(this, DecisionTableHead);

      var _this = _possibleConstructorReturn$7(this, (DecisionTableHead.__proto__ || Object.getPrototypeOf(DecisionTableHead)).call(this, props, context));

      _this.onElementsChanged = function () {
        _this.forceUpdate();
      };

      mixin(_this, ComponentWithSlots);

      _this._sheet = context.injector.get('sheet');

      _this._changeSupport = context.changeSupport;
      return _this;
    }

    _createClass$16(DecisionTableHead, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        var root = this._sheet.getRoot();

        this._changeSupport.onElementsChanged(root.id, this.onElementsChanged);
      }
    }, {
      key: 'componentWillUnmout',
      value: function componentWillUnmout() {
        var root = this._sheet.getRoot();

        this._changeSupport.offElementsChanged(root.id, this.onElementsChanged);
      }
    }, {
      key: 'render',
      value: function render$$1(props) {
        var _this2 = this;

        var root = this._sheet.getRoot();

        if (!is(root, 'dmn:DMNElement')) {
          return null;
        }

        var businessObject = getBusinessObject(root);

        var inputs = businessObject.input,
            outputs = businessObject.output;

        return createVNode(1, 'thead', null, [createVNode(1, 'tr', null, [this.slotFills({
          type: 'cell',
          context: { cellType: 'before-label-cells' }
        }), this.slotFill({
          type: 'cell',
          context: { cellType: 'input-label' }
        }, DefaultInputLabel), this.slotFill({
          type: 'cell',
          context: { cellType: 'output-label' }
        }, DefaultOutputLabel), this.slotFills({
          type: 'cell',
          context: { cellType: 'after-label-cells' }
        })], 0), createVNode(1, 'tr', null, [inputs && inputs.map(function (input) {
          return _this2.slotFill({
            type: 'cell',
            context: {
              cellType: 'input-header',
              input: input
            },
            key: input.id
          }, DefaultInputHeaderCell);
        }), outputs.map(function (output) {
          return _this2.slotFill({
            type: 'cell',
            context: {
              cellType: 'output-header',
              output: output
            },
            key: output.id
          }, DefaultOutputHeaderCell);
        })], 0), createVNode(1, 'tr', null, [inputs && inputs.map(function (input, index) {
          var inputExpression = input.inputExpression;

          return _this2.slotFill({
            type: 'cell',
            context: {
              cellType: 'input-header-type-ref',
              element: inputExpression
            },
            className: 'input-cell',
            key: input.id
          }, DefaultTypeRefCell);
        }), outputs.map(function (output) {

          return _this2.slotFill({
            type: 'cell',
            context: {
              cellType: 'output-header-type-ref',
              element: output
            },
            className: 'output-cell',
            key: output.id
          }, DefaultTypeRefCell);
        })], 0)], 4);
      }
    }]);

    return DecisionTableHead;
  }(Component);
  function DefaultInputHeaderCell(props) {
    var input = props.input,
        className = props.className;
    var label = input.label,
        inputExpression = input.inputExpression;

    var actualClassName = (className || '') + ' input-cell';

    return createVNode(1, 'th', actualClassName, label ? createVNode(1, 'span', 'input-label', label, 0, {
      'title': 'Input Label'
    }) : createVNode(1, 'span', 'input-expression', inputExpression.text || '-', 0, {
      'title': 'Input Expression'
    }), 0, {
      'data-col-id': input.id
    }, input.id);
  }

  var DefaultInputLabel = function (_Component2) {
    _inherits$7(DefaultInputLabel, _Component2);

    function DefaultInputLabel(props, context) {
      _classCallCheck$17(this, DefaultInputLabel);

      var _this3 = _possibleConstructorReturn$7(this, (DefaultInputLabel.__proto__ || Object.getPrototypeOf(DefaultInputLabel)).call(this, props, context));

      _this3._sheet = context.injector.get('sheet');
      return _this3;
    }

    _createClass$16(DefaultInputLabel, [{
      key: 'render',
      value: function render$$1() {

        var root = this._sheet.getRoot(),
            businessObject = root.businessObject;

        var inputs = businessObject.input;

        if (!inputs || !inputs.length) {
          return null;
        }

        var colspan = businessObject.input.length;

        return createVNode(1, 'th', 'input-cell inputs-label header', createTextVNode('Input'), 2, {
          'colspan': colspan
        });
      }
    }]);

    return DefaultInputLabel;
  }(Component);

  function DefaultOutputHeaderCell(props) {
    var output = props.output,
        className = props.className;
    var label = output.label,
        name = output.name;

    var actualClassName = (className || '') + ' output-cell';

    return createVNode(1, 'th', actualClassName, label ? createVNode(1, 'span', 'output-label', label, 0, {
      'title': 'Output Label'
    }) : createVNode(1, 'span', 'output-name', name || '-', 0, {
      'title': 'Output Name'
    }), 0, null, output.id);
  }

  var DefaultOutputLabel = function (_Component3) {
    _inherits$7(DefaultOutputLabel, _Component3);

    function DefaultOutputLabel(props, context) {
      _classCallCheck$17(this, DefaultOutputLabel);

      var _this4 = _possibleConstructorReturn$7(this, (DefaultOutputLabel.__proto__ || Object.getPrototypeOf(DefaultOutputLabel)).call(this, props, context));

      _this4._sheet = context.injector.get('sheet');
      return _this4;
    }

    _createClass$16(DefaultOutputLabel, [{
      key: 'render',
      value: function render$$1() {
        var root = this._sheet.getRoot(),
            businessObject = root.businessObject,
            colspan = businessObject.output.length;

        return createVNode(1, 'th', 'output-cell outputs-label header', createTextVNode('Output'), 2, {
          'colspan': colspan
        });
      }
    }]);

    return DefaultOutputLabel;
  }(Component);

  function DefaultTypeRefCell(props) {
    var className = props.className,
        element = props.element;

    var actualClassName = className + ' type-ref';

    return createVNode(1, 'th', actualClassName, element.typeRef, 0, {
      'title': 'Data Type'
    });
  }

  function DecisionTableHeadProvider(components) {
    components.onGetComponent('table.head', function () {
      return DecisionTableHead;
    });
  }

  DecisionTableHeadProvider.$inject = ['components'];

  var decisionTableHeadModule = {
    __init__: ['decisionTableHeadProvider'],
    decisionTableHeadProvider: ['type', DecisionTableHeadProvider]
  };

  var _typeof$18 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$17 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$18(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$8(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$18(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$8(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$18(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var DecisionTablePropertiesComponent = function (_Component) {
    _inherits$8(DecisionTablePropertiesComponent, _Component);

    function DecisionTablePropertiesComponent() {
      _classCallCheck$18(this, DecisionTablePropertiesComponent);

      return _possibleConstructorReturn$8(this, (DecisionTablePropertiesComponent.__proto__ || Object.getPrototypeOf(DecisionTablePropertiesComponent)).apply(this, arguments));
    }

    _createClass$17(DecisionTablePropertiesComponent, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        var injector = this.context.injector;

        this._sheet = injector.get('sheet');
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var root = this._sheet.getRoot();

        if (!is(root, 'dmn:DMNElement')) {
          return null;
        }

        var _root$businessObject$ = root.businessObject.$parent,
            id = _root$businessObject$.id,
            name = _root$businessObject$.name;

        return createVNode(1, 'header', 'decision-table-properties', [createVNode(1, 'h3', 'decision-table-name', name, 0, {
          'title': 'Decision Name'
        }), createVNode(1, 'h5', 'decision-table-id', id, 0, {
          'title': 'Decision Id'
        })], 4);
      }
    }]);

    return DecisionTablePropertiesComponent;
  }(Component);

  function _classCallCheck$19(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var DecisionTableProperties = function DecisionTableProperties(components) {
    _classCallCheck$19(this, DecisionTableProperties);

    components.onGetComponent('table.before', function () {
      return DecisionTablePropertiesComponent;
    });
  };

  DecisionTableProperties.$inject = ['components'];

  var decisionTablePropertiesModule = {
    __init__: ['decisionTableProperties'],
    decisionTableProperties: ['type', DecisionTableProperties]
  };

  var _typeof$19 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$18 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$20(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$9(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$19(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$9(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$19(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var DecisionRulesIndexCellComponent = function (_Component) {
    _inherits$9(DecisionRulesIndexCellComponent, _Component);

    function DecisionRulesIndexCellComponent() {
      _classCallCheck$20(this, DecisionRulesIndexCellComponent);

      return _possibleConstructorReturn$9(this, (DecisionRulesIndexCellComponent.__proto__ || Object.getPrototypeOf(DecisionRulesIndexCellComponent)).apply(this, arguments));
    }

    _createClass$18(DecisionRulesIndexCellComponent, [{
      key: 'render',
      value: function render$$1() {
        var _props = this.props,
            row = _props.row,
            rowIndex = _props.rowIndex;
        var components = this.context.components;

        var innerComponents = components.getComponents('cell-inner', {
          cellType: 'rule-index',
          row: row,
          rowIndex: rowIndex
        });

        return createVNode(1, 'td', 'rule-index', [innerComponents && innerComponents.map(function (InnerComponent) {
          return createComponentVNode(2, InnerComponent, {
            'row': row,
            'rowIndex': rowIndex
          });
        }), rowIndex + 1], 0, {
          'data-row-id': row.id
        });
      }
    }]);

    return DecisionRulesIndexCellComponent;
  }(Component);

  function _classCallCheck$21(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var DecisionRuleIndices = function DecisionRuleIndices(components) {
    _classCallCheck$21(this, DecisionRuleIndices);

    components.onGetComponent('cell', function (_ref) {
      var cellType = _ref.cellType;

      if (cellType === 'before-rule-cells') {
        return DecisionRulesIndexCellComponent;
      }
    });
  };

  DecisionRuleIndices.$inject = ['components'];

  var decisionRuleIndicesModule = {
    __init__: ['decisionRuleIndices'],
    decisionRuleIndices: ['type', DecisionRuleIndices]
  };

  var _typeof$20 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$19 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$22(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$10(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$20(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$10(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$20(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var DecisionRulesBodyComponent = function (_Component) {
    _inherits$10(DecisionRulesBodyComponent, _Component);

    function DecisionRulesBodyComponent() {
      _classCallCheck$22(this, DecisionRulesBodyComponent);

      return _possibleConstructorReturn$10(this, (DecisionRulesBodyComponent.__proto__ || Object.getPrototypeOf(DecisionRulesBodyComponent)).apply(this, arguments));
    }

    _createClass$19(DecisionRulesBodyComponent, [{
      key: 'render',
      value: function render$$1(_ref) {
        var rows = _ref.rows,
            cols = _ref.cols;
        var components = this.context.components;

        return createVNode(1, 'tbody', null, rows.map(function (row, rowIndex) {
          var RowComponent = components.getComponent('row', { rowType: 'rule' });

          return RowComponent && createComponentVNode(2, RowComponent, {
            'row': row,
            'rowIndex': rowIndex,
            'cols': cols
          }, row.id);
        }), 0);
      }
    }]);

    return DecisionRulesBodyComponent;
  }(Component);

  var _typeof$21 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$20 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$23(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$11(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$21(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$11(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$21(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var DecisionRulesRowComponent = function (_Component) {
    _inherits$11(DecisionRulesRowComponent, _Component);

    function DecisionRulesRowComponent(props, context) {
      _classCallCheck$23(this, DecisionRulesRowComponent);

      var _this = _possibleConstructorReturn$11(this, (DecisionRulesRowComponent.__proto__ || Object.getPrototypeOf(DecisionRulesRowComponent)).call(this, props, context));

      mixin(_this, ComponentWithSlots);
      return _this;
    }

    _createClass$20(DecisionRulesRowComponent, [{
      key: 'render',
      value: function render$$1() {
        var _this2 = this;

        var _props = this.props,
            row = _props.row,
            rowIndex = _props.rowIndex,
            cols = _props.cols;
        var cells = row.cells;

        return createVNode(1, 'tr', null, [this.slotFills({
          type: 'cell',
          context: {
            cellType: 'before-rule-cells',
            row: row,
            rowIndex: rowIndex
          }
        }), cells.map(function (cell, colIndex) {
          return _this2.slotFill({
            type: 'cell',
            context: {
              cellType: 'rule',
              cell: cell,
              rowIndex: rowIndex,
              colIndex: colIndex
            },
            key: cell.id,
            row: row,
            col: cols[colIndex]
          });
        }), this.slotFills({
          type: 'cell',
          context: {
            cellType: 'after-rule-cells',
            row: row,
            rowIndex: rowIndex
          }
        })], 0);
      }
    }]);

    return DecisionRulesRowComponent;
  }(Component);

  var _typeof$22 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$21 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$24(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$12(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$22(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$12(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$22(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var DecisionRulesCellComponent = function (_Component) {
    _inherits$12(DecisionRulesCellComponent, _Component);

    function DecisionRulesCellComponent() {
      _classCallCheck$24(this, DecisionRulesCellComponent);

      return _possibleConstructorReturn$12(this, (DecisionRulesCellComponent.__proto__ || Object.getPrototypeOf(DecisionRulesCellComponent)).apply(this, arguments));
    }

    _createClass$21(DecisionRulesCellComponent, [{
      key: 'render',
      value: function render$$1() {
        var _props = this.props,
            cell = _props.cell,
            row = _props.row,
            col = _props.col;

        if (is(cell, 'dmn:UnaryTests')) {
          return createComponentVNode(2, HeaderCell, {
            'className': 'input-cell',
            'elementId': cell.id,
            'data-row-id': row.id,
            'data-col-id': col.id,
            children: cell.businessObject.text
          });
        } else {
          return createComponentVNode(2, HeaderCell, {
            'className': 'output-cell',
            'elementId': cell.id,
            'data-row-id': row.id,
            'data-col-id': col.id,
            children: cell.businessObject.text
          });
        }
      }
    }]);

    return DecisionRulesCellComponent;
  }(Component);

  function _classCallCheck$25(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Rules$3 = function Rules(components) {
    _classCallCheck$25(this, Rules);

    components.onGetComponent('table.body', function () {
      return DecisionRulesBodyComponent;
    });

    components.onGetComponent('row', function (_ref) {
      var rowType = _ref.rowType;

      if (rowType === 'rule') {
        return DecisionRulesRowComponent;
      }
    });

    components.onGetComponent('cell', function (_ref2) {
      var cellType = _ref2.cellType;

      if (cellType === 'rule') {
        return DecisionRulesCellComponent;
      }
    });
  };

  Rules$3.$inject = ['components'];

  var Rules$4 = {
    __init__: ['decisionRules'],
    decisionRules: ['type', Rules$3]
  };

  var _typeof$23 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$22 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$26(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$13(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$23(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$13(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$23(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var HitPolicyCell = function (_Component) {
    _inherits$13(HitPolicyCell, _Component);

    function HitPolicyCell() {
      _classCallCheck$26(this, HitPolicyCell);

      return _possibleConstructorReturn$13(this, (HitPolicyCell.__proto__ || Object.getPrototypeOf(HitPolicyCell)).apply(this, arguments));
    }

    _createClass$22(HitPolicyCell, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        var injector = this.context.injector;

        this._sheet = injector.get('sheet');
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var root = this._sheet.getRoot(),
            businessObject = root.businessObject,
            hitPolicy = businessObject.hitPolicy,
            hitPolicyLabel = hitPolicy.charAt(0),
            aggregation = businessObject.aggregation;

        var aggregationLabel = getAggregationLabel(aggregation);

        return createVNode(1, 'th', 'hit-policy header', [hitPolicyLabel, aggregationLabel], 0, {
          'rowspan': '3',
          'title': 'Hit Policy = ' + hitPolicy
        });
      }
    }]);

    return HitPolicyCell;
  }(Component);
  function getAggregationLabel(aggregation) {
    switch (aggregation) {
      case 'SUM':
        return '+';
      case 'MIN':
        return '<';
      case 'MAX':
        return '>';
      case 'COUNT':
        return '#';
      default:
        return '';
    }
  }

  function HitPolicyProvider(components) {
    components.onGetComponent('cell', function (_ref) {
      var cellType = _ref.cellType;

      if (cellType === 'before-label-cells') {
        return HitPolicyCell;
      }
    });
  }

  HitPolicyProvider.$inject = ['components'];

  var hitPolicyModule = {
    __init__: ['hitPolicyProvider'],
    hitPolicyProvider: ['type', HitPolicyProvider]
  };

  var _typeof$24 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$23 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$27(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$14(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$24(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$14(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$24(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ViewDrdComponent = function (_Component) {
    _inherits$14(ViewDrdComponent, _Component);

    function ViewDrdComponent(props, context) {
      _classCallCheck$27(this, ViewDrdComponent);

      var _this = _possibleConstructorReturn$14(this, (ViewDrdComponent.__proto__ || Object.getPrototypeOf(ViewDrdComponent)).call(this, props, context));

      _this.onClick = function () {
        _this._eventBus.fire('showDrd');
      };

      var injector = context.injector;

      _this._eventBus = injector.get('eventBus');
      return _this;
    }

    _createClass$23(ViewDrdComponent, [{
      key: 'render',
      value: function render$$1() {
        var _this2 = this;

        return createVNode(1, 'div', 'view-drd', createVNode(1, 'button', 'view-drd-button', createTextVNode('View DRD'), 2, {
          'onClick': this.onClick
        }), 2, null, null, function (node) {
          return _this2.node = node;
        });
      }
    }]);

    return ViewDrdComponent;
  }(Component);

  var _createClass$24 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$28(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var ViewDrd = function () {
    function ViewDrd(components, eventBus, injector, sheet) {
      var _this = this;

      _classCallCheck$28(this, ViewDrd);

      this._injector = injector;
      this._sheet = sheet;

      components.onGetComponent('table.before', function () {
        if (_this.canViewDrd()) {
          return ViewDrdComponent;
        }
      });

      eventBus.on('showDrd', function () {
        var parent = injector.get('_parent', false);

        var root = sheet.getRoot();

        var definitions = getDefinitions(root);

        if (!definitions) {
          return;
        }

        // open definitions
        var view = parent.getView(definitions);

        parent.open(view);
      });
    }

    _createClass$24(ViewDrd, [{
      key: 'canViewDrd',
      value: function canViewDrd() {
        var parent = this._injector.get('_parent', false);

        if (!parent) {
          return false;
        }

        var root = this._sheet.getRoot();

        var definitions = getDefinitions(root);

        return !!parent.getView(definitions);
      }
    }]);

    return ViewDrd;
  }();

  ViewDrd.$inject = ['components', 'eventBus', 'injector', 'sheet'];

  // helpers //////////////////////

  function getDefinitions(root) {
    var businessObject = root.businessObject;

    // root might not have business object

    if (!businessObject) {
      return;
    }

    var decision = businessObject.$parent;

    var definitions = decision.$parent;

    return definitions;
  }

  var viewDrdModule = {
    __init__: ['viewDrd'],
    viewDrd: ['type', ViewDrd]
  };

  var _typeof$25 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$25 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$29(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$15(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$25(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$15(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$25(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  // eslint-disable-next-line
  var logo = 'iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAMAAADypuvZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADBQTFRFiMte9PrwldFwfcZPqtqN0+zEyOe1XLgjvuKncsJAZ70y6fXh3vDT////UrQV////G2zN+AAAABB0Uk5T////////////////////AOAjXRkAAAHDSURBVHjavJZJkoUgDEBJmAX8979tM8u3E6x20VlYJfFFMoL4vBDxATxZcakIOJTWSmxvKWVIkJ8jHvlRv1F2LFrVISCZI+tCtQx+XfewgVTfyY3plPiQEAzI3zWy+kR6NBhFBYeBuscJLOUuA2WVLpCjVIaFzrNQZArxAZKUQm6gsj37L9Cb7dnIBUKxENaaMJQqMpDXvSL+ktxdGRm2IsKgJGGPg7atwUG5CcFUEuSv+CwQqizTrvDTNXdMU2bMiDWZd8d7QIySWVRsb2vBBioxOFt4OinPBapL+neAb5KL5IJ8szOza2/DYoipUCx+CjO0Bpsv0V6mktNZ+k8rlABlWG0FrOpKYVo8DT3dBeLEjUBAj7moDogVii7nSS9QzZnFcOVBp1g2PyBQ3Vr5aIapN91VJy33HTJLC1iX2FY6F8gRdaAeIEfVONgtFCzZTmoLEdOjBDfsIOA6128gw3eu1shAajdZNAORxuQDJN5A5PbEG6gNIu24QJD5iNyRMZIr6bsHbCtCU/OaOaSvgkUyDMdDa1BXGf5HJ1To+/Ym6mCKT02Y+/Sa126ZKyd3jxhzpc1r8zVL6YM1Qy/kR4ABAFJ6iQUnivhAAAAAAElFTkSuQmCC';

  var PoweredByLogoComponent = function (_Component) {
    _inherits$15(PoweredByLogoComponent, _Component);

    function PoweredByLogoComponent(props, context) {
      _classCallCheck$29(this, PoweredByLogoComponent);

      var _this = _possibleConstructorReturn$15(this, (PoweredByLogoComponent.__proto__ || Object.getPrototypeOf(PoweredByLogoComponent)).call(this, props, context));

      _this.onClick = function () {
        _this._eventBus.fire('poweredBy.show');
      };

      var injector = context.injector;

      _this._eventBus = injector.get('eventBus');
      return _this;
    }

    _createClass$25(PoweredByLogoComponent, [{
      key: 'render',
      value: function render$$1() {
        var _this2 = this;

        return createVNode(1, 'div', 'powered-by-logo', createVNode(1, 'img', 'logo', null, 1, {
          'src': 'data:image/png;base64,' + logo
        }), 2, {
          'onClick': this.onClick,
          'title': 'Powered by bpmn.io'
        }, null, function (node) {
          return _this2.node = node;
        });
      }
    }]);

    return PoweredByLogoComponent;
  }(Component);

  var _typeof$26 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$26 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$30(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$16(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$26(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$16(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$26(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  // eslint-disable-next-line
  var logo$1 = 'iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAMAAADypuvZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADBQTFRFiMte9PrwldFwfcZPqtqN0+zEyOe1XLgjvuKncsJAZ70y6fXh3vDT////UrQV////G2zN+AAAABB0Uk5T////////////////////AOAjXRkAAAHDSURBVHjavJZJkoUgDEBJmAX8979tM8u3E6x20VlYJfFFMoL4vBDxATxZcakIOJTWSmxvKWVIkJ8jHvlRv1F2LFrVISCZI+tCtQx+XfewgVTfyY3plPiQEAzI3zWy+kR6NBhFBYeBuscJLOUuA2WVLpCjVIaFzrNQZArxAZKUQm6gsj37L9Cb7dnIBUKxENaaMJQqMpDXvSL+ktxdGRm2IsKgJGGPg7atwUG5CcFUEuSv+CwQqizTrvDTNXdMU2bMiDWZd8d7QIySWVRsb2vBBioxOFt4OinPBapL+neAb5KL5IJ8szOza2/DYoipUCx+CjO0Bpsv0V6mktNZ+k8rlABlWG0FrOpKYVo8DT3dBeLEjUBAj7moDogVii7nSS9QzZnFcOVBp1g2PyBQ3Vr5aIapN91VJy33HTJLC1iX2FY6F8gRdaAeIEfVONgtFCzZTmoLEdOjBDfsIOA6128gw3eu1shAajdZNAORxuQDJN5A5PbEG6gNIu24QJD5iNyRMZIr6bsHbCtCU/OaOaSvgkUyDMdDa1BXGf5HJ1To+/Ym6mCKT02Y+/Sa126ZKyd3jxhzpc1r8zVL6YM1Qy/kR4ABAFJ6iQUnivhAAAAAAElFTkSuQmCC';

  var PoweredByOverlayComponent = function (_Component) {
    _inherits$16(PoweredByOverlayComponent, _Component);

    function PoweredByOverlayComponent(props) {
      _classCallCheck$30(this, PoweredByOverlayComponent);

      var _this = _possibleConstructorReturn$16(this, (PoweredByOverlayComponent.__proto__ || Object.getPrototypeOf(PoweredByOverlayComponent)).call(this, props));

      _this.state = {
        show: false
      };

      _this.onClick = _this.onClick.bind(_this);
      _this.onShow = _this.onShow.bind(_this);
      return _this;
    }

    _createClass$26(PoweredByOverlayComponent, [{
      key: 'onClick',
      value: function onClick() {
        this.setState({
          show: false
        });
      }
    }, {
      key: 'onShow',
      value: function onShow() {
        this.setState({
          show: true
        });
      }
    }, {
      key: 'componentWillMount',
      value: function componentWillMount() {
        var eventBus = this._eventBus = this.context.injector.get('eventBus');

        eventBus.on('poweredBy.show', this.onShow);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this._eventBus.off('poweredBy.show', this.onShow);
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var show = this.state.show;

        return show && createVNode(1, 'div', 'powered-by-overlay', createVNode(1, 'div', 'powered-by-overlay-content', [createVNode(1, 'div', null, createVNode(1, 'img', 'logo', null, 1, {
          'src': 'data:image/png;base64,' + logo$1
        }), 2), createVNode(1, 'div', null, [createTextVNode('Web-based tooling for BPMN, DMN and CMMN diagrams powered by '), createVNode(1, 'a', null, createTextVNode('bpmn.io'), 2, {
          'href': 'http://bpmn.io',
          'target': '_blank'
        }), createTextVNode('.')], 4)], 4, {
          'onClick': function onClick(e) {
            return e.stopPropagation();
          }
        }), 2, {
          'onClick': this.onClick
        });
      }
    }]);

    return PoweredByOverlayComponent;
  }(Component);

  function _classCallCheck$31(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var PoweredBy = function PoweredBy(components, eventBus) {
    _classCallCheck$31(this, PoweredBy);

    components.onGetComponent('table.before', function () {
      return PoweredByLogoComponent;
    });

    components.onGetComponent('table.before', function () {
      return PoweredByOverlayComponent;
    });
  };

  PoweredBy.$inject = ['components', 'eventBus'];

  var PoweredByModule = {
    __init__: ['poweredBy'],
    poweredBy: ['type', PoweredBy]
  };

  var _typeof$27 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$27 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _get$1 = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;if (getter === undefined) {
        return undefined;
      }return getter.call(receiver);
    }
  };

  function _toConsumableArray$7(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function _objectWithoutProperties$4(obj, keys$$1) {
    var target = {};for (var i in obj) {
      if (keys$$1.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
    }return target;
  }

  function _classCallCheck$32(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$17(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$27(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$17(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$27(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var Viewer$1 = function (_Table) {
    _inherits$17(Viewer, _Table);

    function Viewer() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck$32(this, Viewer);

      var container = Viewer._createContainer();

      var _this = _possibleConstructorReturn$17(this, (Viewer.__proto__ || Object.getPrototypeOf(Viewer)).call(this, assign(options, {
        renderer: {
          container: container
        }
      })));

      _this._container = container;
      return _this;
    }

    _createClass$27(Viewer, [{
      key: 'open',
      value: function open(decision, done) {

        var err;

        // use try/catch to not swallow synchronous exceptions
        // that may be raised during model parsing
        try {

          if (this._decision) {
            // clear existing rendered diagram
            this.clear();
          }

          // update decision
          this._decision = decision;

          // perform import
          return importDecision(this, decision, done);
        } catch (e) {
          err = e;
        }

        // handle synchronously thrown exception
        return done(err);
      }

      /**
       * Initialize the table, returning { modules: [], config }.
       *
       * @param  {Object} options
       *
       * @return {Object} init config
       */

    }, {
      key: '_init',
      value: function _init(options) {
        var modules = options.modules,
            additionalModules = options.additionalModules,
            config = _objectWithoutProperties$4(options, ['modules', 'additionalModules']);

        var baseModules = modules || this.getModules();
        var extraModules = additionalModules || [];
        var staticModules = [{
          decisionTable: ['value', this]
        }];

        var allModules = [PoweredByModule].concat(_toConsumableArray$7(baseModules), _toConsumableArray$7(extraModules), staticModules);

        return {
          modules: allModules,
          config: config
        };
      }

      /**
       * Register an event listener
       *
       * Remove a previously added listener via {@link #off(event, callback)}.
       *
       * @param {String} event
       * @param {Number} [priority]
       * @param {Function} callback
       * @param {Object} [that]
       */

    }, {
      key: 'on',
      value: function on(event, priority, callback, target) {
        return this.get('eventBus').on(event, priority, callback, target);
      }

      /**
       * De-register an event listener
       *
       * @param {String} event
       * @param {Function} callback
       */

    }, {
      key: 'off',
      value: function off(event, callback) {
        this.get('eventBus').off(event, callback);
      }

      /**
       * Emit an event on the underlying {@link EventBus}
       *
       * @param  {String} type
       * @param  {Object} event
       *
       * @return {Object} event processing result (if any)
       */

    }, {
      key: '_emit',
      value: function _emit(type, event) {
        return this.get('eventBus').fire(type, event);
      }

      /**
       * Attach viewer to given parent node.
       *
       * @param  {Element} parentNode
       */

    }, {
      key: 'attachTo',
      value: function attachTo(parentNode) {

        if (!parentNode) {
          throw new Error('parentNode required');
        }

        // ensure we detach from the
        // previous, old parent
        this.detach();

        var container = this._container;

        parentNode.appendChild(container);

        this._emit('attach', {});
      }

      /**
       * Detach viewer from parent node, if attached.
       */

    }, {
      key: 'detach',
      value: function detach() {

        var container = this._container,
            parentNode = container.parentNode;

        if (!parentNode) {
          return;
        }

        this._emit('detach', {});

        remove(container);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        _get$1(Viewer.prototype.__proto__ || Object.getPrototypeOf(Viewer.prototype), 'destroy', this).call(this);

        this.detach();
      }
    }, {
      key: 'getModules',
      value: function getModules() {
        return Viewer._getModules();
      }
    }], [{
      key: '_getModules',
      value: function _getModules() {
        return [annotationsModule, coreModule, decisionTableHeadModule, decisionTablePropertiesModule, decisionRuleIndicesModule, Rules$4, hitPolicyModule, viewDrdModule];
      }
    }, {
      key: '_createContainer',
      value: function _createContainer() {
        return domify('<div class="dmn-decision-table-container"></div>');
      }
    }]);

    return Viewer;
  }(Table);

  var _typeof$28 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$28 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$33(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$18(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$28(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$18(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$28(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var AddRuleFootComponent = function (_Component) {
    _inherits$18(AddRuleFootComponent, _Component);

    function AddRuleFootComponent(props, context) {
      _classCallCheck$33(this, AddRuleFootComponent);

      var _this = _possibleConstructorReturn$18(this, (AddRuleFootComponent.__proto__ || Object.getPrototypeOf(AddRuleFootComponent)).call(this, props, context));

      _this.handleClick = function (e) {
        e.stopPropagation();

        _this.addRule();
      };

      inject(_this);

      _this.addRule = _this.addRule.bind(_this);
      return _this;
    }

    _createClass$28(AddRuleFootComponent, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        this._eventBus = this.context.injector.get('eventBus');
      }
    }, {
      key: 'addRule',
      value: function addRule() {
        this._eventBus.fire('addRule');
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var cols = this.props.cols;

        var cells = [createVNode(1, 'td', 'add-rule-add', createVNode(1, 'span', 'dmn-icon-plus action-icon', null, 1, {
          'title': 'Add Rule'
        }), 2)];

        var _sheet$getRoot = this.sheet.getRoot(),
            businessObject = _sheet$getRoot.businessObject;

        if (!businessObject.input || !businessObject.input.length) {
          cells.push(createVNode(1, 'td', 'input-cell', createTextVNode('-'), 2));
        }

        for (var i = 0; i < cols.length + 1; i++) {
          var className = 'add-rule';

          var _businessObject = cols[i] && cols[i].businessObject;

          if (_businessObject) {
            if (_businessObject.$instanceOf('dmn:InputClause')) {
              className += ' input-cell';
            }

            if (_businessObject.$instanceOf('dmn:OutputClause')) {
              className += ' output-cell';
            }
          }

          cells.push(createVNode(1, 'td', className, createTextVNode('-'), 2));
        }

        return createVNode(1, 'tfoot', 'actionable add-rule', createVNode(1, 'tr', null, cells, 0), 2, {
          'onClick': this.handleClick
        });
      }
    }]);

    return AddRuleFootComponent;
  }(Component);

  AddRuleFootComponent.$inject = ['sheet'];

  function _classCallCheck$34(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var AddRule = function AddRule(components, editorActions, eventBus) {
    _classCallCheck$34(this, AddRule);

    components.onGetComponent('table.foot', function () {
      return AddRuleFootComponent;
    });

    eventBus.on('addRule', function () {
      editorActions.trigger('addRule');
    });
  };

  AddRule.$inject = ['components', 'editorActions', 'eventBus'];

  var _createClass$29 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$35(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * Allows selecting a table cell. Selected cell will be highlighted.
   */

  var Selection$1 = function () {
    function Selection(elementRegistry, eventBus, renderer) {
      var _this = this;

      _classCallCheck$35(this, Selection);

      this._elementRegistry = elementRegistry;
      this._eventBus = eventBus;
      this._renderer = renderer;

      this._selection = undefined;

      eventBus.on('diagram.clear', function () {
        _this._selection = undefined;
      });
    }

    /**
     * Select a table cell.
     *
     * @param {Object|String} element - Element or element ID.
     */

    _createClass$29(Selection, [{
      key: 'select',
      value: function select(element) {

        if (isString(element)) {
          element = this._elementRegistry.get(element);
        }

        var oldSelection = this._selection;

        // don't re-select already selected *Ggg*
        if (oldSelection === element) {
          return;
        }

        this._selection = element;

        this._eventBus.fire('selection.changed', {
          oldSelection: oldSelection,
          selection: element
        });
      }

      /**
       * Deselect a table cell.
       */

    }, {
      key: 'deselect',
      value: function deselect() {

        var oldSelection = this._selection;

        this._selection = undefined;

        this._eventBus.fire('selection.changed', {
          oldSelection: oldSelection,
          selection: this._selection
        });
      }

      /**
       * Get the selected cell.
       */

    }, {
      key: 'get',
      value: function get() {
        return this._selection;
      }

      /**
       * Check if a cell is selected.
       */

    }, {
      key: 'hasSelection',
      value: function hasSelection() {
        return !!this._selection;
      }
    }]);

    return Selection;
  }();

  Selection$1.$inject = ['elementRegistry', 'eventBus', 'renderer'];

  function _classCallCheck$36(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * Selects table cells on on left & right click.
   */
  var SelectionBehavior$1 = function SelectionBehavior(elementRegistry, eventBus, renderer, selection) {
    _classCallCheck$36(this, SelectionBehavior);

    this._elementRegistry = elementRegistry;
    this._renderer = renderer;
    this._selection = selection;

    eventBus.on(['cell.click', 'cell.contextmenu'], function (_ref) {
      var id = _ref.id;

      var element = elementRegistry.get(id);

      if (!element) {
        return;
      }

      selection.select(element);
    });

    eventBus.on('row.remove', function (_ref2) {
      var row = _ref2.row;

      var currentSelection = selection.get();

      if (!currentSelection) {
        return;
      }

      if (row === currentSelection.row) {
        selection.deselect();
      }
    });

    eventBus.on('col.remove', function (_ref3) {
      var col = _ref3.col;

      var currentSelection = selection.get();

      if (!currentSelection) {
        return;
      }

      if (col === currentSelection.col) {
        selection.deselect();
      }
    });
  };

  SelectionBehavior$1.$inject = ['elementRegistry', 'eventBus', 'renderer', 'selection'];

  var Selection$2 = {
    __init__: ['selection', 'selectionBehavior'],
    selection: ['type', Selection$1],
    selectionBehavior: ['type', SelectionBehavior$1]
  };

  var _createClass$30 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$37(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var EVENTS = ['click', 'dblclick', 'contextmenu', 'mousedown', 'mouseup', 'mouseenter', 'mouseleave', 'mouseout', 'mouseover', 'mousemove', 'focusin', 'focusout', 'drag', 'dragstart', 'dragend', 'dragover', 'dragenter', 'dragleave', 'drop'];

  /**
   * Provides interaction events on the table.
   *
   * @param {RenderConfig} config
   * @param {EventBus} eventBus
   */

  var InteractionEvents$1 = function () {
    function InteractionEvents(config, eventBus) {
      var _this = this;

      _classCallCheck$37(this, InteractionEvents);

      this._handleEvent = function (event) {
        var target = event.target,
            type = event.type;

        var node = findClosestCell(target);

        if (!node) {
          return;
        }

        var elementId = node.getAttribute('data-element-id');

        if (elementId) {
          var e = _this._eventBus.createEvent({
            id: elementId,
            event: event,
            node: node,
            target: node
          });

          _this._eventBus.fire('cell.' + type, e);

          if (e.defaultPrevented) {
            event.preventDefault();
          }

          if (e.cancelBubble) {
            event.stopPropagation();
          }
        }
      };

      this._eventBus = eventBus;
      this._container = config.container;

      eventBus.on('table.init', function () {
        _this._addEventListeners(EVENTS);
      });

      eventBus.on('table.destroy', function () {
        _this._removeEventListeners(EVENTS);
      });
    }

    _createClass$30(InteractionEvents, [{
      key: '_addEventListeners',
      value: function _addEventListeners(events) {
        var _this2 = this;

        var container = this._container;

        events.forEach(function (event) {
          container.addEventListener(event, _this2._handleEvent);
        });
      }
    }, {
      key: '_removeEventListeners',
      value: function _removeEventListeners(events) {
        var _this3 = this;

        var container = this._container;

        events.forEach(function (event) {
          container.removeEventListener(event, _this3._handleEvent);
        });
      }
    }]);

    return InteractionEvents;
  }();

  InteractionEvents$1.$inject = ['config.renderer', 'eventBus'];

  // helpers /////////////

  function findClosestCell(element) {
    return closest(element, '[data-element-id]', true);
  }

  var InteractionModule = {
    __init__: ['interactionEvents'],
    interactionEvents: ['type', InteractionEvents$1]
  };

  var _typeof$29 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  /**
   * Expose `xor`
   */

  var componentXor = xor;

  /**
   * XOR utility
   *
   * T T F
   * T F T
   * F T T
   * F F F
   *
   * @param {Boolean} a
   * @param {Boolean} b
   * @return {Boolean}
   */

  function xor(a, b) {
    return a ^ b;
  }

  /**
   * Global Names
   */

  var globals = /\b(Array|Date|Object|Math|JSON)\b/g;

  /**
   * Return immediate identifiers parsed from `str`.
   *
   * @param {String} str
   * @param {String|Function} map function or prefix
   * @return {Array}
   * @api public
   */

  var componentProps = function componentProps(str, fn) {
    var p = unique(props(str));
    if (fn && 'string' == typeof fn) fn = prefixed(fn);
    if (fn) return map$2(str, p, fn);
    return p;
  };

  /**
   * Return immediate identifiers in `str`.
   *
   * @param {String} str
   * @return {Array}
   * @api private
   */

  function props(str) {
    return str.replace(/\.\w+|\w+ *\(|"[^"]*"|'[^']*'|\/([^/]+)\//g, '').replace(globals, '').match(/[a-zA-Z_]\w*/g) || [];
  }

  /**
   * Return `str` with `props` mapped with `fn`.
   *
   * @param {String} str
   * @param {Array} props
   * @param {Function} fn
   * @return {String}
   * @api private
   */

  function map$2(str, props, fn) {
    var re = /\.\w+|\w+ *\(|"[^"]*"|'[^']*'|\/([^/]+)\/|[a-zA-Z_]\w*/g;
    return str.replace(re, function (_) {
      if ('(' == _[_.length - 1]) return fn(_);
      if (!~props.indexOf(_)) return _;
      return fn(_);
    });
  }

  /**
   * Return unique array.
   *
   * @param {Array} arr
   * @return {Array}
   * @api private
   */

  function unique(arr) {
    var ret = [];

    for (var i = 0; i < arr.length; i++) {
      if (~ret.indexOf(arr[i])) continue;
      ret.push(arr[i]);
    }

    return ret;
  }

  /**
   * Map with prefix `str`.
   */

  function prefixed(str) {
    return function (_) {
      return str + _;
    };
  }

  /**
   * Module Dependencies
   */

  /**
   * Export `Iterator`
   */

  var domIterator = Iterator;

  /**
   * Initialize `Iterator`
   *
   * @param {Node} node
   * @param {Node} root
   * @return {Iterator} self
   * @api public
   */

  function Iterator(node, root) {
    if (!(this instanceof Iterator)) return new Iterator(node, root);
    this.node = this.start = this.peeked = node;
    this.root = root;
    this.closingTag = false;
    this._revisit = true;
    this._selects = [];
    this._rejects = [];

    if (node && this.higher(node)) {
      throw new Error('root must be a parent or ancestor to node');
    }
  }

  /**
   * Reset the Iterator
   *
   * @param {Node} node (optional)
   * @return {Iterator} self
   * @api public
   */

  Iterator.prototype.reset = function (node) {
    this.node = node || this.start;
    return this;
  };

  /**
   * Revisit element nodes. Defaults to `true`
   */

  Iterator.prototype.revisit = function (revisit) {
    this._revisit = undefined == revisit ? true : revisit;
    return this;
  };

  /**
   * Jump to the opening tag
   */

  Iterator.prototype.opening = function () {
    if (1 == this.node.nodeType) this.closingTag = false;
    return this;
  };

  /**
   * Jump to the closing tag
   */

  Iterator.prototype.atOpening = function () {
    return !this.closingTag;
  };

  /**
   * Jump to the closing tag
   */

  Iterator.prototype.closing = function () {
    if (1 == this.node.nodeType) this.closingTag = true;
    return this;
  };

  /**
   * Jump to the closing tag
   */

  Iterator.prototype.atClosing = function () {
    return this.closingTag;
  };

  /**
   * Next node
   *
   * @param {Number} type
   * @return {Node|null}
   * @api public
   */

  Iterator.prototype.next = traverse('nextSibling', 'firstChild');

  /**
   * Previous node
   *
   * @param {Number} type
   * @return {Node|null}
   * @api public
   */

  Iterator.prototype.previous = Iterator.prototype.prev = traverse('previousSibling', 'lastChild');

  /**
   * Make traverse function
   *
   * @param {String} dir
   * @param {String} child
   * @return {Function}
   * @api private
   */

  function traverse(dir, child) {
    var next = dir == 'nextSibling';
    return function walk(expr, n, peek) {
      expr = this.compile(expr);
      n = n && n > 0 ? n : 1;
      var node = this.node;
      var closing = this.closingTag;
      var revisit = this._revisit;

      while (node) {
        if (componentXor(next, closing) && node[child]) {
          // element with children: <em>...</em>
          node = node[child];
          closing = !next;
        } else if (1 == node.nodeType && !node[child] && componentXor(next, closing)) {
          // empty element tag: <em></em>
          closing = next;
          if (!revisit) continue;
        } else if (node[dir]) {
          // element has a neighbor: ...<em></em>...
          node = node[dir];
          closing = !next;
        } else {
          // done with current layer, move up.
          node = node.parentNode;
          closing = next;
          if (!revisit) continue;
        }

        if (!node || this.higher(node, this.root)) break;

        if (expr(node) && this.selects(node, peek) && this.rejects(node, peek)) {
          if (--n) continue;
          if (!peek) this.node = node;
          this.closingTag = closing;
          return node;
        }
      }

      return null;
    };
  }

  /**
   * Select nodes that cause `expr(node)`
   * to be truthy
   *
   * @param {Number|String|Function} expr
   * @return {Iterator} self
   * @api public
   */

  Iterator.prototype.select = function (expr) {
    expr = this.compile(expr);
    this._selects.push(expr);
    return this;
  };

  /**
   * Run through the selects ORing each
   *
   * @param {Node} node
   * @param {Boolean} peek
   * @return {Boolean}
   * @api private
   */

  Iterator.prototype.selects = function (node, peek) {
    var exprs = this._selects;
    var len = exprs.length;
    if (!len) return true;

    for (var i = 0; i < len; i++) {
      if (exprs[i].call(this, node, peek)) return true;
    }
    return false;
  };

  /**
   * Select nodes that cause `expr(node)`
   * to be falsy
   *
   * @param {Number|String|Function} expr
   * @return {Iterator} self
   * @api public
   */

  Iterator.prototype.reject = function (expr) {
    expr = this.compile(expr);
    this._rejects.push(expr);
    return this;
  };

  /**
   * Run through the reject expressions ANDing each
   *
   * @param {Node} node
   * @param {Boolean} peek
   * @return {Boolean}
   * @api private
   */

  Iterator.prototype.rejects = function (node, peek) {
    var exprs = this._rejects;
    var len = exprs.length;
    if (!len) return true;

    for (var i = 0; i < len; i++) {
      if (exprs[i].call(this, node, peek)) return false;
    }
    return true;
  };

  /**
   * Check if node is higher
   * than root.
   *
   * @param {Node} node
   * @param {Node} root
   * @return {Boolean}
   * @api private
   */

  Iterator.prototype.higher = function (node) {
    var root = this.root;
    if (!root) return false;
    node = node.parentNode;
    while (node && node != root) {
      node = node.parentNode;
    }return node != root;
  };

  /**
   * Compile an expression
   *
   * @param {String|Function|Number} expr
   * @return {Function}
   */

  Iterator.prototype.compile = function (expr) {
    switch (typeof expr === 'undefined' ? 'undefined' : _typeof$29(expr)) {
      case 'number':
        return function (node) {
          return expr == node.nodeType;
        };
      case 'string':
        return new Function('node', 'return ' + componentProps(expr, 'node.'));
      case 'function':
        return expr;
      default:
        return function () {
          return true;
        };
    }
  };

  /**
   * Peek in either direction
   * `n` nodes. Peek backwards
   * using negative numbers.
   *
   * @param {Number} n (optional)
   * @return {Node|null}
   * @api public
   */

  Iterator.prototype.peak = Iterator.prototype.peek = function (expr, n) {
    if (arguments.length == 1) n = expr, expr = true;
    n = undefined == n ? 1 : n;
    if (!n) return this.node;else if (n > 0) return this.next(expr, n, true);else return this.prev(expr, Math.abs(n), true);
  };

  /**
   * Add a plugin
   *
   * @param {Function} fn
   * @return {Iterator}
   * @api public
   */

  Iterator.prototype.use = function (fn) {
    fn(this);
    return this;
  };

  var selection = window.getSelection();

  /**
   * Add selection / insert cursor.
   *
   * @param {Range} range
   */
  function applyRange(range) {
    selection.removeAllRanges();
    selection.addRange(range);
  }

  /**
   * Get current document selection.
   *
   * @return {Selection}
   */
  function getWindowSelection() {
    return selection;
  }

  /**
   * Return true if element is part of window selection.
   *
   * @param  {Element}  el
   * @return {Boolean}
   */
  function isSelected(el) {

    if (!selection.rangeCount) {
      return null;
    }

    var focusNode = selection.focusNode;

    // IE supports Node#contains for elements only
    // thus we ensure we check against an actual Element node
    if (isText(focusNode)) {
      focusNode = focusNode.parentNode;
    }

    return el == focusNode || el.contains(focusNode);
  }

  /**
   * Set cursor or selection position.
   *
   * @param {Element} el
   * @param {SelectionRange} selection
   */
  function setRange(el, selection) {

    var range = createRange(el, selection);

    applyRange(range);
  }

  /**
   * Get cursor or selection position.
   *
   * @param {Element} el
   */
  function getRange(el) {

    if (!isSelected(el)) {
      return null;
    }

    var range = selection.getRangeAt(0);

    var startContainer = range.startContainer;
    var endContainer = range.endContainer;
    var startOffset = range.startOffset;
    var endOffset = range.endOffset;

    var i = domIterator(el.firstChild, el);

    var next = i.node;
    var last;

    var isClosing = false;

    var selectionStart;
    var count = 0;

    function isBeforeEnd(node, referenceNode) {

      if (arguments.length === 1) {
        referenceNode = node;
      }

      return node.parentNode === endContainer && referenceNode == endContainer.childNodes[endOffset];
    }

    function isBeforeStart(node, referenceNode) {

      if (arguments.length === 1) {
        referenceNode = node;
      }

      return node.parentNode === startContainer && referenceNode == startContainer.childNodes[startOffset];
    }

    while (next) {

      // start before node
      if (isBeforeStart(next)) {
        selectionStart = count;
      }

      // end before node
      if (isBeforeEnd(next)) {
        break;
      }

      if (!isClosing) {
        if (isBr(next) || last && last.nextSibling == next && (isDiv(next) || isParagraph(next))) {
          count++;
        }
      }

      if (isText(next)) {

        // #text node
        if (startContainer === next) {
          selectionStart = count + startOffset;
        }

        if (endContainer === next) {
          count += endOffset;
          break;
        }

        count += next.textContent.length;
      }

      if (isText(next) || isClosing) {

        // start before node
        if (isBeforeStart(next, next.nextSibling)) {
          selectionStart = count;
        }

        // end before node
        if (isBeforeEnd(next, next.nextSibling)) {
          break;
        }
      }

      last = next;
      next = i.next();
      isClosing = i.closingTag;
    }

    // selection until end of text
    return {
      start: typeof selectionStart === 'undefined' ? count : selectionStart,
      end: count
    };
  }

  //////// helpers ///////////////////////////

  function createRange(el, selection) {

    var start = selection.start;
    var end = selection.end;

    var range = document.createRange();

    var i = domIterator(el.firstChild, el);

    var next = i.node;
    var isClosing = false;

    var count = 0;
    var length;

    while (next) {

      if (count === start) {
        if (isClosing) {
          range.setStartAfter(next);
        } else {
          range.setStartBefore(next);
        }
      }

      if (count === end) {
        if (isClosing) {
          range.setEndAfter(next);
        } else {
          range.setEndBefore(next);
        }

        return range;
      }

      if (!isClosing) {
        if (isBr(next) || next.previousSibling && (isDiv(next) || isParagraph(next))) {
          count++;
        }
      }

      if (isText(next)) {

        length = next.textContent.length;

        if (count <= start && count + length > start) {
          range.setStart(next, start - count);
        }

        if (count + length > end) {
          range.setEnd(next, end - count);

          return range;
        }

        count += length;
      }

      next = i.next();
      isClosing = i.closingTag;
    }

    // out of range
    if (count <= start) {
      if (el.lastChild) {
        range.setStartAfter(el.lastChild);
      } else {
        range.setStart(el, 0);
      }
    }

    if (el.lastChild) {
      range.setEndAfter(el.lastChild);
    } else {
      range.setEnd(el, 0);
    }

    return range;
  }

  function isText(node) {
    return node.nodeType === 3;
  }

  function isBr(node) {
    return node.nodeType === 1 && node.nodeName === 'BR';
  }

  function isDiv(node) {
    return node.nodeType === 1 && node.nodeName === 'DIV';
  }

  function isParagraph(node) {
    return node.nodeType === 1 && node.nodeName === 'P';
  }

  var _slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;_e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }return _arr;
    }return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var SELECTABLE_SELECTOR = '[contenteditable]';

  var ELEMENT_SELECTOR$1 = '[data-element-id]';

  function getElementId(node) {
    return node.getAttribute('data-element-id');
  }

  function getElementCoords(node) {
    var coordsAttr = node.getAttribute('data-coords');

    if (!coordsAttr) {
      return null;
    }

    var _coordsAttr$split = coordsAttr.split(':'),
        _coordsAttr$split2 = _slicedToArray(_coordsAttr$split, 2),
        row = _coordsAttr$split2[0],
        col = _coordsAttr$split2[1];

    return {
      row: row,
      col: col
    };
  }

  function getNodeByCoords(elementCoords, container) {
    var coordsAttr = elementCoords.row + ':' + elementCoords.col;

    return query('[data-coords="' + css_escape(coordsAttr) + '"]', container);
  }

  function getNodeById(elementId, container) {
    return query('[data-element-id="' + css_escape(elementId) + '"]', container);
  }

  function isUnselectableNode(node) {
    return closest(node, '.no-deselect', true);
  }

  /**
   * Find semantically _selectable_ element in the nodes ancestors.
   *
   * @param {Element} node
   *
   * @return {Element} node
   */
  function findSelectableAncestor(node) {
    return closest(node, ELEMENT_SELECTOR$1, true);
  }

  /**
   * Return focusable node in selectable el.
   *
   * @param  {Element} el
   *
   * @return {Element}
   */
  function getFocusableNode(el) {

    var selector = SELECTABLE_SELECTOR;

    return matchesSelector$1(el, selector) ? el : query(selector, el);
  }

  /**
   * Ensure element or element childNode has the proper focus.
   *
   * @param {Element} el
   */
  function ensureFocus(el) {

    var focusEl = getFocusableNode(el);

    if (!focusEl) {
      return;
    }

    // QUIRK: otherwise range and focus related actions may
    // yield errors in older browsers (PhantomJS / IE)
    if (!document.body.contains(focusEl)) {
      return;
    }

    // nothing to do, if element already has focus
    if (document.activeElement === focusEl) {
      return;
    }

    // (1) focus
    focusEl.focus();

    // (2) set cursor to element end
    var range = getRange(focusEl);

    if (!range || range.end === 0) {
      setRange(focusEl, { start: 5000, end: 5000 });
    }
  }

  var LOW_PRIORITY$7 = 500;

  var VALID_DIRECTIONS = {
    above: true,
    below: true,
    right: true,
    left: true
  };

  /**
   * A cell selection utlity; allows selection of elements, independent from
   * whether they are backed by a business object or not.
   *
   * Works together with the {@link SelectionAware} trait.
   *
   * @param {RenderConfig} config
   * @param {EventBus} eventBus
   * @param {Sheet} sheet
   * @param {Selection} selection
   * @param {ElementRegistry} elementRegistry
   */
  function CellSelection(config, eventBus, sheet, selection, elementRegistry) {
    var container = config.container;

    var lastSelection = null;

    function emit(elementId, newSelection) {

      eventBus.fire('selection.' + elementId + '.changed', newSelection);

      eventBus.fire('cellSelection.changed', {
        elementId: elementId,
        selection: newSelection
      });
    }

    function click(event) {

      var target = event.target;

      if (isUnselectableNode(target)) {
        return;
      }

      var selectableNode = findSelectableAncestor(target);

      var elementId = selectableNode && getElementId(selectableNode);

      var focussed = !event.defaultPrevented;

      realSelect(elementId, focussed);

      event.stopPropagation();
    }

    function focus(event) {
      var elementId = getElementId(event.target);

      var focussed = !event.defaultPrevented;

      event.stopPropagation();

      return realSelect(elementId, focussed);
    }

    function unfocus(event) {
      var elementId = getElementId(event.target);

      emit(elementId, {
        focussed: false
      });
    }

    function realSelect(elementId) {
      var focussed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (lastSelection !== elementId) {
        emit(lastSelection, {
          selected: false,
          focussed: false
        });
      }

      lastSelection = elementId;

      if (elementId) {
        emit(elementId, {
          selected: true,
          focussed: focussed
        });
      }

      if (elementId) {
        selection.select(elementId);
      } else {
        selection.deselect();
      }
    }

    eventBus.on('cell.click', LOW_PRIORITY$7, click);
    eventBus.on('cell.focusin', LOW_PRIORITY$7, focus);
    eventBus.on('cell.focusout', LOW_PRIORITY$7, unfocus);

    eventBus.on('cellSelection.changed', function (event) {
      var elementId = event.elementId,
          selection = event.selection;

      var actualElement = getNodeById(elementId, container);

      if (selection.focussed && actualElement) {
        ensureFocus(actualElement);
      }
    });

    eventBus.on('selection.changed', function (event) {
      var selection = event.selection,
          oldSelection = event.oldSelection;

      var elementId = selection && selection.id;
      var oldElementId = oldSelection && oldSelection.id;

      // select new element
      if (elementId && elementId !== lastSelection) {
        realSelect(selection.id);
      } else

        // deselect old element
        if (oldElementId && oldElementId === lastSelection) {
          realSelect();
        }
    });

    // API //////////////////////

    /**
     * Return true if a cell is currently selected.
     *
     * @return {Boolean}
     */
    this.isCellSelected = function () {
      return !!lastSelection;
    };

    /**
     * Get the currently active cellSelection.
     *
     * @return {String} selection
     */
    this.getCellSelection = function () {
      return lastSelection;
    };

    /**
     * Select next cell in given direction.
     *
     * Returns true on success; false on fail (i.e. if no next selection
     * in direction could be found).
     *
     * @param {String} direction
     *
     * @return {Boolean}
     */
    this.selectCell = function (direction) {

      if (!lastSelection) {
        return;
      }

      if (!(direction in VALID_DIRECTIONS)) {
        throw new Error('direction must be any of { above, below, left, right }');
      }

      var selectionEl = getNodeById(lastSelection, container);

      var coords = getElementCoords(selectionEl);

      if (!coords) {
        return false;
      }

      var nextCoords = getNextCoords(coords, direction);

      var nextNode = getNodeByCoords(nextCoords, container);

      if (!nextNode) {
        return false;
      }

      var nextElId = getElementId(nextNode);

      if (nextElId) {
        realSelect(nextElId, {
          focussed: true,
          selected: true
        });
      }

      return true;
    };

    eventBus.on('contextMenu.close', function () {

      if (lastSelection) {
        return realSelect(lastSelection);
      }
    });
  }

  CellSelection.$inject = ['config.renderer', 'eventBus', 'sheet', 'selection', 'elementRegistry'];

  // helpers ////////////////

  function getNextCoords(coords, direction) {
    var row = coords.row,
        col = coords.col;

    if (direction === 'above' || direction === 'below') {

      var rowIndex = parseInt(row, 10);

      if (isNaN(rowIndex)) {
        return coords;
      }

      var nextRowIndex = direction === 'above' ? rowIndex - 1 : rowIndex + 1;

      return {
        col: col,
        row: nextRowIndex
      };
    }

    if (direction === 'left' || direction === 'right') {

      var colIndex = parseInt(col, 10);

      if (isNaN(colIndex)) {
        return coords;
      }

      var nextColIndex = direction === 'left' ? colIndex - 1 : colIndex + 1;

      return {
        row: row,
        col: nextColIndex
      };
    }

    throw new Error('invalid direction <' + direction + '>');
  }

  var CellSelection$1 = {
    __depends__: [InteractionModule, Selection$2],
    __init__: ['cellSelection'],
    cellSelection: ['type', CellSelection]
  };

  var _typeof$30 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$31 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$38(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$19(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$30(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$19(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$30(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var HIGH_PRIORITY$1 = 2000;

  var DecisionTableModelingRules = function (_RuleProvider) {
    _inherits$19(DecisionTableModelingRules, _RuleProvider);

    function DecisionTableModelingRules(eventBus, sheet) {
      _classCallCheck$38(this, DecisionTableModelingRules);

      var _this = _possibleConstructorReturn$19(this, (DecisionTableModelingRules.__proto__ || Object.getPrototypeOf(DecisionTableModelingRules)).call(this, eventBus));

      _this._sheet = sheet;
      return _this;
    }

    _createClass$31(DecisionTableModelingRules, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        this.addRule('col.move', HIGH_PRIORITY$1, function (_ref) {
          var col = _ref.col,
              index = _ref.index;

          var _sheet$getRoot = _this2._sheet.getRoot(),
              businessObject = _sheet$getRoot.businessObject,
              input = businessObject.input;

          if (isInput(col)) {
            return index < input.length;
          } else {
            return index >= input.length;
          }
        });

        this.addRule('col.remove', HIGH_PRIORITY$1, function (_ref2) {
          var col = _ref2.col;

          var _sheet$getRoot2 = _this2._sheet.getRoot(),
              cols = _sheet$getRoot2.cols;

          if (isOutput(col)) {
            return cols.filter(function (c) {
              return isOutput(c);
            }).length > 1;
          }

          return true;
        });

        // a rule that is aware of the data structure coming from copy and paste
        this.addRule('paste', HIGH_PRIORITY$1, function (_ref3) {
          var data = _ref3.data,
              target = _ref3.target;

          if (!data || !target) {
            return false;
          }

          var root = data.root;

          if (target instanceof Row) {
            return _this2.canPasteRows(root);
          }

          if (target instanceof Col) {
            return _this2.canPasteCols(root, target);
          }

          return false;
        });
      }
    }, {
      key: 'canPasteRows',
      value: function canPasteRows(root) {
        var _sheet$getRoot3 = this._sheet.getRoot(),
            cols = _sheet$getRoot3.cols;

        return every(root, function (descriptor) {
          if (descriptor.type !== 'row') {
            return false;
          }

          if (descriptor.cells.length !== cols.length) {
            return false;
          }

          return every(descriptor.cells, function (cellDescriptor, index) {
            if (isInput(cols[index])) {
              return cellDescriptor.businessObject.$type === 'dmn:UnaryTests';
            } else {
              return cellDescriptor.businessObject.$type === 'dmn:LiteralExpression';
            }
          });
        });
      }
    }, {
      key: 'canPasteCols',
      value: function canPasteCols(root, targetCol) {
        var _sheet$getRoot4 = this._sheet.getRoot(),
            rows = _sheet$getRoot4.rows;

        return every(root, function (descriptor) {
          if (descriptor.type !== 'col') {
            return false;
          }

          if (descriptor.cells.length !== rows.length) {
            return false;
          }

          if (isInput(targetCol)) {
            return descriptor.businessObject.$type === 'dmn:InputClause';
          } else {
            return descriptor.businessObject.$type === 'dmn:OutputClause';
          }
        });
      }
    }]);

    return DecisionTableModelingRules;
  }(RuleProvider);

  DecisionTableModelingRules.$inject = ['eventBus', 'sheet'];

  var Rules$5 = {
    __depends__: [Rules$1]
  };

  var Rules$6 = {
    __depends__: [Rules$5],
    __init__: ['decisionTableModelingRules'],
    decisionTableModelingRules: ['type', DecisionTableModelingRules]
  };

  var _createClass$32 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$39(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * A handler that implements cutting a row or col.
   * Cutting of cells doesn't make sense.
   */

  var CutHandler = function () {
    function CutHandler(clipboard, modeling, sheet) {
      _classCallCheck$39(this, CutHandler);

      this._clipboard = clipboard;
      this._modeling = modeling;
      this._sheet = sheet;
    }

    /**
     * <do>
     */

    _createClass$32(CutHandler, [{
      key: 'execute',
      value: function execute(context) {
        var data = context.data;

        context.oldData = this._clipboard.get();

        this._clipboard.set(data);

        return this._sheet.getRoot();
      }
    }, {
      key: 'postExecute',
      value: function postExecute(context) {
        var _this = this;

        var elements = context.elements;

        elements.forEach(function (element) {
          if (element instanceof Row) {
            _this._modeling.removeRow(element);
          } else if (element instanceof Col) {
            _this._modeling.removeCol(element);
          }
        });
      }

      /**
       * <undo>
       */

    }, {
      key: 'revert',
      value: function revert(context) {
        var oldData = context.oldData;

        this._clipboard.set(oldData);

        return this._sheet.getRoot();
      }
    }]);

    return CutHandler;
  }();

  CutHandler.$inject = ['clipboard', 'modeling', 'sheet'];

  var _extends$8 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }return obj;
  }

  function _toConsumableArray$8(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  // creating descriptors //////////

  var createHooks = [copyTableProperties, copyBusinessObjectProperties];

  var reviveHooks = [reviveBusinessObject, reviveTableElement];

  /**
   * Return a serializable snapshot of the given elements.
   *
   * @param {Array<Base>} elements list of table elements
   *
   * @return {Tree} descriptor tree
   */
  function createDescriptor(element, cache, hooks) {

    hooks = hooks || createHooks;
    cache = cache || {};

    if (isArray(element)) {
      return createDescriptors0(element, cache, hooks);
    } else {
      return createDescriptor0(element, cache, hooks);
    }
  }

  /**
   * Create descriptors of elements, returning { descriptors: [], descriptorCache }.
   *
   * @param {Array<Base>} elements list of table elements
   * @param {Object} cache the create cache
   *
   * @return {Object} new descriptors + updated cache
   */
  function createDescriptors0(elements, cache, hooks) {

    return reduce(elements, function (result, element) {

      var currentCache = result.descriptorCache,
          currentDescriptors = result.root;

      var _createDescriptor = createDescriptor0(element, currentCache, hooks),
          root = _createDescriptor.root,
          descriptorCache = _createDescriptor.descriptorCache;

      return {
        root: [].concat(_toConsumableArray$8(currentDescriptors), [root]),
        descriptorCache: _extends$8({}, currentCache, descriptorCache)
      };
    }, {
      root: [],
      descriptorCache: cache
    });
  }

  function createDescriptor0(element, cache, hooks) {

    var id = element.id;

    var descriptor = {
      id: id
    };

    var elements = cache.elements || {};

    var existingDescriptor = elements[id];

    // element already created; nothing to do
    if (existingDescriptor) {
      return {
        root: existingDescriptor,
        descriptorCache: cache
      };
    }

    // we're new; need to initialize element via hooks
    // we assume we're not handling recursive data structures
    // here. Otherwise we'd need to pre-populate the cache
    // with the given element
    var element0 = evaluateHooks(element, descriptor, hooks, _extends$8({}, cache, {
      elements: elements
    }));

    return {
      root: element0.root,
      descriptorCache: _extends$8({}, element0.descriptorCache, {
        elements: _extends$8({}, element0.descriptorCache.elements, _defineProperty$1({}, id, element0.root))
      })
    };
  }

  function evaluateHooks(element, descriptor, hooks, cache) {

    function create(element, descriptorCache) {
      return createDescriptor(element, descriptorCache, hooks);
    }

    return reduce(hooks, function (result, hook) {
      return hook(element, result.root, result.descriptorCache, create);
    }, {
      root: descriptor,
      descriptorCache: cache
    });
  }

  function copyTableProperties(element, descriptor, cache, create) {

    var descriptorCache = cache;

    var newDesc = _extends$8({}, descriptor, {
      type: getType$1(element)
    });

    if (element instanceof Row || element instanceof Col) {
      var cells0 = create(element.cells, descriptorCache);

      newDesc.cells = cells0.root;
      descriptorCache = cells0.descriptorCache;
    }

    return {
      root: newDesc,
      descriptorCache: descriptorCache
    };
  }

  function copyBusinessObjectProperties(element, descriptor, cache) {

    var businessObject = element.businessObject;

    if (!businessObject) {
      return {
        root: descriptor,
        descriptorCache: cache
      };
    }

    // need to clone businessObject
    var bo0 = createBoDescriptor(businessObject, cache);

    return {
      root: _extends$8({}, descriptor, {
        businessObject: bo0.root
      }),
      descriptorCache: bo0.descriptorCache
    };
  }

  function getType$1(element) {

    if (element instanceof Row) {
      return 'row';
    }

    if (element instanceof Col) {
      return 'col';
    }

    if (element instanceof Cell) {
      return 'cell';
    }

    throw new Error('cannot deduce element type: #' + element.id);
  }

  function createBoDescriptor(bo, cache) {
    var boCache, existingBoDesc;

    var id = bo.id;

    if (id) {
      boCache = cache.boCache || {};

      existingBoDesc = boCache[id];

      // businessObject already created; nothing to do
      if (existingBoDesc) {
        return {
          root: existingBoDesc,
          descriptorCache: cache
        };
      }
    }

    var descriptor = {
      $type: bo.$type
    };

    if (id) {
      descriptor.id = id;

      boCache = _extends$8({}, boCache, _defineProperty$1({}, id, descriptor));

      cache = _extends$8({}, cache, {
        boCache: boCache
      });
    }

    // TODO(nikku): distinguish relations and containment
    // Need to build up the whole tree and revive relations afterwards

    // ITERATE OVER ALL SET PROPERTIES
    // (Object.keys(bo) or via bo.$descriptor....)

    bo.$descriptor.properties.forEach(function (property) {
      var value = bo[property.name];

      // const propertyDescriptor = bo.$model.getPropertyDescriptor(bo, property.name),
      //       isId = propertyDescriptor.isId,
      //       isReference = propertyDescriptor.isReference;

      // not set
      if (!value) {
        return;
      }

      // arrays of moddle elements
      if (isArray(value)) {
        value = value.map(function (b) {
          var value0 = createBoDescriptor(b, cache);

          cache = value0.descriptorCache;

          return value0.root;
        });
      }

      // moddle elements
      if (value.$type) {
        var value0 = createBoDescriptor(value, cache);

        cache = value0.descriptorCache;
        value = value0.root;
      }

      // other values
      descriptor[property.name] = value;
    });

    return {
      root: descriptor,
      descriptorCache: cache
    };
  }

  // reviving //////////

  function reviveDescriptor(entry, reviveCache, hooks) {

    hooks = hooks || reviveHooks;
    reviveCache = reviveCache || {};

    if (isArray(entry.root)) {
      return reviveDescriptors0(entry, reviveCache, hooks);
    } else {
      return reviveDescriptor0(entry, reviveCache, hooks);
    }
  }

  /**
   * TBD: document this!
   *
   * @param  {[type]} entry       [description]
   * @param  {[type]} reviveCache [description]
   * @param  {[type]} hooks       [description]
   * @return {[type]}             [description]
   */
  function reviveDescriptors0(entry, reviveCache, hooks) {

    var descriptors = entry.root;
    var descriptorCache = entry.descriptorCache;

    return reduce(descriptors, function (result, element) {

      var currentCache = result.reviveCache,
          currentDescriptors = result.root;

      var _reviveDescriptor = reviveDescriptor0({ root: element, descriptorCache: descriptorCache }, currentCache, hooks),
          root = _reviveDescriptor.root,
          reviveCache = _reviveDescriptor.reviveCache;

      return {
        root: [].concat(_toConsumableArray$8(currentDescriptors), [root]),
        reviveCache: reviveCache
      };
    }, {
      root: [],
      reviveCache: reviveCache
    });
  }

  /**
   * TBD: document this!
   *
   * @param  {[type]} entry [description]
   * @param  {[type]} cache [description]
   * @param  {[type]} hooks [description]
   * @return {[type]}       [description]
   */
  function reviveDescriptor0(entry, reviveCache, hooks) {

    var descriptor = entry.root;

    var id = descriptor.id;

    var elements = reviveCache.elements || {};

    var existingElement = elements[id];

    // element already created; nothing to do
    if (existingElement) {
      return {
        root: existingElement,
        reviveCache: reviveCache
      };
    }

    // start with a fake element; haha <3
    var element = {
      id: id
    };

    // we're new; need to initialize element via hooks
    var element0 = evaluateReviveHooks(entry, element, hooks, _extends$8({}, reviveCache, {
      elements: elements
    }));

    return {
      root: element0.root,
      reviveCache: _extends$8({}, element0.reviveCache, {
        elements: _extends$8({}, element0.reviveCache.elements, _defineProperty$1({}, id, element0.root))
      })
    };
  }

  // entry = { root, descriptorCache }
  // element = { id: foo }
  // hooks = [ ... ]
  // reviveCache = { ... }
  function evaluateReviveHooks(entry, element, hooks, reviveCache) {

    function revive(entry, reviveCache) {
      return reviveDescriptor(entry, reviveCache, hooks);
    }

    return reduce(hooks, function (result, hook) {
      return hook(entry, result.root, result.reviveCache, revive);
    }, {
      root: element,
      reviveCache: reviveCache
    });
  }

  function reviveTableElement(entry, element, reviveCache, revive) {
    var descriptor = entry.root;
    var createCache = entry.descriptorCache;

    var elementAttrs = _extends$8({}, element);

    // make sure table element ID is same as moddle element ID
    if (element.businessObject && element.businessObject.id) {
      elementAttrs.id = element.businessObject.id;
    }

    if (descriptor.type === 'row' || descriptor.type === 'col') {
      var cells0 = revive({
        root: descriptor.cells,
        descriptorCache: createCache
      }, reviveCache);

      elementAttrs.cells = cells0.root;
      reviveCache = cells0.reviveCache;
    }

    var Constructor = getConstructor(descriptor);

    var newElement = new Constructor(elementAttrs);

    // set parent row or col
    if (newElement instanceof Row) {
      newElement.cells.forEach(function (cell) {
        cell.row = newElement;
      });
    } else if (newElement instanceof Col) {
      newElement.cells.forEach(function (cell) {
        cell.col = newElement;
      });
    }

    return {
      root: newElement,
      reviveCache: reviveCache
    };
  }

  function reviveBusinessObject(entry, element, reviveCache) {
    var businessObject = entry.root.businessObject;

    if (!businessObject) {
      return {
        root: element,
        reviveCache: reviveCache
      };
    }

    // need to clone businessObject
    var bo0 = createBo({
      root: businessObject,
      descriptorCache: entry.descriptorCache
    }, reviveCache);

    return {
      root: _extends$8({}, element, {
        businessObject: bo0.root
      }),
      reviveCache: bo0.reviveCache
    };
  }

  function getConstructor(descriptor) {

    switch (descriptor.type) {
      case 'row':
        return Row;
      case 'cell':
        return Cell;
      case 'col':
        return Col;
      default:
        throw new Error('unknown element type: #' + descriptor.type);
    }
  }

  function createBo(entry, reviveCache) {
    var boDescriptor = entry.root;

    var id = boDescriptor.id;

    var boCache = void 0,
        existingBo = void 0;

    if (id) {
      boCache = reviveCache.boCache || {};

      existingBo = boCache[id];

      // businessObject already created; nothing to do
      if (existingBo) {
        return {
          root: existingBo,
          reviveCache: reviveCache
        };
      }
    }

    var newBoAttrs = {};

    // set attrs for new business object (might include creating other business objects)
    keys(boDescriptor).forEach(function (key) {
      var val = void 0,
          val0 = void 0;

      if (boDescriptor[key].$type) {
        val0 = createBo({
          root: boDescriptor[key]
        }, reviveCache);

        val = val0.root;

        reviveCache = val0.reviveCache;
        boCache = reviveCache.boCache || {};
      } else if (isArray(boDescriptor[key])) {
        val = boDescriptor[key].map(function (b) {
          val0 = createBo({
            root: b
          }, reviveCache);

          reviveCache = val0.reviveCache;
          boCache = reviveCache.boCache || {};

          return val0.root;
        });
      } else {
        val = boDescriptor[key];
      }

      newBoAttrs[key] = val;
    });

    var type = newBoAttrs.$type;

    delete newBoAttrs.$type;

    // generate new ID if not supposed to be kept or already assigned
    if (!reviveCache._keepIds || reviveCache._model.ids.assigned(newBoAttrs.id)) {

      delete newBoAttrs.id;
    }

    var newBo = reviveCache._dmnFactory.create(type, newBoAttrs);

    // set up $parent relationships for moddle elements
    forEach(newBoAttrs, function (newBoAttr) {
      if (newBoAttr.$type) {
        newBoAttr.$parent = newBo;
      }

      if (isArray(newBoAttr)) {
        newBoAttr.forEach(function (a) {
          return a.$parent = newBo;
        });
      }
    });

    if (id) {
      boCache = _extends$8({}, boCache, _defineProperty$1({}, id, newBo));

      reviveCache = _extends$8({}, reviveCache, {
        boCache: boCache
      });
    }

    return {
      root: newBo,
      reviveCache: reviveCache
    };
  }

  var _createClass$33 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$40(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * A handler that implements pasting elements.
   */

  var PasteHandler$1 = function () {
    function PasteHandler(clipboard, dmnFactory, elementFactory, elementRegistry, eventBus, moddle, modeling, sheet) {
      _classCallCheck$40(this, PasteHandler);

      this._clipboard = clipboard;
      this._dmnFactory = dmnFactory;
      this._elementFactory = elementFactory;
      this._elementRegistry = elementRegistry;
      this._eventBus = eventBus;
      this._model = moddle;
      this._modeling = modeling;
      this._sheet = sheet;
    }

    /**
     * <do>
     */

    _createClass$33(PasteHandler, [{
      key: 'postExecute',
      value: function postExecute(context) {
        var _this = this;

        var element = context.element,
            after = context.after;

        var data = this._clipboard.get();

        if (!data) {
          throw new Error('missing clipboard data');
        }

        var root = this._sheet.getRoot();

        // (1) create elements from descriptors
        var elements = reviveDescriptor(data.elements, {
          _dmnFactory: this._dmnFactory,
          _keepIds: data.keepIds,
          _model: this._model
        }).root;

        // (2) add elements to sheet
        if (element instanceof Row) {

          var index = root.rows.indexOf(element);

          if (index === -1) {
            return;
          }

          elements.forEach(function (element) {
            if (after) {
              index++;
            }

            _this._modeling.addRow(element, index);
          });
        } else if (element instanceof Col) {

          var _index = root.cols.indexOf(element);

          if (_index === -1) {
            return;
          }

          elements.forEach(function (element) {
            if (after) {
              _index++;
            }

            _this._modeling.addCol(element, _index);
          });
        }

        context.oldElements = this._clipboard.get();

        return this._sheet.getRoot();
      }

      /**
       * <undo>
       */

    }, {
      key: 'revert',
      value: function revert(context) {}
    }]);

    return PasteHandler;
  }();

  PasteHandler$1.$inject = ['clipboard', 'dmnFactory', 'elementFactory', 'elementRegistry', 'eventBus', 'moddle', 'modeling', 'sheet'];

  var _extends$9 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass$34 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$41(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var CutPaste = function () {
    function CutPaste(clipboard, commandStack, eventBus, modeling, sheet, rules) {
      _classCallCheck$41(this, CutPaste);

      this._clipboard = clipboard;
      this._commandStack = commandStack;
      this._eventBus = eventBus;
      this._modeling = modeling;
      this._sheet = sheet;
      this._rules = rules;

      commandStack.registerHandler('cut', CutHandler);
      commandStack.registerHandler('paste', PasteHandler$1);
    }

    /**
     * Copy elements.
     *
     * @param {Array} elements - Elements to be copied.
     */

    _createClass$34(CutPaste, [{
      key: 'copy',
      value: function copy(elements) {
        if (!isArray(elements)) {
          elements = [elements];
        }

        var data = {
          elements: createDescriptor(elements)
        };

        this._eventBus.fire('copyCutPaste.copy', { data: data });

        this._clipboard.set(data);
      }

      /**
       * Cut elements thereby removing them temporarily.
       *
       * @param {Array} elements - Elements to be cut.
       */

    }, {
      key: 'cut',
      value: function cut(elements) {
        if (!isArray(elements)) {
          elements = [elements];
        }

        var data = {
          elements: createDescriptor(elements),
          keepIds: true
        };

        var context = {
          elements: elements,
          data: data
        };

        this._eventBus.fire('copyCutPaste.cut', { data: data });

        this._commandStack.execute('cut', context);
      }

      /**
       * Paste rows or cols before row or col.
       *
       * @param {Row|Col} element - Row or col to paste elements before.
       */

    }, {
      key: 'pasteBefore',
      value: function pasteBefore(element) {
        return this._paste(element, { before: true });
      }

      /**
       * Paste rows or cols after row or col.
       *
       * @param {Row|Col} element - Row or col to paste elements after.
       */

    }, {
      key: 'pasteAfter',
      value: function pasteAfter(element) {
        return this._paste(element, { after: true });
      }

      /**
       * Basic paste onto given target element.
       */

    }, {
      key: '_paste',
      value: function _paste(target, position) {

        var clipboardData = this._clipboard.get();

        if (!clipboardData) {
          return undefined;
        }

        var allowed = this._rules.allowed('paste', {
          data: clipboardData.elements,
          target: target
        });

        if (!allowed) {
          return false;
        }

        this._commandStack.execute('paste', _extends$9({
          element: target
        }, position));

        return true;
      }

      /**
       * Paste elements at.
       */

    }, {
      key: 'pasteAt',
      value: function pasteAt(element) {
        // TODO: implement for pasting cells
      }
    }]);

    return CutPaste;
  }();

  CutPaste.$inject = ['clipboard', 'commandStack', 'eventBus', 'modeling', 'sheet', 'rules'];

  var CopyCutPaste = {
    __depends__: [ClipboardModule, Rules$6],
    __init__: ['copyCutPaste'],
    copyCutPaste: ['type', CutPaste]
  };

  function _classCallCheck$42(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var DecisionTableEditorActions = function DecisionTableEditorActions(copyCutPaste, editorActions, modeling, selection, cellSelection, sheet) {
    _classCallCheck$42(this, DecisionTableEditorActions);

    var actions = {
      addRule: function addRule() {
        return modeling.addRow({ type: 'dmn:DecisionRule' });
      },
      addRuleAbove: function addRuleAbove(context) {
        var rule = context && context.rule;

        if (!rule && !selection.hasSelection()) {
          return;
        }

        rule = rule || selection.get().row;

        var root = sheet.getRoot(),
            index = root.rows.indexOf(rule);

        if (index === -1) {
          return;
        }

        return modeling.addRow({ type: 'dmn:DecisionRule' }, index);
      },
      addRuleBelow: function addRuleBelow(context) {
        var rule = context && context.rule;

        if (!rule && !selection.hasSelection()) {
          return;
        }

        rule = rule || selection.get().row;

        var root = sheet.getRoot(),
            index = root.rows.indexOf(rule);

        if (index === -1) {
          return;
        }

        return modeling.addRow({ type: 'dmn:DecisionRule' }, index + 1);
      },
      removeRule: function removeRule(context) {
        var rule = context && context.rule;

        if (!rule && !selection.hasSelection()) {
          return;
        }

        rule = rule || selection.get().row;

        modeling.removeRow(rule);
      },
      addInput: function addInput() {
        var root = sheet.getRoot(),
            businessObject = root.businessObject;

        var input = businessObject.input;

        return modeling.addCol({
          type: 'dmn:InputClause'
        }, input ? input.length : 0);
      },
      addInputLeft: function addInputLeft(context) {
        var input = context && context.input;

        if (!input && !selection.hasSelection()) {
          return;
        }

        input = input || selection.get().col;

        var root = sheet.getRoot(),
            index = root.cols.indexOf(input);

        if (index === -1) {
          return;
        }

        return modeling.addCol({ type: 'dmn:InputClause' }, index);
      },
      addInputRight: function addInputRight(context) {
        var input = context && context.input;

        if (!input && !selection.hasSelection()) {
          return;
        }

        input = input || selection.get().col;

        var root = sheet.getRoot(),
            index = root.cols.indexOf(input);

        if (index === -1) {
          return;
        }

        return modeling.addCol({ type: 'dmn:InputClause' }, index + 1);
      },
      removeInput: function removeInput(context) {
        var input = context && context.input;

        if (!input && !selection.hasSelection()) {
          return;
        }

        input = input || selection.get().col;

        modeling.removeCol(input);
      },
      addOutput: function addOutput() {
        var root = sheet.getRoot(),
            businessObject = root.businessObject;

        var input = businessObject.input,
            output = businessObject.output;

        return modeling.addCol({ type: 'dmn:OutputClause' }, input.length + output.length);
      },
      addOutputLeft: function addOutputLeft(context) {
        var output = context && context.output;

        if (!output && !selection.hasSelection()) {
          return;
        }

        output = output || selection.get().col;

        var root = sheet.getRoot(),
            index = root.cols.indexOf(output);

        if (index === -1) {
          return;
        }

        return modeling.addCol({ type: 'dmn:OutputClause' }, index);
      },
      addOutputRight: function addOutputRight(context) {
        var output = context && context.output;

        if (!output && !selection.hasSelection()) {
          return;
        }

        output = output || selection.get().col;

        var root = sheet.getRoot(),
            index = root.cols.indexOf(output);

        if (index === -1) {
          return;
        }

        return modeling.addCol({ type: 'dmn:OutputClause' }, index + 1);
      },
      removeOutput: function removeOutput(context) {
        var output = context && context.output;

        if (!output && !selection.hasSelection()) {
          return;
        }

        output = output || selection.get().col;

        modeling.removeCol(output);
      },
      addClause: function addClause() {
        if (!selection.hasSelection()) {
          return;
        }

        var clause = selection.get().col;

        if (is(clause, 'dmn:InputClause')) {
          return actions.addInput({ input: clause });
        } else if (is(clause, 'dmn:OutputClause')) {
          return actions.addOutput({ output: clause });
        }
      },
      addClauseLeft: function addClauseLeft() {
        if (!selection.hasSelection()) {
          return;
        }

        var clause = selection.get().col;

        if (is(clause, 'dmn:InputClause')) {
          return actions.addInputLeft({ input: clause });
        } else if (is(clause, 'dmn:OutputClause')) {
          return actions.addOutputLeft({ output: clause });
        }
      },
      addClauseRight: function addClauseRight() {
        if (!selection.hasSelection()) {
          return;
        }

        var clause = selection.get().col;

        if (is(clause, 'dmn:InputClause')) {
          return actions.addInputRight({ input: clause });
        } else if (is(clause, 'dmn:OutputClause')) {
          return actions.addOutputRight({ output: clause });
        }
      },
      removeClause: function removeClause() {
        if (!selection.hasSelection()) {
          return;
        }

        var clause = selection.get().col;

        if (is(clause, 'dmn:InputClause')) {
          return actions.removeInput({ input: clause });
        } else if (is(clause, 'dmn:OutputClause')) {
          return actions.removeOutput({ output: clause });
        }
      },
      selectCellAbove: function selectCellAbove() {
        return cellSelection.selectCell('above');
      },
      selectCellBelow: function selectCellBelow() {
        return cellSelection.selectCell('below');
      },
      copy: function copy(_ref) {
        var element = _ref.element;

        copyCutPaste.copy(element);
      },
      cut: function cut(_ref2) {
        var element = _ref2.element;

        copyCutPaste.cut(element);
      },
      pasteBefore: function pasteBefore(_ref3) {
        var element = _ref3.element;

        return copyCutPaste.pasteBefore(element);
      },
      pasteAfter: function pasteAfter(_ref4) {
        var element = _ref4.element;

        return copyCutPaste.pasteAfter(element);
      }
    };

    editorActions.register(actions);
  };

  DecisionTableEditorActions.$inject = ['copyCutPaste', 'editorActions', 'modeling', 'selection', 'cellSelection', 'sheet'];

  var _createClass$35 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$43(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var NOT_REGISTERED_ERROR$1 = 'is not a registered action',
      IS_REGISTERED_ERROR$1 = 'is already registered';

  /**
   * An interface that provides access to modeling actions by decoupling
   * the one who requests the action to be triggered and the trigger itself.
   *
   * It's possible to add new actions by registering them with ´registerAction´ and likewise
   * unregister existing ones with ´unregisterAction´.
   *
   */

  var EditorActions$1 = function () {
    function EditorActions(commandStack, eventBus, modeling, selection) {
      _classCallCheck$43(this, EditorActions);

      this._actions = {
        undo: function undo() {
          commandStack.undo();
        },
        redo: function redo() {
          commandStack.redo();
        },
        select: function select(_ref) {
          var cell = _ref.cell;

          selection.select(cell);
        },
        deselect: function deselect() {
          selection.deselect();
        },
        addRow: function addRow(_ref2) {
          var attrs = _ref2.attrs,
              index = _ref2.index;

          modeling.addRow(attrs, index);
        },
        removeRow: function removeRow(_ref3) {
          var row = _ref3.row;

          modeling.removeRow(row);
        },
        moveRow: function moveRow(_ref4) {
          var row = _ref4.row,
              index = _ref4.index;

          modeling.moveRow(row, index);
        },
        addCol: function addCol(_ref5) {
          var attrs = _ref5.attrs,
              index = _ref5.index;

          modeling.addCol(attrs, index);
        },
        removeCol: function removeCol(_ref6) {
          var col = _ref6.col;

          modeling.removeCol(col);
        },
        moveCol: function moveCol(_ref7) {
          var col = _ref7.col,
              index = _ref7.index;

          modeling.moveCol(col, index);
        }
      };
    }

    /**
     * Triggers a registered action
     *
     * @param  {String} action
     * @param  {Object} opts
     *
     * @return {Unknown} Returns what the registered listener returns
     */

    _createClass$35(EditorActions, [{
      key: 'trigger',
      value: function trigger(action, opts) {
        if (!this._actions[action]) {
          throw error$3(action, NOT_REGISTERED_ERROR$1);
        }

        return this._actions[action](opts);
      }

      /**
       * Registers a collections of actions.
       * The key of the object will be the name of the action.
       *
       * @param  {Object} actions
       */

    }, {
      key: 'register',
      value: function register(actions, listener) {
        var _this = this;

        if (typeof actions === 'string') {
          return this._registerAction(actions, listener);
        }

        forEach(actions, function (listener, action) {
          _this._registerAction(action, listener);
        }, this);
      }

      /**
       * Registers a listener to an action key
       *
       * @param  {String} action
       * @param  {Function} listener
       */

    }, {
      key: '_registerAction',
      value: function _registerAction(action, listener) {
        if (this.isRegistered(action)) {
          throw error$3(action, IS_REGISTERED_ERROR$1);
        }

        this._actions[action] = listener;
      }

      /**
       * Unregister an existing action
       *
       * @param {String} action
       */

    }, {
      key: 'unregister',
      value: function unregister(action) {
        if (!this.isRegistered(action)) {
          throw error$3(action, NOT_REGISTERED_ERROR$1);
        }

        this._actions[action] = undefined;
      }

      /**
       * Checks wether the given action is registered
       *
       * @param {String} action
       *
       * @return {Boolean}
       */

    }, {
      key: 'isRegistered',
      value: function isRegistered(action) {
        return !!this._actions[action];
      }
    }]);

    return EditorActions;
  }();

  EditorActions$1.$inject = ['commandStack', 'eventBus', 'modeling', 'selection'];

  // helpers /////////////

  function error$3(action, message) {
    return new Error(action + ' ' + message);
  }

  var EditorActions$2 = {
    __depends__: [Selection$2],
    __init__: ['editorActions'],
    editorActions: ['type', EditorActions$1]
  };

  var EditorActions$3 = {
    __depends__: [CellSelection$1, CopyCutPaste, EditorActions$2, Selection$2],
    __init__: ['decisionTableEditorActions'],
    decisionTableEditorActions: ['type', DecisionTableEditorActions]
  };

  var addRuleModule = {
    __depends__: [EditorActions$3],
    __init__: ['addRule'],
    addRule: ['type', AddRule]
  };

  /*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   */

  /**
   * Module variables.
   * @private
   */

  var matchHtmlRegExp = /["'&<>]/;

  /**
   * Module exports.
   * @public
   */

  var escapeHtml_1 = escapeHtml;

  /**
   * Escape special characters in the given string of html.
   *
   * @param  {string} string The string to escape for inserting into HTML
   * @return {string}
   * @public
   */

  function escapeHtml(string) {
    var str = '' + string;
    var match = matchHtmlRegExp.exec(str);

    if (!match) {
      return str;
    }

    var escape;
    var html = '';
    var index = 0;
    var lastIndex = 0;

    for (index = match.index; index < str.length; index++) {
      switch (str.charCodeAt(index)) {
        case 34:
          // "
          escape = '&quot;';
          break;
        case 38:
          // &
          escape = '&amp;';
          break;
        case 39:
          // '
          escape = '&#39;';
          break;
        case 60:
          // <
          escape = '&lt;';
          break;
        case 62:
          // >
          escape = '&gt;';
          break;
        default:
          continue;
      }

      if (lastIndex !== index) {
        html += str.substring(lastIndex, index);
      }

      lastIndex = index + 1;
      html += escape;
    }

    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }

  /**
   * Calculate the selection update for the given
   * current and new input values.
   *
   * @param {Object} currentSelection as {start, end}
   * @param {String} currentValue
   * @param {String} newValue
   *
   * @return {Object} newSelection as {start, end}
   */

  function calculateUpdate(currentSelection, currentValue, newValue) {

    var currentCursor = currentSelection.start,
        newCursor = currentCursor,
        diff = newValue.length - currentValue.length;

    var lengthDelta = newValue.length - currentValue.length;

    var currentTail = currentValue.substring(currentCursor);

    // check if we can remove common ending from the equation
    // to be able to properly detect a selection change for
    // the following scenarios:
    //
    //  * (AAATTT|TF) => (AAAT|TF)
    //  * (AAAT|TF) =>  (AAATTT|TF)
    //
    if (newValue.lastIndexOf(currentTail) === newValue.length - currentTail.length) {
      currentValue = currentValue.substring(0, currentValue.length - currentTail.length);
      newValue = newValue.substring(0, newValue.length - currentTail.length);
    }

    // diff
    var diff = createDiff(currentValue, newValue);

    if (diff) {
      if (diff.type === 'remove') {
        newCursor = diff.newStart;
      } else {
        newCursor = diff.newEnd;
      }
    }

    return range(newCursor);
  }

  var selectionUpdate = calculateUpdate;

  function createDiff(currentValue, newValue) {

    var insert;

    var l_str,
        l_char,
        l_idx = 0,
        s_str,
        s_char,
        s_idx = 0;

    if (newValue.length > currentValue.length) {
      l_str = newValue;
      s_str = currentValue;
    } else {
      l_str = currentValue;
      s_str = newValue;
    }

    // assume there will be only one insert / remove and
    // detect that _first_ edit operation only
    while (l_idx < l_str.length) {

      l_char = l_str.charAt(l_idx);
      s_char = s_str.charAt(s_idx);

      // chars no not equal
      if (l_char !== s_char) {

        if (!insert) {
          insert = {
            l_start: l_idx,
            s_start: s_idx
          };
        }

        l_idx++;
      }

      // chars equal (again?)
      else {

          if (insert && !insert.complete) {
            insert.l_end = l_idx;
            insert.s_end = s_idx;
            insert.complete = true;
          }

          s_idx++;
          l_idx++;
        }
    }

    if (insert && !insert.complete) {
      insert.complete = true;
      insert.s_end = s_str.length;
      insert.l_end = l_str.length;
    }

    // no diff
    if (!insert) {
      return;
    }

    if (newValue.length > currentValue.length) {
      return {
        newStart: insert.l_start,
        newEnd: insert.l_end,
        type: 'add'
      };
    } else {
      return {
        newStart: insert.s_start,
        newEnd: insert.s_end,
        type: newValue.length < currentValue.length ? 'remove' : 'replace'
      };
    }
  }

  /**
   * Utility method for creating a new selection range {start, end} object.
   *
   * @param {Number} start
   * @param {Number} [end]
   *
   * @return {Object} selection range as {start, end}
   */
  function range(start, end) {
    return {
      start: start,
      end: end === undefined ? start : end
    };
  }

  var range_1 = range;
  selectionUpdate.range = range_1;

  var _typeof$31 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$36 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$44(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$20(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$31(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$20(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$31(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  /**
   * A content ediable that performs proper selection updates on
   * editable changes. It normalizes editor operations by allowing
   * only <br/> and plain text to be inserted.
   *
   * The callback `onInput(text)` recieves text (including line breaks)
   * only. Updating the value via props will update the selection
   * if needed, too.
   *
   * @example
   *
   * class SomeComponent extends Component {
   *
   *   render() {
   *     return (
   *       <ContentEditable
   *         className="some classes"
   *         value={ this.state.text }
   *         onInput={ this.handleInput }
   *         onFocus={ ... }
   *         onBlur={ ... } />
   *     );
   *   }
   *
   * }
   *
   */

  var ContentEditable = function (_Component) {
    _inherits$20(ContentEditable, _Component);

    function ContentEditable(props, context) {
      _classCallCheck$44(this, ContentEditable);

      var _this = _possibleConstructorReturn$20(this, (ContentEditable.__proto__ || Object.getPrototypeOf(ContentEditable)).call(this, props, context));

      _this.onFocus = function () {
        var propsFocus = _this.props.onFocus;

        _this.setState({
          focussed: true
        });

        if (typeof propsFocus === 'function') {
          propsFocus();
        }
      };

      _this.onBlur = function () {
        var propsBlur = _this.props.onBlur;

        _this.setState({
          focussed: false
        });

        if (typeof propsBlur === 'function') {
          propsBlur();
        }
      };

      _this.onKeydown = function (event) {
        // enter
        if (event.which === 13) {

          // prevent default action (<br/> insert)
          event.preventDefault();

          if (_this.props.ctrlForNewline && !isCmd$1(event)) {
            return;
          }

          event.stopPropagation();

          insertLineBreak();

          _this.onInput(event);
        }
      };

      _this.onInput = function (event) {

        var propsInput = _this.props.onInput;

        if (typeof propsInput !== 'function') {
          return;
        }

        var text = innerText(_this.node);

        propsInput(text);
      };

      _this.onPaste = noop$1;
      _this.onKeypress = noop$1;

      _this.state = {};

      // TODO(nikku): remove once we drop IE 11 support
      if (isIE()) {

        // onInput shim for IE <= 11
        _this.onPaste = _this.onKeypress = function (event) {

          var oldText = _this.node.innerHTML;

          setTimeout(function () {

            var text = _this.node.innerHTML;
            if (oldText !== text) {
              _this.onInput(event);
            }
          }, 0);
        };
      }
      return _this;
    }

    _createClass$36(ContentEditable, [{
      key: 'componentWillUpdate',
      value: function componentWillUpdate(newProps, newState) {

        // save old selection + text for later
        var node = this.node;

        var range = newState.focussed && getRange(node);

        this.selected = range && {
          range: range,
          text: innerText(node)
        };
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {

        var selected = this.selected;

        if (!selected) {
          return;
        }

        // compute and restore selection based on
        // (possibly new) text

        var range = selected.range;
        var text = selected.text;

        var node = this.node;

        var newText = innerText(node);

        var newRange = newText !== text ? selectionUpdate(range, text, newText) : range;

        setRange(node, newRange);
      }

      // stubs for modern browsers; actual implementation
      // for IE 11 to polyfill missing <input> event on [contentediable]

    }, {
      key: 'render',
      value: function render$$1(props) {
        var _this2 = this;

        var value = props.value,
            className = props.className;

        // QUIRK: must add trailing <br/> for line
        // breaks to properly work

        value = escapeHtml_1(value).replace(/\r?\n/g, '<br/>') + '<br/>';

        return createVNode(1, 'div', [className || '', 'content-editable'].join(' '), null, 1, {
          'contentEditable': 'true',
          'spellcheck': 'false',
          'onInput': this.onInput,
          'onKeypress': this.onKeypress,
          'onPaste': this.onPaste,
          'onFocus': this.onFocus,
          'onBlur': this.onBlur,
          'onKeydown': this.onKeydown,
          'dangerouslySetInnerHTML': { __html: value }
        }, null, function (node) {
          return _this2.node = node;
        });
      }
    }]);

    return ContentEditable;
  }(Component);

  function brTag() {
    return document.createElement('br');
  }

  function innerText(node) {
    // QUIRK: we must remove the last trailing <br/>, if any
    return node.innerText.replace(/\n$/, '');
  }

  function insertLineBreak() {

    // insert line break at current insertation
    // point; this assumes that the correct element, i.e.
    // a <ContentEditable /> is currently focussed
    var selection = getWindowSelection();

    var range = selection.getRangeAt(0);

    if (!range) {
      return;
    }

    var newRange = range.cloneRange();

    var br = brTag();

    newRange.deleteContents();

    newRange.insertNode(br);

    newRange.setStartAfter(br);
    newRange.setEndAfter(br);

    applyRange(newRange);
  }

  function noop$1() {}

  function isIE() {
    var ua = window.navigator.userAgent;

    return (
      // IE 10 or older
      ua.indexOf('MSIE ') > 0 ||
      // IE 11
      ua.indexOf('Trident/') > 0
    );
  }

  function isCmd$1(event) {
    return event.metaKey || event.ctrlKey;
  }

  var _typeof$32 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$37 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$45(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$21(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$32(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$21(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$32(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  /**
   * A base component for interactivity.
   *
   * @example
   *
   * class Foo extends EditableComponent {
   *
   *   render() {
   *     return (
   *       <div>{ this.getEditor() }</div>
   *     );
   *   }
   * }
   *
   * And in use:
   *
   * <Foo value={ blub }
   *      onChange={ (newValue) => { ... }
   *      onFocus={ () => { ... } }
   *      onBlur={ () => { ... } }
   *      validate={ (newValue) => { return 'some-error'; } }
   *      className="..." } />
   *
   * Special classes added:
   *
   * * focused
   * * invalid
   *
   */

  var EditableComponent = function (_Component) {
    _inherits$21(EditableComponent, _Component);

    function EditableComponent(props, context) {
      _classCallCheck$45(this, EditableComponent);

      var _this = _possibleConstructorReturn$21(this, (EditableComponent.__proto__ || Object.getPrototypeOf(EditableComponent)).call(this, props, context));

      _this.onFocus = function () {
        _this.setState({
          focussed: true
        });

        var onFocus = _this.props.onFocus;

        if (typeof onFocus === 'function') {
          onFocus();
        }
      };

      _this.onBlur = function (property) {
        _this.setState({
          focussed: false
        });

        var invalid = _this.state.invalid;

        if (invalid) {
          _this.setState({
            changing: false,
            invalid: false
          });
        }

        var onBlur = _this.props.onBlur;

        if (typeof onBlur === 'function') {
          onBlur();
        }
      };

      _this.state = {
        changing: false,
        focussed: false
      };

      var injector = context.injector;

      var debounceInput = injector.get('debounceInput');

      _this.inputChanged = debounceInput(function (value) {
        var onChange = _this.props.onChange;

        if (typeof onChange === 'function') {
          onChange(value);
        }

        // only unset changed if user input and
        // committed changed value equal. This prevents the
        // input jumping back to the saved, good value.
        var currentValue = _this.state.changing;

        _this.setState({
          changing: currentValue === value ? false : currentValue
        });
      });

      _this.onInput = function (value) {

        var validate = _this.props.validate || function () {};

        var invalid = validate(value);

        _this.setState({
          changing: value,
          invalid: invalid
        });

        if (!invalid) {
          _this.inputChanged(value);
        }
      };
      return _this;
    }

    _createClass$37(EditableComponent, [{
      key: 'getClassName',
      value: function getClassName() {
        var className = this.props.className;
        var _state = this.state,
            focussed = _state.focussed,
            invalid = _state.invalid;

        className += ' editable';

        if (focussed) {
          className += ' focussed';
        }

        if (invalid) {
          className += ' invalid';
        }

        return className;
      }
    }, {
      key: 'getDisplayValue',
      value: function getDisplayValue() {
        var value = this.props.value;
        var _state2 = this.state,
            focussed = _state2.focussed,
            changing = _state2.changing;

        if (typeof changing === 'string') {
          value = changing;
        }

        if (!value) {
          value = focussed ? '' : '-';
        }

        return value;
      }
    }, {
      key: 'getEditor',
      value: function getEditor() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        return createComponentVNode(2, ContentEditable, {
          'className': props.className,
          'ctrlForNewline': props.ctrlForNewline,
          'onFocus': this.onFocus,
          'onBlur': this.onBlur,
          'onInput': this.onInput,
          'value': this.getDisplayValue()
        });
      }
    }]);

    return EditableComponent;
  }(Component);

  var _typeof$33 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$38 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$46(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$22(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$33(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$22(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$33(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var EditableAnnotationCell = function (_Component) {
    _inherits$22(EditableAnnotationCell, _Component);

    function EditableAnnotationCell(props, context) {
      _classCallCheck$46(this, EditableAnnotationCell);

      var _this = _possibleConstructorReturn$22(this, (EditableAnnotationCell.__proto__ || Object.getPrototypeOf(EditableAnnotationCell)).call(this, props, context));

      _this.onElementsChanged = function () {
        _this.forceUpdate();
      };

      _this.setAnnotationValue = function (text) {
        var row = _this.props.row;

        _this.modeling.editAnnotation(row.businessObject, text);
      };

      inject(_this);
      return _this;
    }

    _createClass$38(EditableAnnotationCell, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        var row = this.props.row;

        this.changeSupport.onElementsChanged(row.id, this.onElementsChanged);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        var row = this.props.row;

        this.changeSupport.offElementsChanged(row.id, this.onElementsChanged);
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _props = this.props,
            row = _props.row,
            rowIndex = _props.rowIndex;
        var _row$businessObject = row.businessObject,
            description = _row$businessObject.description,
            id = _row$businessObject.id;

        return createComponentVNode(2, HeaderCell, {
          'className': 'annotation',
          'onChange': this.setAnnotationValue,
          'coords': rowIndex + ':annotation',
          'value': description,
          'elementId': id + '__annotation',
          'data-row-id': row.id,
          children: createComponentVNode(2, AnnotationEditor, {
            'ctrlForNewline': true,
            'className': 'annotation-editor',
            'onChange': this.setAnnotationValue,
            'value': description
          })
        });
      }
    }]);

    return EditableAnnotationCell;
  }(Component);

  EditableAnnotationCell.$inject = ['changeSupport', 'modeling'];

  var AnnotationEditor = function (_EditableComponent) {
    _inherits$22(AnnotationEditor, _EditableComponent);

    function AnnotationEditor() {
      _classCallCheck$46(this, AnnotationEditor);

      return _possibleConstructorReturn$22(this, (AnnotationEditor.__proto__ || Object.getPrototypeOf(AnnotationEditor)).apply(this, arguments));
    }

    _createClass$38(AnnotationEditor, [{
      key: 'render',
      value: function render$$1() {
        return createVNode(1, 'div', this.getClassName(), this.getEditor(), 0);
      }
    }]);

    return AnnotationEditor;
  }(EditableComponent);

  function AnnotationsEditingProvider(components) {

    components.onGetComponent('cell', function (_ref) {
      var cellType = _ref.cellType;

      if (cellType === 'after-label-cells') {
        return AnnotationHeader;
      } else if (cellType === 'after-rule-cells') {
        return EditableAnnotationCell;
      }
    });
  }

  AnnotationsEditingProvider.$inject = ['components'];

  var DEFAULT_DEBOUNCE_TIME = 300;

  function debounceInput(shouldDebounce) {
    return function _debounceInput(fn) {
      if (shouldDebounce !== false) {

        var debounceTime = isNumber(shouldDebounce) ? shouldDebounce : DEFAULT_DEBOUNCE_TIME;

        return debounce(fn, debounceTime);
      } else {
        return fn;
      }
    };
  }

  debounceInput.$inject = ['config.debounceInput'];

  var DebounceInput = {
    debounceInput: ['factory', debounceInput]
  };

  var annotationsEditorModule = {
    __depends__: [DebounceInput],
    __init__: ['annotationsProvider'],
    annotationsProvider: ['type', AnnotationsEditingProvider]
  };

  var _typeof$34 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$39 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$47(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$23(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$34(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$23(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$34(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ContextMenuComponent = function (_Component) {
    _inherits$23(ContextMenuComponent, _Component);

    function ContextMenuComponent(props, context) {
      _classCallCheck$47(this, ContextMenuComponent);

      var _this = _possibleConstructorReturn$23(this, (ContextMenuComponent.__proto__ || Object.getPrototypeOf(ContextMenuComponent)).call(this, props, context));

      _initialiseProps.call(_this);

      _this.state = {
        isOpen: false,
        position: {
          x: 0,
          y: 0
        }
      };

      inject(_this);
      return _this;
    }

    /**
     * Open the context menu with given position and context.
     *
     * The menu itself will figure out the best position, taking the optional
     * positioning parameter into account.
     *
     * @param {Bounds|Point} position
     * @param {Object} [context]
     */

    /**
     * Closes context menu and resets state.
     */

    _createClass$39(ContextMenuComponent, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.eventBus.on('contextMenu.open', this.open);
        this.eventBus.on('contextMenu.close', this.close);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this.eventBus.off('contextMenu.open', this.open);
        this.eventBus.off('contextMenu.close', this.close);
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _state = this.state,
            isOpen = _state.isOpen,
            context = _state.context,
            position = _state.position;

        if (!isOpen) {
          return null;
        }

        var components = this.components.getComponents('context-menu', context);

        if (!components.length) {
          return null;
        }

        return createComponentVNode(2, ContextMenu, {
          'className': 'context-menu no-deselect',
          'context': context,
          'position': position,
          'offset': context.offset || { x: 0, y: 0 },
          'autoFocus': context.autoFocus !== false,
          'autoClose': context.autoClose !== false,
          'components': components,
          'onClose': this.triggerClose
        });
      }
    }]);

    return ContextMenuComponent;
  }(Component);

  var _initialiseProps = function _initialiseProps() {
    var _this2 = this;

    this.open = function (_ref) {
      var position = _ref.position,
          context = _ref.context;

      // always close first
      _this2.close();

      _this2.setState({
        isOpen: true,
        position: position || { x: 0, y: 0 },
        context: context || {}
      });
    };

    this.close = function () {

      if (_this2.state.isOpen) {
        _this2.setState({
          context: undefined,
          isOpen: false,
          position: {
            x: 0,
            y: 0
          }
        });
      }
    };

    this.triggerClose = function () {
      _this2.eventBus.fire('contextMenu.close');
    };
  };

  ContextMenuComponent.$inject = ['eventBus', 'components'];

  /**
   * Low-level, stateless context menu holder.
   */

  var ContextMenu = function (_Component2) {
    _inherits$23(ContextMenu, _Component2);

    function ContextMenu(props, context) {
      _classCallCheck$47(this, ContextMenu);

      var _this3 = _possibleConstructorReturn$23(this, (ContextMenu.__proto__ || Object.getPrototypeOf(ContextMenu)).call(this, props, context));

      _this3.onGlobalClick = function (event) {
        _this3.checkClose(event.target);
      };

      _this3.onGlobalKey = function (event) {

        var keyCode = event.which;

        // ENTER or ESC
        if (keyCode === 13 || keyCode === 27) {
          event.stopPropagation();
          event.preventDefault();

          _this3.close();
        }
      };

      _this3.onFocusChanged = function (event) {
        _this3.checkClose(event.target);
      };

      _this3.setNode = function (node) {
        _this3.node = node;

        var autoFocus = _this3.props.autoFocus;

        if (node) {

          if (autoFocus) {
            ensureFocus$1(node);
          }

          _this3.updatePosition();
        }
      };

      inject(_this3);
      return _this3;
    }

    _createClass$39(ContextMenu, [{
      key: 'close',
      value: function close() {
        var onClose = this.props.onClose;

        if (isFunction(onClose)) {
          onClose();
        }
      }

      /**
       * Check whether closing the context menu is necessary
       * after selecting the given element.
       */

    }, {
      key: 'checkClose',
      value: function checkClose(focusTarget) {
        var autoClose = this.props.autoClose;

        if (!autoClose) {
          return;
        }

        var node = this.node;

        if (!node) {
          return;
        }

        if (node === focusTarget) {
          return;
        }

        if (node.contains(focusTarget)) {
          return;
        }

        this.close();
      }

      /**
       * Handle global (window) click event.
       */

      /**
       * Handle global key event.
       */

      /**
       * Handle global (document) focus changed event.
       */

    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        document.addEventListener('focusin', this.onFocusChanged);
        document.addEventListener('keydown', this.onGlobalKey);
        document.addEventListener('click', this.onGlobalClick);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        document.removeEventListener('focusin', this.onFocusChanged);
        document.removeEventListener('keydown', this.onGlobalKey);
        document.removeEventListener('click', this.onGlobalClick);
      }
    }, {
      key: 'updatePosition',

      /**
       * Find best context menu position and re-layout accordingly.
       */
      value: function updatePosition() {
        var _props = this.props,
            position = _props.position,
            offset = _props.offset;

        var bounds = this.node.getBoundingClientRect();

        if (!position.width) {
          position.width = 0;
        }

        if (!position.height) {
          position.height = 0;
        }

        var container = this.renderer.getContainer();

        var containerBounds = container.getBoundingClientRect();

        if (containerBounds.width > containerBounds.height) {
          this.node.classList.add('horizontal');
          this.node.classList.remove('vertical');
        } else {
          this.node.classList.add('vertical');
          this.node.classList.remove('horizontal');
        }

        var scrollLeft = container.scrollLeft,
            scrollTop = container.scrollTop;

        var style = {};

        if (position.x + position.width / 2 > containerBounds.width / 2) {
          var left = position.x - containerBounds.left - bounds.width + offset.x + scrollLeft;

          left = clampNumber(left, 0 + scrollLeft, containerBounds.width - bounds.width + scrollLeft);

          style.left = left + 'px';
        } else {
          var _left = window.scrollX - containerBounds.left + position.x + position.width - offset.x + scrollLeft;

          _left = clampNumber(_left, 0 + scrollLeft, containerBounds.width - bounds.width + scrollLeft);

          style.left = _left + 'px';
        }

        var top = void 0;

        if (position.y + position.height / 2 > containerBounds.height / 2) {
          top = position.y - containerBounds.top - bounds.height + offset.y + scrollTop;

          top = clampNumber(top, 0 + scrollTop, containerBounds.height - bounds.height + scrollTop);

          style.top = top + 'px';
        } else {
          top = window.scrollY - containerBounds.top + position.y - offset.y + scrollTop;

          top = clampNumber(top, 0 + scrollTop, containerBounds.height - bounds.height + scrollTop);

          style.top = top + 'px';
        }

        // ensure context menu will always be accessible
        style.overflowY = 'auto';
        style.maxHeight = containerBounds.height - top + scrollTop + 'px';

        assign(this.node.style, style);
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _props2 = this.props,
            context = _props2.context,
            components = _props2.components,
            className = _props2.className;

        return createVNode(1, 'div', className, components.map(function (Component$$1, idx) {
          return createComponentVNode(2, Component$$1, {
            'context': context
          }, idx);
        }), 0, {
          'onContextMenu': function onContextMenu(e) {
            return e.preventDefault();
          }
        }, null, this.setNode);
      }
    }]);

    return ContextMenu;
  }(Component);

  ContextMenu.$inject = ['renderer'];

  // helpers /////////////

  function clampNumber(number, min, max) {
    return Math.max(min, Math.min(max, number));
  }

  var SELECTABLE_ELEMENTS = '\n  input[type=text],\n  input[type=number],\n  input[type=button],\n  input[type=submit],\n  [contenteditable],\n  [tabindex],\n  a[href],\n  textarea,\n  button\n';

  function ensureFocus$1(el) {

    var focusEl = query(SELECTABLE_ELEMENTS, el);

    if (focusEl) {
      focusEl.focus();

      // inputs
      if (focusEl.selectionStart && focusEl.type === 'text') {
        focusEl.selectionStart = 100000;
      } else

        // content editable elements
        if ('contentEditable' in focusEl) {
          setRange(focusEl, { start: 100000, end: 100000 });
        }
    }
  }

  var _createClass$40 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$48(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var ContextMenu$1 = function () {
    function ContextMenu(components, eventBus, renderer) {
      _classCallCheck$48(this, ContextMenu);

      this._eventBus = eventBus;

      components.onGetComponent('table.before', function () {
        return ContextMenuComponent;
      });
    }

    _createClass$40(ContextMenu, [{
      key: 'open',
      value: function open(position, context) {
        this._eventBus.fire('contextMenu.open', {
          position: position,
          context: context
        });
      }
    }, {
      key: 'close',
      value: function close() {
        this._eventBus.fire('contextMenu.close');
      }
    }]);

    return ContextMenu;
  }();

  ContextMenu$1.$inject = ['components', 'eventBus', 'renderer'];

  var ContextMenu$2 = {
    __init__: ['contextMenu'],
    contextMenu: ['type', ContextMenu$1]
  };

  function isCmd$2(modifiers) {
    // ensure we don't react to AltGr
    // (mapped to CTRL + ALT)
    if (modifiers.altKey) {
      return false;
    }

    return modifiers.ctrlKey || modifiers.metaKey;
  }

  function isShift$1(modifiers) {
    return modifiers.shiftKey;
  }

  var _createClass$41 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$49(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * Keybindings for Copy + Paste
   */

  var CopyPasteKeyBindings = function () {
    function CopyPasteKeyBindings(injector, eventBus, clipboard, cellSelection, elementRegistry, editorActions, renderer) {
      var _this = this;

      _classCallCheck$49(this, CopyPasteKeyBindings);

      this._clearClipboard = function () {
        _this._clipboard.clear();
      };

      this._registerBindings = function () {

        // copy
        // CTRL/CMD + C
        var copy = function copy(key, modifiers) {

          if (isCmd$2(modifiers) && key === 67) {
            var cell = _this._getSelectedCell();

            if (!cell) {
              return;
            }

            if (isShift$1(modifiers)) {
              _this._editorActions.trigger('copy', {
                element: cell.col
              });
            } else {
              _this._editorActions.trigger('copy', {
                element: cell.row
              });
            }

            return true;
          }
        };

        // cut
        // CTRL/CMD + X
        var cut = function cut(key, modifiers) {

          if (isCmd$2(modifiers) && key === 88) {

            var cell = _this._getSelectedCell();

            if (!cell) {
              return;
            }

            if (isShift$1(modifiers)) {
              _this._editorActions.trigger('cut', {
                element: cell.col
              });
            } else {
              _this._editorActions.trigger('cut', {
                element: cell.row
              });
            }

            return true;
          }
        };

        // paste
        // CTRL/CMD + V
        var paste = function paste(key, modifiers) {

          var pasted = void 0;

          if (isCmd$2(modifiers) && key === 86) {

            var cell = _this._getSelectedCell();

            if (!cell) {
              return;
            }

            if (isShift$1(modifiers)) {
              pasted = _this._editorActions.trigger('pasteAfter', {
                element: cell.col
              });

              if (pasted) {
                _this._cellSelection.selectCell('right');
              }
            } else {
              pasted = _this._editorActions.trigger('pasteAfter', {
                element: cell.row
              });

              if (pasted) {
                _this._cellSelection.selectCell('below');
              }
            }
          }

          // indicate, whether we could paste
          return typeof pasted !== 'undefined';
        };

        // register listeners
        [copy, cut, paste].forEach(function (l) {
          _this._keyboard.addListener(l);
        });
      };

      this._clipboard = clipboard;
      this._cellSelection = cellSelection;
      this._elementRegistry = elementRegistry;
      this._editorActions = editorActions;
      this._keyboard = injector.get('keyboard', false);
      this._renderer = renderer;

      if (!this._keyboard) {
        return;
      }

      eventBus.on('keyboard.init', this._registerBindings);

      eventBus.on('keyboard.bind', function () {
        componentEvent.bind(document, 'copy', _this._clearClipboard, true);
        componentEvent.bind(document, 'cut', _this._clearClipboard, true);
      });

      eventBus.on('keyboard.unbind', function () {
        componentEvent.unbind(document, 'copy', _this._clearClipboard, true);
        componentEvent.unbind(document, 'cut', _this._clearClipboard, true);
      });
    }

    _createClass$41(CopyPasteKeyBindings, [{
      key: '_getSelectedCell',

      /**
       * Return the selected cell within the decision table.
       *
       * This verifies that a cell ready for copy-or-paste is
       * actual selected by the user, in the Browser UI.
       *
       * @return {Cell}
       */
      value: function _getSelectedCell() {

        var elementId = this._cellSelection.getCellSelection();

        // we may have no selection
        if (!elementId) {
          return;
        }

        var cell = this._elementRegistry.get(elementId);

        // selection may not be a cell
        if (!cell) {
          return;
        }

        var container = this._renderer.getContainer();

        var node = getNodeById(elementId, container);

        var focusableNode = getFocusableNode(node);

        // focusable element in selection may not be actual
        // browser focus, i.e. when a menu is open
        if (document.activeElement !== focusableNode) {
          return;
        }

        var range = getRange(node);

        // user may attempt native copy-paste operation right now
        // don't interfere with normal text copying
        if (range && range.start !== range.end) {
          return;
        }

        return cell;
      }
    }]);

    return CopyPasteKeyBindings;
  }();

  CopyPasteKeyBindings.$inject = ['injector', 'eventBus', 'clipboard', 'cellSelection', 'elementRegistry', 'editorActions', 'renderer'];

  var copyCutPasteKeybindingsModule = {
    __depends__: [ClipboardModule, CellSelection$1],
    __init__: ['copyCutPasteKeyBindings'],
    copyCutPasteKeyBindings: ['type', CopyPasteKeyBindings]
  };

  var _typeof$35 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$42 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$50(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$24(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$35(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$24(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$35(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var CreateInputsHeaderCell = function (_Component) {
    _inherits$24(CreateInputsHeaderCell, _Component);

    function CreateInputsHeaderCell(props, context) {
      _classCallCheck$50(this, CreateInputsHeaderCell);

      var _this = _possibleConstructorReturn$24(this, (CreateInputsHeaderCell.__proto__ || Object.getPrototypeOf(CreateInputsHeaderCell)).call(this, props, context));

      _this.onClick = function (event) {
        _this.editorActions.trigger('addInput');
      };

      inject(_this);
      return _this;
    }

    _createClass$42(CreateInputsHeaderCell, [{
      key: 'render',
      value: function render$$1() {
        return createVNode(1, 'th', 'input-cell create-inputs header actionable', [createTextVNode('Input '), createVNode(1, 'span', 'add-input dmn-icon-plus action-icon', null, 1, {
          'title': 'Add Input'
        })], 4, {
          'onClick': this.onClick,
          'rowspan': '3',
          'title': 'Add Input'
        });
      }
    }]);

    return CreateInputsHeaderCell;
  }(Component);

  CreateInputsHeaderCell.$inject = ['editorActions'];

  var _typeof$36 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$43 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$51(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$25(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$36(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$25(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$36(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var CreateInputsCell = function (_Component) {
    _inherits$25(CreateInputsCell, _Component);

    function CreateInputsCell(props, context) {
      _classCallCheck$51(this, CreateInputsCell);

      var _this = _possibleConstructorReturn$25(this, (CreateInputsCell.__proto__ || Object.getPrototypeOf(CreateInputsCell)).call(this, props, context));

      _this.onClick = function (event) {
        _this.editorActions.trigger('addInput');
      };

      inject(_this);
      return _this;
    }

    _createClass$43(CreateInputsCell, [{
      key: 'render',
      value: function render$$1() {
        return createVNode(1, 'td', 'input-cell create-inputs', createTextVNode('-'), 2, {
          'onClick': this.onClick,
          'title': 'Add Input'
        });
      }
    }]);

    return CreateInputsCell;
  }(Component);

  CreateInputsCell.$inject = ['editorActions'];

  function _classCallCheck$52(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var LOW_PRIORITY$8 = 500;

  var CreateInputsProvider = function CreateInputsProvider(components, sheet) {
    _classCallCheck$52(this, CreateInputsProvider);

    components.onGetComponent('cell', LOW_PRIORITY$8, function (_ref) {
      var cellType = _ref.cellType;

      var _sheet$getRoot = sheet.getRoot(),
          businessObject = _sheet$getRoot.businessObject;

      if (businessObject.input && businessObject.input.length) {
        return;
      }

      if (cellType === 'before-label-cells') {
        return CreateInputsHeaderCell;
      } else if (cellType === 'before-rule-cells') {
        return CreateInputsCell;
      }
    });
  };

  CreateInputsProvider.$inject = ['components', 'sheet'];

  var createInputsModule = {
    __depends__: [EditorActions$3],
    __init__: ['createInputsProvider'],
    createInputsProvider: ['type', CreateInputsProvider]
  };

  var _createClass$44 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$53(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var ContextMenu$3 = function () {
    function ContextMenu(components, contextMenu, clipboard, editorActions, eventBus, elementRegistry, modeling, sheet, rules) {
      var _this = this;

      _classCallCheck$53(this, ContextMenu);

      this._contextMenu = contextMenu;
      this._clipboard = clipboard;
      this._editorActions = editorActions;
      this._elementRegistry = elementRegistry;
      this._eventBus = eventBus;
      this._modeling = modeling;
      this._sheet = sheet;
      this._rules = rules;

      this._getEntries = this._getEntries.bind(this);

      components.onGetComponent('context-menu', function () {
        var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (context.contextMenuType && context.contextMenuType === 'context-menu') {
          var entries = _this._getEntries(context);

          var element = _this._elementRegistry.get(context.id);

          var additionalCellEntries = isCell(element) && components.getComponents('context-menu-cell-additional', context);

          if (additionalCellEntries && additionalCellEntries.length) {
            var cellEntriesGroup = createVNode(1, 'div', 'context-menu-group context-menu-group-cell', [createVNode(1, 'h4', 'context-menu-group-title', createTextVNode('Cell'), 2), additionalCellEntries], 0);

            return function () {
              return createVNode(1, 'div', 'context-menu-flex', (entries || []).concat([cellEntriesGroup]), 0);
            };
          } else {
            return function () {
              return createVNode(1, 'div', 'context-menu-flex', entries || [], 0);
            };
          }
        }
      });

      eventBus.on('cell.contextmenu', function (_ref) {
        var event = _ref.event,
            id = _ref.id,
            node = _ref.node;

        event.preventDefault();

        contextMenu.open({
          x: event.pageX,
          y: event.pageY
        }, {
          contextMenuType: 'context-menu',
          id: id
        });
      });
    }

    _createClass$44(ContextMenu, [{
      key: '_getEntries',
      value: function _getEntries(context) {
        var _this2 = this;

        var handlers = {
          addRuleAbove: function addRuleAbove(rule) {
            _this2._editorActions.trigger('addRuleAbove', { rule: rule });

            _this2._contextMenu.close();
          },
          addRuleBelow: function addRuleBelow(rule) {
            _this2._editorActions.trigger('addRuleBelow', { rule: rule });

            _this2._contextMenu.close();
          },
          removeRule: function removeRule(rule) {
            _this2._editorActions.trigger('removeRule', { rule: rule });

            _this2._contextMenu.close();
          },
          addInputLeft: function addInputLeft(input) {
            _this2._editorActions.trigger('addInputLeft', { input: input });

            _this2._contextMenu.close();
          },
          addInputRight: function addInputRight(input) {
            _this2._editorActions.trigger('addInputRight', { input: input });

            _this2._contextMenu.close();
          },
          removeInput: function removeInput(input) {
            _this2._editorActions.trigger('removeInput', { input: input });

            _this2._contextMenu.close();
          },
          addOutputLeft: function addOutputLeft(output) {
            _this2._editorActions.trigger('addOutputLeft', { output: output });

            _this2._contextMenu.close();
          },
          addOutputRight: function addOutputRight(output) {
            _this2._editorActions.trigger('addOutputRight', { output: output });

            _this2._contextMenu.close();
          },
          removeOutput: function removeOutput(output) {
            _this2._editorActions.trigger('removeOutput', { output: output });

            _this2._contextMenu.close();
          },
          copy: function copy(element) {
            _this2._editorActions.trigger('copy', { element: element });

            _this2._contextMenu.close();
          },
          cut: function cut(element) {
            _this2._editorActions.trigger('cut', { element: element });

            _this2._contextMenu.close();
          },
          pasteBefore: function pasteBefore(element) {
            _this2._editorActions.trigger('pasteBefore', { element: element });

            _this2._contextMenu.close();
          },
          pasteAfter: function pasteAfter(element) {
            _this2._editorActions.trigger('pasteAfter', { element: element });

            _this2._contextMenu.close();
          }
        };

        var id = context && context.id;

        if (!id) {
          return null;
        }

        var element = this._elementRegistry.get(id);

        if (!element) {
          return null;
        }

        var clipboardData = this._clipboard.get() || {};

        var entries = [];

        if (is(element.row, 'dmn:DecisionRule')) {
          var canPaste = this._rules.allowed('paste', {
            data: clipboardData.elements,
            target: element.row
          });

          entries.push(createVNode(1, 'div', 'context-menu-group context-menu-group-rule', [createVNode(1, 'h4', 'context-menu-group-title', createTextVNode('Rule'), 2), createVNode(1, 'div', 'context-menu-group-entry context-menu-entry-add-rule-above', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-up'), createTextVNode('Add Above')], 4, {
            'onClick': function onClick() {
              return handlers.addRuleAbove(element.row);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry context-menu-entry-add-rule-below', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-down'), createTextVNode('Add Below')], 4, {
            'onClick': function onClick() {
              return handlers.addRuleBelow(element.row);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry context-menu-entry-remove-rule', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-clear'), createTextVNode('Remove')], 4, {
            'onClick': function onClick() {
              return handlers.removeRule(element.row);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry context-menu-entry-copy-rule', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-copy'), createTextVNode('Copy')], 4, {
            'onClick': function onClick() {
              return handlers.copy(element.row);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry context-menu-entry-cut-rule', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-cut'), createTextVNode('Cut')], 4, {
            'onClick': function onClick() {
              return handlers.cut(element.row);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry ' + (canPaste ? '' : 'disabled') + ' context-menu-entry-paste-rule-above', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-paste'), createTextVNode('Paste Above')], 4, {
            'onClick': function onClick() {
              return handlers.pasteBefore(element.row);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry ' + (canPaste ? '' : 'disabled') + ' context-menu-entry-paste-rule-below', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-paste'), createTextVNode('Paste Below')], 4, {
            'onClick': function onClick() {
              return handlers.pasteAfter(element.row);
            }
          })], 4));
        }

        if (is(element, 'dmn:InputClause') || is(element.col, 'dmn:InputClause')) {
          var actualElement = is(element, 'dmn:InputClause') ? element : element.col;

          var canRemove = this._rules.allowed('col.remove', {
            col: element.col || element
          });

          var _canPaste = this._rules.allowed('paste', {
            data: clipboardData.elements,
            target: element.col || element
          });

          entries.push(createVNode(1, 'div', 'context-menu-group context-menu-group-input', [createVNode(1, 'h4', 'context-menu-group-title', createTextVNode('Input'), 2), createVNode(1, 'div', 'context-menu-group-entry context-menu-entry-add-input-left', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-left'), createTextVNode('Add Left')], 4, {
            'onClick': function onClick() {
              return handlers.addInputLeft(actualElement);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry context-menu-entry-add-input-right', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-right'), createTextVNode('Add Right')], 4, {
            'onClick': function onClick() {
              return handlers.addInputRight(actualElement);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry ' + (canRemove ? '' : 'disabled') + ' context-menu-entry-remove-input', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-clear'), createTextVNode('Remove')], 4, {
            'onClick': function onClick() {
              return handlers.removeInput(actualElement);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry context-menu-entry-copy-input', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-copy'), createTextVNode('Copy')], 4, {
            'onClick': function onClick() {
              return handlers.copy(actualElement);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry ' + (canRemove ? '' : 'disabled') + ' context-menu-entry-cut-input', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-cut'), createTextVNode('Cut')], 4, {
            'onClick': function onClick() {
              return handlers.cut(actualElement);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry ' + (_canPaste ? '' : 'disabled') + ' context-menu-entry-paste-input-left', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-paste'), createTextVNode('Paste Left')], 4, {
            'onClick': function onClick() {
              return handlers.pasteBefore(actualElement);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry ' + (_canPaste ? '' : 'disabled') + ' context-menu-entry-paste-input-right', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-paste'), createTextVNode('Paste Right')], 4, {
            'onClick': function onClick() {
              return handlers.pasteAfter(actualElement);
            }
          })], 4));
        } else if (is(element, 'dmn:OutputClause') || is(element.col, 'dmn:OutputClause')) {
          var _actualElement = is(element, 'dmn:OutputClause') ? element : element.col;

          var _canRemove = this._rules.allowed('col.remove', {
            col: element.col || element
          });

          var _canPaste2 = this._rules.allowed('paste', {
            data: clipboardData.elements,
            target: element.col || element
          });

          entries.push(createVNode(1, 'div', 'context-menu-group context-menu-group-output', [createVNode(1, 'h4', 'context-menu-group-title', createTextVNode('Output'), 2), createVNode(1, 'div', 'context-menu-group-entry context-menu-entry-add-output-left', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-left'), createTextVNode('Add Left')], 4, {
            'onClick': function onClick() {
              return handlers.addOutputLeft(_actualElement);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry context-menu-entry-add-output-right', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-right'), createTextVNode('Add Right')], 4, {
            'onClick': function onClick() {
              return handlers.addOutputRight(_actualElement);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry ' + (_canRemove ? '' : 'disabled') + ' context-menu-entry-remove-output', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-clear'), createTextVNode('Remove')], 4, {
            'onClick': function onClick() {
              return handlers.removeOutput(_actualElement);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry context-menu-entry-copy-output', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-copy'), createTextVNode('Copy')], 4, {
            'onClick': function onClick() {
              return handlers.copy(_actualElement);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry ' + (_canRemove ? '' : 'disabled') + ' context-menu-entry-cut-output', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-cut'), createTextVNode('Cut')], 4, {
            'onClick': function onClick() {
              return handlers.cut(_actualElement);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry ' + (_canPaste2 ? '' : 'disabled') + ' context-menu-entry-paste-output-left', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-paste'), createTextVNode('Paste Left')], 4, {
            'onClick': function onClick() {
              return handlers.pasteBefore(_actualElement);
            }
          }), createVNode(1, 'div', 'context-menu-group-entry ' + (_canPaste2 ? '' : 'disabled') + ' context-menu-entry-paste-output-right', [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-paste'), createTextVNode('Paste Right')], 4, {
            'onClick': function onClick() {
              return handlers.pasteAfter(_actualElement);
            }
          })], 4));
        }

        return entries;
      }
    }]);

    return ContextMenu;
  }();

  ContextMenu$3.$inject = ['components', 'contextMenu', 'clipboard', 'editorActions', 'eventBus', 'elementRegistry', 'modeling', 'sheet', 'rules'];

  // helpers ///////////

  function isCell(element) {
    return element instanceof Cell;
  }

  function _classCallCheck$54(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var COMMANDS = ['row.add', 'row.remove', 'col.add', 'col.remove'];

  var ContextMenuCloseBehavior = function ContextMenuCloseBehavior(contextMenu, eventBus) {
    _classCallCheck$54(this, ContextMenuCloseBehavior);

    eventBus.on('commandStack.executed', function (_ref) {
      var command = _ref.command;

      // close on certain modeling operations
      if (COMMANDS.indexOf(command) !== -1) {
        contextMenu.close();
      }
    });

    // always close on undo
    eventBus.on('commandStack.reverted', function () {
      contextMenu.close();
    });
  };

  ContextMenuCloseBehavior.$inject = ['contextMenu', 'eventBus'];

  var decisionTableContextMenu = {
    __depends__: [EditorActions$3, ContextMenu$2, Rules$6],
    __init__: ['decisionTableContextMenu', 'contextMenuCloseBehavior'],
    decisionTableContextMenu: ['type', ContextMenu$3],
    contextMenuCloseBehavior: ['type', ContextMenuCloseBehavior]
  };

  var _typeof$37 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$45 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$55(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$26(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$37(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$26(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$37(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var OutputCell = function (_Component) {
    _inherits$26(OutputCell, _Component);

    function OutputCell(props, context) {
      _classCallCheck$55(this, OutputCell);

      var _this = _possibleConstructorReturn$26(this, (OutputCell.__proto__ || Object.getPrototypeOf(OutputCell)).call(this, props, context));

      _this.onClick = function (event) {
        var output = _this.props.output;

        _this._eventBus.fire('output.edit', {
          event: event,
          output: output
        });
      };

      _this.onContextmenu = function (event) {
        var id = _this.props.output.id;

        _this._eventBus.fire('cell.contextmenu', {
          event: event,
          id: id
        });
      };

      _this.onElementsChanged = function () {
        _this.forceUpdate();
      };

      mixin(_this, ComponentWithSlots);
      return _this;
    }

    _createClass$45(OutputCell, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        var injector = this.context.injector;

        this._changeSupport = this.context.changeSupport;
        this._eventBus = injector.get('eventBus');
        this._elementRegistry = injector.get('elementRegistry');

        var output = this.props.output;

        this._changeSupport.onElementsChanged(output.id, this.onElementsChanged);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        var output = this.props.output;

        this._changeSupport.offElementsChanged(output.id, this.onElementsChanged);
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var output = this.props.output;

        var label = output.get('label');
        var name = output.get('name');

        return createVNode(1, 'th', 'output-cell output-editor', [this.slotFills({
          type: 'cell-inner',
          context: {
            cellType: 'output-cell',
            col: this._elementRegistry.get(output.id)
          },
          col: output
        }), label ? createVNode(1, 'span', 'output-label', label, 0, {
          'title': 'Output Label'
        }) : createVNode(1, 'span', 'output-name', name || '-', 0, {
          'title': 'Output Expression'
        })], 0, {
          'data-col-id': output.id,
          'onClick': this.onClick,
          'onContextmenu': this.onContextmenu
        });
      }
    }]);

    return OutputCell;
  }(Component);

  var _typeof$38 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$46 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$56(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$27(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$38(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$27(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$38(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var Input = function (_Component) {
    _inherits$27(Input, _Component);

    function Input(props, context) {
      _classCallCheck$56(this, Input);

      var _this = _possibleConstructorReturn$27(this, (Input.__proto__ || Object.getPrototypeOf(Input)).call(this, props, context));

      _this.onInput = function (event) {
        var onInput = _this.props.onInput;

        if (typeof onInput !== 'function') {
          return;
        }

        onInput(event.target.value);
      };

      _this.onKeyDown = function (event) {
        var onKeyDown = _this.props.onKeyDown;

        if (typeof onKeyDown !== 'function') {
          return;
        }

        onKeyDown(event);
      };

      _this.onKeyUp = function (event) {
        var onKeyUp = _this.props.onKeyUp;

        if (typeof onKeyUp !== 'function') {
          return;
        }

        onKeyUp(event);
      };

      return _this;
    }

    _createClass$46(Input, [{
      key: 'render',
      value: function render$$1() {
        var _props = this.props,
            className = _props.className,
            placeholder = _props.placeholder,
            type = _props.type,
            value = _props.value;

        return createVNode(64, 'input', [className || '', 'dms-input'].join(' '), null, 1, {
          'placeholder': placeholder || '',
          'onInput': this.onInput,
          'onKeyDown': this.onKeyDown,
          'onKeyUp': this.onKeyUp,
          'spellcheck': 'false',
          'type': type || 'text',
          'value': value
        });
      }
    }]);

    return Input;
  }(Component);

  var _typeof$39 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$47 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$57(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$28(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$39(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$28(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$39(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var OutputEditor = function (_Component) {
    _inherits$28(OutputEditor, _Component);

    function OutputEditor(props, context) {
      _classCallCheck$57(this, OutputEditor);

      var _this = _possibleConstructorReturn$28(this, (OutputEditor.__proto__ || Object.getPrototypeOf(OutputEditor)).call(this, props, context));

      _this.setName = function (name) {
        name = name || undefined;

        _this.handleChange({ name: name });
      };

      _this.setLabel = function (label) {
        label = label || undefined;

        _this.handleChange({ label: label });
      };
      return _this;
    }

    _createClass$47(OutputEditor, [{
      key: 'handleChange',
      value: function handleChange(changes) {
        var onChange = this.props.onChange;

        if (typeof onChange === 'function') {
          onChange(changes);
        }
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _props = this.props,
            name = _props.name,
            label = _props.label;

        return createVNode(1, 'div', 'dms-container ref-output-editor', [createVNode(1, 'p', 'dms-fill-row', [createVNode(1, 'label', 'dms-label', createTextVNode('Output Name'), 2), createComponentVNode(2, Input, {
          'className': 'ref-output-name',
          'value': name || '',
          'onInput': this.setName
        })], 4), createVNode(1, 'p', 'dms-fill-row', [createVNode(1, 'label', 'dms-label', createTextVNode('Output Label'), 2), createComponentVNode(2, Input, {
          'className': 'ref-output-label',
          'value': label || '',
          'onInput': this.setLabel
        })], 4)], 4);
      }
    }]);

    return OutputEditor;
  }(Component);

  var _typeof$40 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _extends$10 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass$48 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$58(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$29(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$40(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$29(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$40(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var OutputCellContextMenu = function (_Component) {
    _inherits$29(OutputCellContextMenu, _Component);

    function OutputCellContextMenu(props, context) {
      _classCallCheck$58(this, OutputCellContextMenu);

      var _this = _possibleConstructorReturn$29(this, (OutputCellContextMenu.__proto__ || Object.getPrototypeOf(OutputCellContextMenu)).call(this, props, context));

      _this.persistChanges = function () {
        var output = _this.props.context.output;
        var unsaved = _this.state.unsaved;

        if (!unsaved) {
          return;
        }

        _this.modeling.updateProperties(output, unsaved);

        _this.setState({
          unsaved: false
        });
      };

      _this.handleChange = function (changes) {
        _this.setState({
          unsaved: _extends$10({}, _this.state.unsaved, changes)
        }, _this.persistChanges);
      };

      _this.state = {};

      inject(_this);

      _this.persistChanges = _this.debounceInput(_this.persistChanges);
      return _this;
    }

    _createClass$48(OutputCellContextMenu, [{
      key: 'getValue',
      value: function getValue(attr) {
        var output = this.props.context.output;
        var unsaved = this.state.unsaved;

        return unsaved && unsaved[attr] || output.get(attr);
      }
    }, {
      key: 'render',
      value: function render$$1() {
        return createVNode(1, 'div', 'context-menu-container output-edit', createComponentVNode(2, OutputEditor, {
          'name': this.getValue('name'),
          'label': this.getValue('label'),
          'onChange': this.handleChange
        }), 2);
      }
    }]);

    return OutputCellContextMenu;
  }(Component);

  OutputCellContextMenu.$inject = ['debounceInput', 'modeling'];

  function _classCallCheck$59(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var OutputEditingProvider = function OutputEditingProvider(components, contextMenu, eventBus, renderer) {
    _classCallCheck$59(this, OutputEditingProvider);

    components.onGetComponent('cell', function (_ref) {
      var cellType = _ref.cellType;

      if (cellType === 'output-header') {
        return OutputCell;
      }
    });

    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (context.contextMenuType === 'output-edit') {
        return OutputCellContextMenu;
      }
    });

    eventBus.on('output.edit', function (_ref2) {
      var event = _ref2.event,
          output = _ref2.output;
      var target = event.target;

      var node = closest(target, 'th', true);

      var _node$getBoundingClie = node.getBoundingClientRect(),
          left = _node$getBoundingClie.left,
          top = _node$getBoundingClie.top,
          width = _node$getBoundingClie.width,
          height = _node$getBoundingClie.height;

      var container = renderer.getContainer();

      contextMenu.open({
        x: left + container.parentNode.scrollLeft,
        y: top + container.parentNode.scrollTop,
        width: width,
        height: height
      }, {
        contextMenuType: 'output-edit',
        output: output,
        offset: {
          x: 4,
          y: 4
        }
      });
    });
  };

  OutputEditingProvider.$inject = ['components', 'contextMenu', 'eventBus', 'renderer'];

  var _typeof$41 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$49 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$60(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$30(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$41(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$30(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$41(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var InputCell = function (_Component) {
    _inherits$30(InputCell, _Component);

    function InputCell(props, context) {
      _classCallCheck$60(this, InputCell);

      var _this = _possibleConstructorReturn$30(this, (InputCell.__proto__ || Object.getPrototypeOf(InputCell)).call(this, props, context));

      _this.onClick = function (event) {
        var input = _this.props.input;

        _this._eventBus.fire('input.edit', {
          event: event,
          input: input
        });
      };

      _this.onContextmenu = function (event) {
        var id = _this.props.input.id;

        _this._eventBus.fire('cell.contextmenu', {
          event: event,
          id: id
        });
      };

      _this.onElementsChanged = function () {
        _this.forceUpdate();
      };

      mixin(_this, ComponentWithSlots);
      return _this;
    }

    _createClass$49(InputCell, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        var injector = this.context.injector;

        this._changeSupport = this.context.changeSupport;
        this._sheet = injector.get('sheet');
        this._eventBus = injector.get('eventBus');
        this._elementRegistry = injector.get('elementRegistry');

        var root = this._sheet.getRoot();

        var input = this.props.input;

        this._changeSupport.onElementsChanged(root.id, this.onElementsChanged);
        this._changeSupport.onElementsChanged(input.id, this.onElementsChanged);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        var root = this._sheet.getRoot();

        var input = this.props.input;

        this._changeSupport.offElementsChanged(root.id, this.onElementsChanged);
        this._changeSupport.offElementsChanged(input.id, this.onElementsChanged);
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var input = this.props.input;

        var inputExpression = input.inputExpression;

        var label = input.get('label');
        var inputVariable = input.get('inputVariable');

        var expressionLanguage = inputExpression.get('expressionLanguage') || 'FEEL';

        var showLanguageBadge = !label && expressionLanguage != 'FEEL';

        return createVNode(1, 'th', 'input-cell input-editor', [this.slotFills({
          type: 'cell-inner',
          context: {
            cellType: 'input-cell',
            col: this._elementRegistry.get(input.id)
          },
          col: input
        }), label ? createVNode(1, 'span', 'input-label', label, 0, {
          'title': 'Input Label'
        }) : createVNode(1, 'span', 'input-expression', inputExpression.text || '-', 0, {
          'title': 'Input Expression'
        }), inputVariable && createVNode(1, 'span', 'dms-badge dmn-variable-name input-variable', inputVariable, 0, {
          'title': 'Input Variable'
        }), showLanguageBadge && createVNode(1, 'span', 'dms-badge dmn-expression-language input-expression-language', [createVNode(1, 'span', 'dms-badge-icon dmn-icon-file-code'), createVNode(1, 'span', 'dms-badge-label', expressionLanguage, 0)], 4, {
          'title': 'Input Expression Language = ' + expressionLanguage
        })], 0, {
          'data-col-id': input.id,
          'onClick': this.onClick,
          'onContextmenu': this.onContextmenu
        });
      }
    }]);

    return InputCell;
  }(Component);

  var _typeof$42 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$50 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$61(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$31(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$42(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$31(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$42(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var InputSelect = function (_Component) {
    _inherits$31(InputSelect, _Component);

    function InputSelect(props, context) {
      _classCallCheck$61(this, InputSelect);

      var _this = _possibleConstructorReturn$31(this, (InputSelect.__proto__ || Object.getPrototypeOf(InputSelect)).call(this, props, context));

      _initialiseProps$1.call(_this);

      inject(_this);

      var value = props.value;

      _this.state = {
        value: value,
        optionsVisible: false
      };

      _this._portalEl = null;
      return _this;
    }

    _createClass$50(InputSelect, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        document.addEventListener('click', this.onGlobalClick);
        document.addEventListener('focusin', this.onFocusChanged);

        this.keyboard.addListener(this.onKeyboard);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        document.removeEventListener('focusin', this.onFocusChanged);
        document.removeEventListener('click', this.onGlobalClick);

        this.keyboard.removeListener(this.onKeyboard);

        this.removePortalEl();
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(props) {
        var value = props.value;

        this.setState({
          value: value
        });
      }
    }, {
      key: 'componentWillUpdate',
      value: function componentWillUpdate(nextProps, nextState) {
        var optionsVisible = nextState.optionsVisible;

        if (optionsVisible) {
          if (!this._portalEl) {
            this.addPortalEl();
          }
        } else {
          if (this._portalEl) {
            this.removePortalEl();
          }
        }
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        var optionsVisible = this.state.optionsVisible;

        if (!optionsVisible || !this.inputNode) {
          return;
        }

        var _inputNode$getBoundin = this.inputNode.getBoundingClientRect(),
            top = _inputNode$getBoundin.top,
            left = _inputNode$getBoundin.left,
            width = _inputNode$getBoundin.width,
            height = _inputNode$getBoundin.height;

        assign(this._portalEl.style, {
          top: top + height + 'px',
          left: left + 'px',
          width: width + 'px'
        });
      }
    }, {
      key: 'addPortalEl',
      value: function addPortalEl() {
        this._portalEl = domify('<div class="dms-select-options"></div>');

        var container = this.renderer.getContainer();

        container.appendChild(this._portalEl);
      }
    }, {
      key: 'removePortalEl',
      value: function removePortalEl() {
        if (this._portalEl) {
          remove(this._portalEl);

          this._portalEl = null;
        }
      }
    }, {
      key: 'focusInput',

      /**
       * Focus input node
       */
      value: function focusInput() {
        var node = this.inputNode;

        node.focus();

        // move cursor to end of input
        if ('selectionStart' in node) {
          node.selectionStart = 100000;
        }
      }
    }, {
      key: 'checkClose',
      value: function checkClose(focusTarget) {

        if (this._portalEl && !this._portalEl.contains(focusTarget) && !this.parentNode.contains(focusTarget)) {
          this.setOptionsVisible(false);
        }
      }
    }, {
      key: 'select',
      value: function select(direction) {
        var options$$1 = this.props.options;
        var value = this.state.value;

        if (!options$$1) {
          return;
        }

        var option = options$$1.filter(function (o) {
          return o.value === value;
        })[0];

        var idx = option ? options$$1.indexOf(option) : -1;

        var nextIdx = idx === -1 ? direction === 1 ? 0 : options$$1.length - 1 : (idx + direction) % options$$1.length;

        var nextOption = options$$1[nextIdx < 0 ? options$$1.length + nextIdx : nextIdx];

        this.onChange(nextOption.value);
      }
    }, {
      key: 'setOptionsVisible',
      value: function setOptionsVisible(optionsVisible) {
        this.setState({
          optionsVisible: optionsVisible
        });
      }
    }, {
      key: 'renderOptions',
      value: function renderOptions(options$$1, activeOption) {
        var _this2 = this;

        return createVNode(1, 'div', 'options', options$$1.map(function (option) {
          return createVNode(1, 'div', ['option', activeOption === option ? 'active' : ''].join(' '), option.label, 0, {
            'data-value': option.value,
            'onClick': function onClick(e) {
              return _this2.onOptionClick(option.value, e);
            }
          });
        }), 0);
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _this3 = this;

        var _props = this.props,
            className = _props.className,
            options$$1 = _props.options,
            noInput = _props.noInput;
        var _state = this.state,
            optionsVisible = _state.optionsVisible,
            value = _state.value;

        var option = options$$1 ? options$$1.filter(function (o) {
          return o.value === value;
        })[0] : false;

        var label = option ? option.label : value;

        return createVNode(1, 'div', [className || '', 'dms-input-select'].join(' '), [noInput ? createVNode(1, 'div', 'dms-input', label, 0, {
          'tabindex': '0',
          'onKeyDown': this.onKeyDown
        }, null, function (node) {
          return _this3.inputNode = node;
        }) : createVNode(64, 'input', 'dms-input', null, 1, {
          'onInput': this.onInput,
          'onKeyDown': this.onKeyDown,
          'spellcheck': 'false',
          'type': 'text',
          'value': value
        }, null, function (node) {
          return _this3.inputNode = node;
        }), createVNode(1, 'span', ['dms-input-select-icon', optionsVisible ? 'dmn-icon-up' : 'dmn-icon-down'].join(' ')), optionsVisible && createPortal(this.renderOptions(options$$1, option), this._portalEl)], 0, {
          'onClick': this.onInputClick
        }, null, function (node) {
          return _this3.parentNode = node;
        });
      }
    }]);

    return InputSelect;
  }(Component);

  var _initialiseProps$1 = function _initialiseProps() {
    var _this4 = this;

    this.onChange = function (value) {
      _this4.setState({
        value: value
      });

      var onChange = _this4.props.onChange;

      if (typeof onChange !== 'function') {
        return;
      }

      onChange(value);
    };

    this.onInputClick = function (event) {
      event.preventDefault();
      event.stopPropagation();

      _this4.setOptionsVisible(!_this4.state.optionsVisible);

      _this4.focusInput();
    };

    this.onInput = function (event) {
      var value = event.target.value;

      _this4.onChange(value);
    };

    this.onOptionClick = function (value, event) {
      event.preventDefault();
      event.stopPropagation();

      _this4.setOptionsVisible(false);

      _this4.onChange(value);

      _this4.focusInput();
    };

    this.onFocusChanged = function (evt) {
      _this4.checkClose(evt.target);
    };

    this.onGlobalClick = function (evt) {
      _this4.checkClose(evt.target);
    };

    this.onKeyDown = function (evt) {
      var optionsVisible = _this4.state.optionsVisible;

      var code = evt.which;

      // DOWN or UP
      if (code === 40 || code === 38) {

        evt.stopPropagation();
        evt.preventDefault();

        if (!optionsVisible) {
          _this4.setOptionsVisible(true);
        } else {
          _this4.select(code === 40 ? 1 : -1);
        }
      }

      if (optionsVisible) {

        // ENTER
        // ESC
        if (code === 13 || code === 27) {
          evt.stopPropagation();
          evt.preventDefault();

          _this4.setOptionsVisible(false);
        }
      }
    };

    this.onKeyboard = function (keycode) {
      var optionsVisible = _this4.state.optionsVisible;

      if (!optionsVisible) {
        return;
      }

      // close on ESC
      if (keycode === 27) {
        _this4.setOptionsVisible(false);

        return true;
      }
    };
  };

  InputSelect.$inject = ['keyboard', 'renderer'];

  var _typeof$43 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$51 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$62(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$32(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$43(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$32(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$43(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var InputEditor = function (_Component) {
    _inherits$32(InputEditor, _Component);

    function InputEditor(props, context) {
      _classCallCheck$62(this, InputEditor);

      var _this = _possibleConstructorReturn$32(this, (InputEditor.__proto__ || Object.getPrototypeOf(InputEditor)).call(this, props, context));

      _this.setExpressionLanguage = function (expressionLanguage) {
        _this.handleChange({ expressionLanguage: expressionLanguage });
      };

      _this.makeScript = function (event) {
        event.preventDefault();
        event.stopPropagation();

        _this.setExpressionLanguage('FEEL');
      };

      _this.handleValue = function (text) {
        var expressionLanguage = _this.props.expressionLanguage;

        var change = { text: text };

        if (isMultiLine(text) && !expressionLanguage) {
          change.expressionLanguage = 'FEEL';
        }

        if (!isMultiLine(text) && expressionLanguage === 'FEEL') {
          change.expressionLanguage = undefined;
        }

        _this.handleChange(change);
      };

      _this.handleLanguageChange = function (language) {
        _this.setExpressionLanguage(language);
      };

      _this.handleLabelChange = function (value) {

        // default to <undefined> for empty string
        var label = value || undefined;

        _this.handleChange({ label: label });
      };

      _this.handleInputVariableChange = function (value) {

        // default to <undefined> for empty string
        var inputVariable = value || undefined;

        _this.handleChange({ inputVariable: inputVariable });
      };
      return _this;
    }

    _createClass$51(InputEditor, [{
      key: 'handleChange',
      value: function handleChange(changes) {
        var onChange = this.props.onChange;

        if (typeof onChange === 'function') {
          onChange(changes);
        }
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _props = this.props,
            expressionLanguage = _props.expressionLanguage,
            inputVariable = _props.inputVariable,
            label = _props.label,
            text = _props.text;

        var editScript = expressionLanguage || isMultiLine(text);

        var languageOptions = [!isMultiLine(text) && '', 'FEEL', 'JUEL', 'JavaScript', 'Groovy', 'Python'].filter(isString).map(function (o) {
          return { label: o, value: o };
        });

        return createVNode(1, 'div', 'dms-container ref-input-editor', [createVNode(1, 'h4', 'dms-heading', createTextVNode('Input Expression'), 2), createComponentVNode(2, ContentEditable, {
          'placeholder': 'enter expression',
          'ctrlForNewline': true,
          'className': ['ref-text', 'dms-input', editScript ? 'dms-script-input script-editor' : '', 'dms-fit-row'].join(' '),
          'onInput': this.handleValue,
          'value': text || ''
        }), !editScript && createVNode(1, 'p', 'dms-hint', [createTextVNode('Enter simple '), createVNode(1, 'code', null, createTextVNode('FEEL'), 2), createTextVNode(' expression or '), createVNode(1, 'a', 'ref-make-script', createTextVNode('change to script'), 2, {
          'href': '#',
          'onClick': this.makeScript
        }), createTextVNode('.')], 4), editScript && createVNode(1, 'p', 'dms-hint', createTextVNode('Enter script.'), 2), editScript && createVNode(1, 'p', null, [createVNode(1, 'label', 'dms-label', createTextVNode('Expression Language'), 2), createComponentVNode(2, InputSelect, {
          'className': 'ref-language',
          'value': expressionLanguage || '',
          'onChange': this.handleLanguageChange,
          'options': languageOptions
        })], 4), createVNode(1, 'hr', 'dms-hrule'), createVNode(1, 'p', 'dms-fill-row', [createVNode(1, 'label', 'dms-label', createTextVNode('Input Label'), 2), createComponentVNode(2, Input, {
          'className': 'ref-input-label',
          'value': label || '',
          'onInput': this.handleLabelChange
        })], 4), createVNode(1, 'p', 'dms-fill-row', [createVNode(1, 'label', 'dms-label', createTextVNode('Input Variable'), 2), createComponentVNode(2, Input, {
          'className': 'ref-input-variable',
          'value': inputVariable || '',
          'onInput': this.handleInputVariableChange,
          'placeholder': 'cellInput'
        })], 4)], 0);
      }
    }]);

    return InputEditor;
  }(Component);

  function isMultiLine(text) {
    return text && text.split(/\n/).length > 1;
  }

  var _typeof$44 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _extends$11 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass$52 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _objectWithoutProperties$5(obj, keys) {
    var target = {};for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
    }return target;
  }

  function _classCallCheck$63(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$33(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$44(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$33(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$44(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var InputCellContextMenu = function (_Component) {
    _inherits$33(InputCellContextMenu, _Component);

    function InputCellContextMenu(props, context) {
      _classCallCheck$63(this, InputCellContextMenu);

      var _this = _possibleConstructorReturn$33(this, (InputCellContextMenu.__proto__ || Object.getPrototypeOf(InputCellContextMenu)).call(this, props, context));

      _this.persistChanges = function () {
        var input = _this.props.context.input;
        var unsaved = _this.state.unsaved;

        if (!unsaved) {
          return;
        }

        var inputVariable = unsaved.inputVariable,
            label = unsaved.label,
            inputExpressionProperties = _objectWithoutProperties$5(unsaved, ['inputVariable', 'label']);

        var changes = {};

        if ('inputVariable' in unsaved) {
          changes.inputVariable = inputVariable;
        }

        if ('label' in unsaved) {
          changes.label = label;
        }

        if (hasKeys(inputExpressionProperties)) {
          changes.inputExpression = inputExpressionProperties;
        }

        _this.modeling.updateProperties(input, changes);

        _this.setState({
          unsaved: false
        });
      };

      _this.handleChange = function (changes) {
        _this.setState({
          unsaved: _extends$11({}, _this.state.unsaved, changes)
        }, _this.persistChanges);
      };

      _this.state = {};

      inject(_this);

      _this.persistChanges = _this.debounceInput(_this.persistChanges);
      return _this;
    }

    _createClass$52(InputCellContextMenu, [{
      key: 'getValue',
      value: function getValue(attr) {
        var input = this.props.context.input;
        var unsaved = this.state.unsaved;

        var target = input;

        // input variable stored in parent
        if (attr === 'expressionLanguage' || attr === 'text') {
          target = target.inputExpression;
        }

        return unsaved && unsaved[attr] || target.get(attr);
      }
    }, {
      key: 'render',
      value: function render$$1() {
        return createVNode(1, 'div', 'context-menu-container input-edit', createComponentVNode(2, InputEditor, {
          'expressionLanguage': this.getValue('expressionLanguage'),
          'inputVariable': this.getValue('inputVariable'),
          'label': this.getValue('label'),
          'text': this.getValue('text'),
          'onChange': this.handleChange
        }), 2);
      }
    }]);

    return InputCellContextMenu;
  }(Component);

  InputCellContextMenu.$inject = ['debounceInput', 'modeling'];

  // helpers //////////////////////

  function hasKeys(obj) {
    return Object.keys(obj).length;
  }

  function _classCallCheck$64(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var InputCellProvider = function InputCellProvider(components, contextMenu, eventBus, renderer) {
    _classCallCheck$64(this, InputCellProvider);

    components.onGetComponent('cell', function (_ref) {
      var cellType = _ref.cellType;

      if (cellType === 'input-header') {
        return InputCell;
      }
    });

    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (context.contextMenuType === 'input-edit') {
        return InputCellContextMenu;
      }
    });

    eventBus.on('input.edit', function (_ref2) {
      var event = _ref2.event,
          input = _ref2.input;
      var target = event.target;

      var node = closest(target, 'th', true);

      var _node$getBoundingClie = node.getBoundingClientRect(),
          left = _node$getBoundingClie.left,
          top = _node$getBoundingClie.top,
          width = _node$getBoundingClie.width,
          height = _node$getBoundingClie.height;

      var container = renderer.getContainer();

      contextMenu.open({
        x: left + container.parentNode.scrollLeft,
        y: top + container.parentNode.scrollTop,
        width: width,
        height: height
      }, {
        contextMenuType: 'input-edit',
        input: input,
        offset: {
          x: 4,
          y: 4
        }
      });
    });
  };

  InputCellProvider.$inject = ['components', 'contextMenu', 'eventBus', 'renderer'];

  var _typeof$45 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$53 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$65(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$34(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$45(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$34(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$45(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var TypeRefCell = function (_Component) {
    _inherits$34(TypeRefCell, _Component);

    function TypeRefCell(props) {
      _classCallCheck$65(this, TypeRefCell);

      var _this = _possibleConstructorReturn$34(this, (TypeRefCell.__proto__ || Object.getPrototypeOf(TypeRefCell)).call(this, props));

      _this.onClick = function (event) {

        var element = _this.getTypeRefTarget();

        _this._eventBus.fire('typeRef.edit', {
          event: event,
          element: element
        });
      };

      _this.onContextmenu = function (event) {
        var element = _this.props.element;

        var actualElement = element;

        if (is(element, 'dmn:LiteralExpression')) {
          actualElement = element.$parent;
        }

        _this._eventBus.fire('cell.contextmenu', {
          event: event,
          node: event.node,
          id: actualElement.id
        });
      };

      _this.onElementsChanged = function () {
        _this.forceUpdate();
      };

      return _this;
    }

    _createClass$53(TypeRefCell, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        var injector = this.context.injector;

        this._changeSupport = this.context.changeSupport;
        this._sheet = injector.get('sheet');
        this._eventBus = injector.get('eventBus');

        var target = this.getTypeRefTarget();

        this._changeSupport.onElementsChanged(target.id, this.onElementsChanged);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        var target = this.getTypeRefTarget();

        this._changeSupport.offElementsChanged(target.id, this.onElementsChanged);
      }
    }, {
      key: 'getTypeRefTarget',
      value: function getTypeRefTarget() {
        var element = this.props.element;

        return is(element, 'dmn:InputClause') ? element.inputExpression : element;
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _props = this.props,
            element = _props.element,
            className = _props.className;

        var actualClassName = (className || '') + ' type-ref';

        var colId = is(element, 'dmn:LiteralExpression') ? element.$parent.id : element.id;

        return createVNode(1, 'th', actualClassName, element.typeRef, 0, {
          'title': 'Data Type',
          'data-col-id': colId,
          'onClick': this.onClick,
          'onContextmenu': this.onContextmenu
        });
      }
    }]);

    return TypeRefCell;
  }(Component);

  var _typeof$46 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$54 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$66(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$35(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$46(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$35(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$46(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var TYPES$1 = ['string', 'boolean', 'integer', 'long', 'double', 'date'];

  var TypeRefCellContextMenu = function (_Component) {
    _inherits$35(TypeRefCellContextMenu, _Component);

    function TypeRefCellContextMenu(props, context) {
      _classCallCheck$66(this, TypeRefCellContextMenu);

      var _this = _possibleConstructorReturn$35(this, (TypeRefCellContextMenu.__proto__ || Object.getPrototypeOf(TypeRefCellContextMenu)).call(this, props));

      _this.onTypeChange = function (value) {
        var element = _this.props.context.element;

        var actualElement = is(element, 'dmn:LiteralExpression') ? element.$parent : element;

        var newProperties = void 0;

        if (isInput(actualElement)) {
          newProperties = {
            inputExpression: {
              typeRef: value
            }
          };
        } else if (isOutput(actualElement)) {
          newProperties = {
            typeRef: value
          };
        }

        _this._modeling.updateProperties(actualElement, newProperties);
      };

      _this._modeling = context.injector.get('modeling');
      return _this;
    }

    _createClass$54(TypeRefCellContextMenu, [{
      key: 'render',
      value: function render$$1() {
        var element = this.props.context.element;

        var typeRef = (is(element, 'dmn:InputClause') ? element.inputExpression : element).typeRef;

        var typeRefOptions = TYPES$1.map(function (t) {
          return {
            label: t,
            value: t
          };
        });

        return createVNode(1, 'div', 'type-ref-edit context-menu-container', [createVNode(1, 'label', 'dms-label', createTextVNode('Type:'), 2), createComponentVNode(2, InputSelect, {
          'className': 'type-ref-edit-select',
          'onChange': this.onTypeChange,
          'options': typeRefOptions,
          'value': typeRef
        })], 4);
      }
    }]);

    return TypeRefCellContextMenu;
  }(Component);

  function _classCallCheck$67(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var TypeRef = function TypeRef(components, contextMenu, eventBus, renderer) {
    _classCallCheck$67(this, TypeRef);

    components.onGetComponent('cell', function (_ref) {
      var cellType = _ref.cellType;

      if (cellType === 'input-header-type-ref' || cellType === 'output-header-type-ref') {
        return TypeRefCell;
      }
    });

    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (context.contextMenuType && context.contextMenuType === 'type-ref-edit') {
        return TypeRefCellContextMenu;
      }
    });

    eventBus.on('typeRef.edit', function (_ref2) {
      var event = _ref2.event,
          element = _ref2.element;
      var target = event.target;

      var node = closest(target, 'th', true);

      var _node$getBoundingClie = node.getBoundingClientRect(),
          left = _node$getBoundingClie.left,
          top = _node$getBoundingClie.top,
          width = _node$getBoundingClie.width,
          height = _node$getBoundingClie.height;

      var container = renderer.getContainer();

      contextMenu.open({
        x: left + container.parentNode.scrollLeft,
        y: top + container.parentNode.scrollTop,
        width: width,
        height: height
      }, {
        contextMenuType: 'type-ref-edit',
        element: element,
        offset: {
          x: 4,
          y: 4
        }
      });
    });
  };

  TypeRef.$inject = ['components', 'contextMenu', 'eventBus', 'renderer'];

  var TypeRefEditing = {
    __depends__: [ContextMenu$2],
    __init__: ['typeRefEditingProvider'],
    typeRefEditingProvider: ['type', TypeRef]
  };

  var _typeof$47 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  function _classCallCheck$68(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$36(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$47(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$36(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$47(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  /**
   * Makes sure allowed values are removed if type is set to
   * something other than string.
   */

  var AllowedValuesUpdateBehavior = function (_CommandInterceptor) {
    _inherits$36(AllowedValuesUpdateBehavior, _CommandInterceptor);

    function AllowedValuesUpdateBehavior(eventBus, modeling) {
      _classCallCheck$68(this, AllowedValuesUpdateBehavior);

      var _this = _possibleConstructorReturn$36(this, (AllowedValuesUpdateBehavior.__proto__ || Object.getPrototypeOf(AllowedValuesUpdateBehavior)).call(this, eventBus));

      _this.postExecuted('updateProperties', function (event) {
        var _event$context = event.context,
            element = _event$context.element,
            properties = _event$context.properties;

        var actualProperties = isInput(element) ? properties.inputExpression : properties;

        if (actualProperties && actualProperties.typeRef && actualProperties.typeRef !== 'string') {

          var target = is(element, 'dmn:LiteralExpression') ? element.$parent : element;

          // delete allowed values
          modeling.editAllowedValues(target, null);
        }
      });
      return _this;
    }

    return AllowedValuesUpdateBehavior;
  }(CommandInterceptor);

  AllowedValuesUpdateBehavior.$inject = ['eventBus', 'modeling'];

  var _typeof$48 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$55 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$69(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$37(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$48(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$37(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$48(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var RADIO = 'radio';

  var REMOVE_BTN_CLS = 'remove dmn-icon-clear';

  /**
   * Shows a list of grouped items that can be checked
   * (checkboxes or radio buttons), removed.
   *
   * Example list of items:
   *
   * [
   *   { value: 'foo', isChecked: true, isRemovable: false, group: 'foo' },
   *   { value: 'bar', isChecked: false, isRemovable: true, group: 'bar' },
   *   { value: 'baz', isCheckable: false, group: 'baz' }
   * ]
   */

  var List = function (_Component) {
    _inherits$37(List, _Component);

    function List(props, context) {
      _classCallCheck$69(this, List);

      var _this = _possibleConstructorReturn$37(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this, props, context));

      _this.getRemoveClickHandler = function (item) {
        return function (e) {
          e.stopPropagation();

          _this.removeItem(item);
        };
      };

      _this.getToggleClickHandler = function (item) {
        return function (e) {
          e.stopPropagation();

          _this.toggleItem(item);
        };
      };

      _this.removeItem = function (item) {
        var onChange = _this.props.onChange;

        // remove item

        var newItems = _this.state.items.filter(function (i) {
          return i !== item;
        });

        _this.setState({
          items: newItems
        });

        onChange && onChange(newItems);
      };

      _this.toggleItem = function (item) {
        var _this$props = _this.props,
            onChange = _this$props.onChange,
            type = _this$props.type;

        // toggle item

        var newItems = _this.state.items.map(function (i) {
          if (i === item) {
            i.isChecked = !i.isChecked;
          } else {

            if (type === RADIO) {
              i.isChecked = false;
            }
          }

          return i;
        });

        _this.setState({
          items: newItems
        });

        onChange && onChange(newItems);
      };

      var items = props.items;

      _this.state = {
        items: items
      };
      return _this;
    }

    _createClass$55(List, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(props) {
        var items = props.items;

        this.setState({
          items: items
        });
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _this2 = this;

        var _props = this.props,
            className = _props.className,
            items = _props.items,
            type = _props.type;

        var classes = ['dms-list-component'];

        if (className) {
          classes.push(className);
        }

        // group items by group title
        var groupedItems = groupBy(items, 'group');

        var asPairs = toPairs(groupedItems);

        return createVNode(1, 'div', classes.join(' '), asPairs.map(function (pair) {

          var groupTitle = pair[0],
              groupItems = pair[1];

          return createVNode(1, 'div', 'group', [createVNode(1, 'h4', 'dms-heading', groupTitle, 0), createVNode(1, 'ul', 'items no-wrap', groupItems.map(function (item) {

            return createVNode(1, 'li', 'item', [type && createVNode(64, 'input', 'item-toggle', null, 1, {
              'type': type,
              'checked': item.isChecked,
              'onClick': _this2.getToggleClickHandler(item)
            }), createTextVNode('\xA0'), item.value, item.isRemovable && createVNode(1, 'span', REMOVE_BTN_CLS, null, 1, {
              'title': 'Remove item',
              'onClick': _this2.getRemoveClickHandler(item)
            })], 0);
          }), 0)], 4);
        }), 0);
      }
    }]);

    return List;
  }(Component);
  function toPairs(object) {
    var entrys = [];

    for (var key in object) {
      entrys.push([key, object[key]]);
    }

    return entrys;
  }

  var _typeof$49 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$56 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$70(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$38(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$49(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$38(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$49(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  /**
   * Input with optional validation.
   */

  var ValidatedInput = function (_Component) {
    _inherits$38(ValidatedInput, _Component);

    function ValidatedInput(props, context) {
      _classCallCheck$70(this, ValidatedInput);

      var _this = _possibleConstructorReturn$38(this, (ValidatedInput.__proto__ || Object.getPrototypeOf(ValidatedInput)).call(this, props, context));

      var validate = props.validate,
          value = props.value;

      var validationWarning = validate ? validate(value || '') : undefined;

      _this.state = {
        validationWarning: validationWarning,
        value: value
      };

      _this.onInput = _this.onInput.bind(_this);
      _this.onKeyDown = _this.onKeyDown.bind(_this);
      _this.onKeyUp = _this.onKeyUp.bind(_this);
      return _this;
    }

    _createClass$56(ValidatedInput, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(props) {
        var validate = props.validate,
            value = props.value;

        var validationWarning = validate ? validate(value || '') : undefined;

        this.setState({
          validationWarning: validationWarning,
          value: value
        });
      }
    }, {
      key: 'onInput',
      value: function onInput(value) {
        var _props = this.props,
            onInput = _props.onInput,
            validate = _props.validate;

        var validationWarning = validate ? validate(value) : undefined;

        this.setState({
          validationWarning: validationWarning,
          value: value
        });

        if (typeof onInput !== 'function') {
          return;
        }

        onInput && onInput({
          isValid: !validationWarning,
          value: value
        });
      }
    }, {
      key: 'onKeyDown',
      value: function onKeyDown(event) {
        var target = event.target,
            value = target.value;
        var _props2 = this.props,
            onKeyDown = _props2.onKeyDown,
            validate = _props2.validate;

        var validationWarning = validate ? validate(value) : undefined;

        if (typeof onKeyDown !== 'function') {
          return;
        }

        onKeyDown({
          isValid: !validationWarning,
          value: value,
          event: event
        });
      }
    }, {
      key: 'onKeyUp',
      value: function onKeyUp(event) {
        var target = event.target,
            value = target.value;
        var _props3 = this.props,
            onKeyUp = _props3.onKeyUp,
            validate = _props3.validate;

        var validationWarning = validate ? validate(value) : undefined;

        if (typeof onKeyUp !== 'function') {
          return;
        }

        onKeyUp({
          isValid: !validationWarning,
          value: value,
          event: event
        });
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _props4 = this.props,
            placeholder = _props4.placeholder,
            type = _props4.type,
            className = _props4.className;
        var _state = this.state,
            validationWarning = _state.validationWarning,
            value = _state.value;

        var parentClasses = ['dms-validated-input', className].join(' ');

        var inputClasses = [];

        if (validationWarning) {
          inputClasses.push('invalid');
        }

        return createVNode(1, 'div', parentClasses, [createComponentVNode(2, Input, {
          'className': inputClasses,
          'onInput': this.onInput,
          'onKeyDown': this.onKeyDown,
          'onKeyUp': this.onKeyUp,
          'placeholder': placeholder || '',
          'type': type,
          'value': value || ''
        }), validationWarning && createVNode(1, 'p', 'dms-hint dms-validation-warning', validationWarning, 0)], 0);
      }
    }]);

    return ValidatedInput;
  }(Component);

  function parseString(string) {

    // empty string or no string at all
    if (!string || isEmptyString(string.trim())) {
      return {
        values: []
      };
    }

    // disjunction
    var values = string.split(',');

    var result = {
      values: []
    };

    var openString = '';

    values.forEach(function (value) {
      openString += value;

      if (/^"[^"]*"$/.test(openString.trim())) {
        result.values.push(openString.trim());

        openString = '';
      } else {
        openString += ',';
      }
    });

    if (!openString) {
      return result;
    }
  }

  function isEmptyString(string) {
    return string === '';
  }

  function getValuesArray(values) {
    return values.map(function (value) {
      return value.value;
    });
  }

  var _typeof$50 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$57 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$71(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$39(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$50(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$39(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$50(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var AllowedValuesEditing = function (_Component) {
    _inherits$39(AllowedValuesEditing, _Component);

    function AllowedValuesEditing(props, context) {
      _classCallCheck$71(this, AllowedValuesEditing);

      var _this = _possibleConstructorReturn$39(this, (AllowedValuesEditing.__proto__ || Object.getPrototypeOf(AllowedValuesEditing)).call(this, props, context));

      _initialiseProps$2.call(_this);

      _this._modeling = context.injector.get('modeling');
      _this._changeSupport = context.changeSupport;

      var target = _this.getAllowedValuesTarget();

      var parsedString = parseString(target.inputValues && target.inputValues.text || target.outputValues && target.outputValues.text || '');

      if (parsedString) {
        _this.state = {
          values: parsedString.values.map(function (value) {
            return {
              value: value,
              isCheckable: false,
              isRemovable: true,
              group: 'Predefined Values'
            };
          }),
          inputValue: ''
        };
      } else {
        _this.state = {
          values: null,
          inputValue: ''
        };
      }
      return _this;
    }

    _createClass$57(AllowedValuesEditing, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        var target = this.getAllowedValuesTarget();

        this._changeSupport.onElementsChanged(target.id, this.onElementsChanged);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        var target = this.getAllowedValuesTarget();

        this._changeSupport.offElementsChanged(target.id, this.onElementsChanged);
      }
    }, {
      key: 'getAllowedValuesTarget',
      value: function getAllowedValuesTarget() {
        var element = this.props.context.element;

        if (is(element, 'dmn:LiteralExpression')) {
          return element.$parent;
        } else {
          return element;
        }
      }

      /**
       * Add new value on ENTER.
       */

    }, {
      key: 'render',
      value: function render$$1() {
        var element = this.props.context.element;
        var _state = this.state,
            inputValue = _state.inputValue,
            values = _state.values;

        return element.typeRef === 'string' ? createVNode(1, 'div', 'context-menu-container allowed-values-edit', [createVNode(1, 'hr', 'dms-hrule'), !isNull$1(values) && values.length > 0 && createComponentVNode(2, List, {
          'items': values,
          'onChange': this.onListChange
        }), !isNull$1(values) && !values.length && createVNode(1, 'div', null, [createVNode(1, 'h4', 'dms-heading', createTextVNode('Predefined Values'), 2), createVNode(1, 'span', 'placeholder', createTextVNode('No values'), 2)], 4), !isNull$1(values) && createVNode(1, 'p', 'dms-hint', createVNode(1, 'a', 'del-values', createTextVNode('Clear predefined values.'), 2, {
          'href': '#',
          'onClick': this.handleRemovePredifinedValuesClick
        }), 2), createVNode(1, 'h4', 'dms-heading', createTextVNode('Add Predefined Values'), 2), createComponentVNode(2, ValidatedInput, {
          'onInput': this.onInput,
          'onKeyDown': this.onKeyDown,
          'placeholder': '"value", "value", ...',
          'type': 'text',
          'validate': function validate(value) {
            if (!parseString(value)) {
              return 'Strings must be in double quotes.';
            }
          },
          'value': inputValue
        })], 0) : null;
      }
    }]);

    return AllowedValuesEditing;
  }(Component);

  // helpers //////////////////////

  var _initialiseProps$2 = function _initialiseProps() {
    var _this2 = this;

    this.onElementsChanged = function () {
      _this2.forceUpdate();
    };

    this.setPredefinedValues = function (values) {

      // inputClause or outputClause
      var target = _this2.getAllowedValuesTarget();

      _this2.setState({
        values: values
      });

      _this2._modeling.editAllowedValues(target, values && getValuesArray(values));
    };

    this.onListChange = function (values) {
      _this2.setPredefinedValues(values);
    };

    this.onInput = function (_ref) {
      var isValid = _ref.isValid,
          value = _ref.value;

      _this2.setState({
        inputValue: value
      });
    };

    this.onKeyDown = function (_ref2) {
      var isValid = _ref2.isValid,
          event = _ref2.event;

      if (!isEnter(event.keyCode)) {
        return;
      }

      event.stopPropagation();
      event.preventDefault();

      if (isValid) {
        var _state2 = _this2.state,
            inputValue = _state2.inputValue,
            values = _state2.values;

        var parsedString = parseString(inputValue);

        _this2.onListChange((values || []).concat(parsedString.values.map(function (value) {
          return {
            value: value,
            isCheckable: false,
            isRemovable: true,
            group: 'Predefined Values'
          };
        })));

        _this2.setState({
          inputValue: ''
        });
      }
    };

    this.handleRemovePredifinedValuesClick = function (e) {
      e.stopPropagation();

      _this2.removePredefinedValues();
    };

    this.removePredefinedValues = function () {
      _this2.setPredefinedValues(null);
    };
  };
  function isEnter(keyCode) {
    return keyCode === 13;
  }

  function isNull$1(value) {
    return value === null;
  }

  function _classCallCheck$72(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var LOW_PRIORITY$9 = 500;

  var InputOutputValues = function InputOutputValues(components) {
    _classCallCheck$72(this, InputOutputValues);

    components.onGetComponent('context-menu', LOW_PRIORITY$9, function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (context.contextMenuType && context.contextMenuType === 'type-ref-edit') {
        return AllowedValuesEditing;
      }
    });
  };

  InputOutputValues.$inject = ['components'];

  var AllowedValuesEditing$1 = {
    __init__: ['allowedValuesUpdateBehavior', 'allowedValuesEditingProvider'],
    allowedValuesUpdateBehavior: ['type', AllowedValuesUpdateBehavior],
    allowedValuesEditingProvider: ['type', InputOutputValues]
  };

  var _typeof$51 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$58 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$73(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$40(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$51(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$40(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$51(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var AddInput = function (_Component) {
    _inherits$40(AddInput, _Component);

    function AddInput(props, context) {
      _classCallCheck$73(this, AddInput);

      var _this = _possibleConstructorReturn$40(this, (AddInput.__proto__ || Object.getPrototypeOf(AddInput)).call(this, props, context));

      _this.onElementsChanged = function () {
        _this.forceUpdate();
      };

      _this.handleClick = function (e) {
        e.stopPropagation();

        _this.add();
      };

      _this.add = function () {
        _this._eventBus.fire('addInput');
      };

      _this._sheet = context.injector.get('sheet');
      _this._eventBus = context.injector.get('eventBus');

      _this._changeSupport = context.changeSupport;
      return _this;
    }

    _createClass$58(AddInput, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        var root = this.getRoot();

        this._changeSupport.onElementsChanged(root.id, this.onElementsChanged);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        var root = this.getRoot();

        this._changeSupport.offElementsChanged(root.id, this.onElementsChanged);
      }
    }, {
      key: 'getRoot',
      value: function getRoot() {
        return this._sheet.getRoot();
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _getRoot = this.getRoot(),
            businessObject = _getRoot.businessObject;

        var inputs = businessObject.input;

        if (!inputs || !inputs.length) {
          return null;
        }

        var colspan = inputs.length;

        return createVNode(1, 'th', 'input-cell inputs-label actionable add-input header', [createTextVNode('Input '), createVNode(1, 'span', 'add-input dmn-icon-plus action-icon', null, 1, {
          'title': 'Add Input'
        })], 4, {
          'onClick': this.handleClick,
          'colspan': colspan
        });
      }
    }]);

    return AddInput;
  }(Component);

  var _typeof$52 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$59 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$74(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$41(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$52(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$41(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$52(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var AddOutput = function (_Component) {
    _inherits$41(AddOutput, _Component);

    function AddOutput(props, context) {
      _classCallCheck$74(this, AddOutput);

      var _this = _possibleConstructorReturn$41(this, (AddOutput.__proto__ || Object.getPrototypeOf(AddOutput)).call(this, props, context));

      _this.onElementsChanged = function () {
        _this.forceUpdate();
      };

      _this.handleClick = function (e) {
        e.stopPropagation();

        _this.add();
      };

      _this.add = function () {
        _this._eventBus.fire('addOutput');
      };

      _this._sheet = context.injector.get('sheet');
      _this._eventBus = context.injector.get('eventBus');

      _this._changeSupport = context.changeSupport;
      return _this;
    }

    _createClass$59(AddOutput, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        var root = this.getRoot();

        this._changeSupport.onElementsChanged(root.id, this.onElementsChanged);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        var root = this.getRoot();

        this._changeSupport.offElementsChanged(root.id, this.onElementsChanged);
      }
    }, {
      key: 'getRoot',
      value: function getRoot() {
        return this._sheet.getRoot();
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _getRoot = this.getRoot(),
            businessObject = _getRoot.businessObject;

        var colspan = businessObject.output.length;

        return createVNode(1, 'th', 'output-cell outputs-label add-output actionable header', [createTextVNode('Output '), createVNode(1, 'span', 'add-output dmn-icon-plus action-icon', null, 1, {
          'title': 'Add Output'
        })], 4, {
          'onClick': this.handleClick,
          'colspan': colspan
        });
      }
    }]);

    return AddOutput;
  }(Component);

  function AddInputOutputProvider(components, editorActions, eventBus) {

    components.onGetComponent('cell', function (_ref) {
      var cellType = _ref.cellType;

      if (cellType === 'input-label') {
        return AddInput;
      }

      if (cellType === 'output-label') {
        return AddOutput;
      }
    });

    eventBus.on('addInput', function () {
      editorActions.trigger('addInput');
    });

    eventBus.on('addOutput', function () {
      editorActions.trigger('addOutput');
    });
  }

  AddInputOutputProvider.$inject = ['components', 'editorActions', 'eventBus'];

  var AddInputOutput = {
    __depends__: [EditorActions$3],
    __init__: ['addInputOutputProvider'],
    addInputOutputProvider: ['type', AddInputOutputProvider]
  };

  var tableHeadEditorModule = {
    __depends__: [AddInputOutput, AllowedValuesEditing$1, ContextMenu$2, DebounceInput, TypeRefEditing],
    __init__: ['inputEditingProvider', 'outputEditingProvider'],
    inputEditingProvider: ['type', InputCellProvider],
    outputEditingProvider: ['type', OutputEditingProvider]
  };

  var _createClass$60 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$75(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var TARGET_SELECTOR = '.dmn-decision-table-container td,\n   .dmn-decision-table-container th';

  var DragAndDrop = function () {
    function DragAndDrop(eventBus, renderer, modeling, sheet) {
      var _this = this;

      _classCallCheck$75(this, DragAndDrop);

      this.handleDragOver = function (event$$1) {

        // we're taking over (!)
        stopEvent$1(event$$1);

        var targetEl = event$$1.target;

        var cellEl = closest(targetEl, TARGET_SELECTOR, true);

        var allowed = !!cellEl;

        var hoverEl = _this._dragContext.hoverEl;

        // drag leave

        if (hoverEl && hoverEl !== cellEl) {
          _this._emit('dragAndDrop.dragLeave', event$$1);

          // unset target element
          _this._dragContext.targetEl = null;

          // unset hover element
          _this._dragContext.hoverEl = null;
        }

        if (cellEl) {

          // drag enter
          if (cellEl !== hoverEl) {

            // new hover element
            _this._dragContext.hoverEl = cellEl;

            allowed = _this._emit('dragAndDrop.dragEnter', event$$1);

            if (allowed !== false) {
              // new targetEl
              _this._dragContext.targetEl = cellEl;
            }
          }

          // drag over
          allowed = _this._emit('dragAndDrop.dragOver', event$$1);
        }

        event$$1.dataTransfer.dropEffect = allowed !== false ? 'move' : 'none';
      };

      this.handleDrop = function (event$$1) {

        // prevent default drop action
        // QUIRK: Firefox will redirect if not prevented
        stopEvent$1(event$$1);

        var target = _this._emit('dragAndDrop.drop', event$$1);

        if (target) {
          var draggedElement = _this._dragContext.draggedElement;

          if (draggedElement instanceof Row) {
            var _sheet$getRoot = _this._sheet.getRoot(),
                rows = _sheet$getRoot.rows;

            var index = rows.indexOf(target);

            _this._modeling.moveRow(draggedElement, index);
          } else if (draggedElement instanceof Col) {
            var _sheet$getRoot2 = _this._sheet.getRoot(),
                cols = _sheet$getRoot2.cols;

            var _index = cols.indexOf(target);

            _this._modeling.moveCol(draggedElement, _index);
          }
        }

        // manually call to drag end needed, as we prevent the default
        // browser behavior / drag end handling via
        // event.preventDefault();
        _this.handleDragEnd(event$$1);
      };

      this.handleDragEnd = function (event$$1) {

        // prevent default drop action
        stopEvent$1(event$$1);

        _this._unbindListeners();
        _this._emit('dragAndDrop.dragEnd', event$$1);

        _this._dragContext = null;
      };

      this._eventBus = eventBus;
      this._renderer = renderer;
      this._modeling = modeling;
      this._sheet = sheet;

      this._dragContext = null;

      eventBus.on('table.destroy', function () {
        _this._unbindListeners();
      });
    }

    _createClass$60(DragAndDrop, [{
      key: '_bindListeners',
      value: function _bindListeners() {
        componentEvent.bind(document, 'dragover', this.handleDragOver);
        componentEvent.bind(document, 'drop', this.handleDrop);
        componentEvent.bind(document, 'dragend', this.handleDragEnd);
      }
    }, {
      key: '_unbindListeners',
      value: function _unbindListeners() {
        componentEvent.unbind(document, 'dragover', this.handleDragOver);
        componentEvent.unbind(document, 'drop', this.handleDrop);
        componentEvent.unbind(document, 'dragend', this.handleDragEnd);
      }
    }, {
      key: '_emit',
      value: function _emit(eventName, originalEvent) {

        return this._eventBus.fire(eventName, {
          dragContext: this._dragContext,
          originalEvent: originalEvent
        });
      }
    }, {
      key: 'startDrag',
      value: function startDrag(element, event$$1) {

        stopEvent$1(event$$1, true);

        event$$1.dataTransfer.effectAllowed = 'move';

        // QUIRK: Firefox won't fire events unless data was set
        if (event$$1.dataTransfer.setData) {
          event$$1.dataTransfer.setData('text', '__DUMMY');
        }

        this._dragContext = {
          draggedElement: element
        };

        this._bindListeners();

        this._emit('dragAndDrop.dragStart', event$$1);
      }
    }]);

    return DragAndDrop;
  }();

  DragAndDrop.$inject = ['eventBus', 'renderer', 'modeling', 'sheet'];

  // helpers /////////////////

  function stopEvent$1(event$$1, preventDefault) {
    event$$1.stopPropagation();

    if (preventDefault !== true) {
      event$$1.preventDefault();
    }
  }

  var DragAndDrop$1 = {
    __init__: ['dragAndDrop'],
    dragAndDrop: ['type', DragAndDrop]
  };

  var _createClass$61 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$76(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var TOP = 'top',
      RIGHT = 'right',
      BOTTOM = 'bottom',
      LEFT = 'left';

  var DragAndDrop$2 = function () {
    function DragAndDrop(components, elementRegistry, eventBus, dragAndDrop, renderer, rules, sheet) {
      var _this = this;

      _classCallCheck$76(this, DragAndDrop);

      this._cleanup = function () {
        var container = _this._renderer.getContainer();

        removeHighlight(container);
        removeFadeOut(container);

        if (_this._dragImage) {
          remove(_this._dragImage);

          _this._dragImage = null;
        }
      };

      this._elementRegistry = elementRegistry;
      this._dragAndDrop = dragAndDrop;
      this._renderer = renderer;
      this._rules = rules;
      this._sheet = sheet;

      // provide drag handle for drag and drop
      components.onGetComponent('cell-inner', function (_ref) {
        var cellType = _ref.cellType,
            col = _ref.col,
            row = _ref.row;

        if (cellType === 'rule-index') {
          return function () {
            return createVNode(1, 'span', 'dmn-icon-drag vertical', createTextVNode('\xA0'), 2, {
              'draggable': 'true',
              'onDragStart': function onDragStart(e) {
                return _this.startDrag(row, e);
              },
              'title': 'Move rule'
            });
          };
        } else if (cellType === 'input-cell' || cellType === 'output-cell') {

          var title = 'Move ' + (isInput(col) ? 'Input' : 'Output');

          return function () {
            return createVNode(1, 'span', 'dmn-icon-drag horizontal', null, 1, {
              'draggable': 'true',
              'onDragStart': function onDragStart(e) {
                return _this.startDrag(col, e);
              },
              'title': title
            });
          };
        }
      });

      // validate allowed rules
      eventBus.on('dragAndDrop.dragEnter', function (event) {
        var dragContext = event.dragContext;
        var draggedElement = dragContext.draggedElement,
            hoverEl = dragContext.hoverEl;

        // can always drag rows

        if (draggedElement instanceof Row) {
          return true;
        }

        if (draggedElement instanceof Col) {
          var dropIndex = getTargetColIndex(hoverEl, _this._elementRegistry, _this._sheet);

          // cannot drop as we cannot compute the drop index
          if (dropIndex === -1) {
            return false;
          }

          var allowed = _this._rules.allowed('col.move', {
            col: draggedElement,
            index: dropIndex
          });

          return allowed;
        }

        return false;
      });

      // clear previous UI
      eventBus.on('dragAndDrop.dragLeave', function (event) {
        var dragContext = event.dragContext;
        var targetEl = dragContext.targetEl;

        if (!targetEl) {
          return;
        }

        var container = _this._renderer.getContainer();

        removeHighlight(container);
      });

      // update UI
      eventBus.on('dragAndDrop.dragOver', function (event) {
        var dragContext = event.dragContext,
            originalEvent = event.originalEvent;
        var draggedElement = dragContext.draggedElement,
            lastPosition = dragContext.lastPosition,
            targetEl = dragContext.targetEl;

        var container = _this._renderer.getContainer();

        if (!targetEl) {
          return false;
        }

        var newPosition = void 0;

        if (draggedElement instanceof Row) {
          newPosition = getVerticalPosition(originalEvent, targetEl);
        }

        if (draggedElement instanceof Col) {
          newPosition = getHorizontalPosition(originalEvent, targetEl);
        }

        // nothing to do
        if (lastPosition === newPosition) {
          return true;
        }

        // remove old highlight
        removeHighlight(container);

        if (draggedElement instanceof Row) {

          if (newPosition === TOP) {

            // drop above
            highlightRow(targetEl, container, 'top');
          } else {

            // drop below
            highlightRow(targetEl, container, 'bottom');
          }
        }

        if (draggedElement instanceof Col) {
          if (newPosition === LEFT) {

            // drop left
            highlightCol(targetEl, container, 'left');
          } else {

            // drop right
            highlightCol(targetEl, container, 'right');
          }
        }

        // remember position
        dragContext.lastPosition = newPosition;

        // allowed
        return true;
      });

      // perform drop operation
      eventBus.on('dragAndDrop.drop', function (event) {
        var dragContext = event.dragContext,
            originalEvent = event.originalEvent;
        var draggedElement = dragContext.draggedElement,
            targetEl = dragContext.targetEl;

        if (!targetEl) {
          return false;
        }

        if (draggedElement instanceof Row) {
          var verticalPosition = getVerticalPosition(originalEvent, targetEl);

          var rowId = targetEl.dataset.rowId,
              row = _this._elementRegistry.get(rowId);

          if (!row || row === draggedElement) {
            return;
          }

          var targetRow = getTargetRow(draggedElement, row, verticalPosition, _this._sheet.getRoot().rows);

          if (targetRow === draggedElement) {
            return;
          }

          return targetRow;
        }

        if (draggedElement instanceof Col) {
          var horizontalPosition = getHorizontalPosition(originalEvent, targetEl);

          // no need to check rules; we verified on
          // dragEnter that dropping is O.K.
          var colId = targetEl.dataset.colId,
              col = _this._elementRegistry.get(colId);

          if (!col || col === draggedElement) {
            return;
          }

          var targetCol = getTargetCol(draggedElement, col, horizontalPosition, _this._sheet.getRoot().cols);

          if (targetCol === draggedElement) {
            return;
          }

          return targetCol;
        }
      });

      eventBus.on('dragAndDrop.dragEnd', this._cleanup);
    }

    _createClass$61(DragAndDrop, [{
      key: 'startDrag',
      value: function startDrag(element, event) {
        var container = this._renderer.getContainer();

        this._dragImage = domify('<span style="\n          visibility: hidden;\n          position: fixed;\n          top: -10000px\n      "></span>');

        // needs to be present in DOM
        document.body.appendChild(this._dragImage);

        // QUIRK: not supported by Edge and Internet Explorer
        if (event.dataTransfer.setDragImage) {
          event.dataTransfer.setDragImage(this._dragImage, 0, 0);
        }

        if (element instanceof Row) {
          fadeOutRow(element, container);
        } else if (element instanceof Col) {
          fadeOutCol(element, container);
        }

        this._dragAndDrop.startDrag(element, event);
      }
    }]);

    return DragAndDrop;
  }();

  DragAndDrop$2.$inject = ['components', 'elementRegistry', 'eventBus', 'dragAndDrop', 'renderer', 'rules', 'sheet'];

  // helpers //////////

  function getTargetColIndex(cellEl, elementRegistry, sheet) {
    var targetCol = elementRegistry.get(cellEl.dataset.colId);

    if (!targetCol) {
      return -1;
    }

    var _sheet$getRoot = sheet.getRoot(),
        cols = _sheet$getRoot.cols;

    return cols.indexOf(targetCol);
  }

  function highlightRow(dragOverCell, container, position) {
    var rowId = dragOverCell.dataset.rowId;

    if (!rowId) {
      return;
    }

    var cells = all('[data-row-id=' + rowId + ']', container);

    forEach(cells, function (cell) {

      // QUIRK: PhantomJS might return object instead of NodeList
      if (isNode(cell)) {
        classes(cell).add('dragover');
        classes(cell).add(position);
      }
    });
  }

  function highlightCol(dragOverCell, container, position) {
    var colId = dragOverCell.dataset.colId;

    if (!colId) {
      return;
    }

    var cells = all('[data-col-id=' + colId + ']', container);

    forEach(cells, function (cell) {

      // QUIRK: PhantomJS might return object instead of NodeList
      if (isNode(cell)) {
        classes(cell).add('dragover');
        classes(cell).add(position);
      }
    });
  }

  function removeHighlight(container) {
    var cells = all('.dragover', container);

    forEach(cells, function (cell) {

      // QUIRK: PhantomJS might return object instead of NodeList
      if (isNode(cell)) {
        classes(cell).remove('dragover');
        classes(cell).remove('top');
        classes(cell).remove('right');
        classes(cell).remove('bottom');
        classes(cell).remove('left');
      }
    });
  }

  function fadeOutRow(row, container) {
    var cells = all('[data-row-id=' + row.id + ']', container);

    forEach(cells, function (cell) {

      // QUIRK: PhantomJS might return object instead of NodeList
      if (isNode(cell)) {
        classes(cell).add('dragged');
      }
    });
  }

  function fadeOutCol(col, container) {
    var cells = all('[data-col-id=' + col.id + ']', container);

    forEach(cells, function (cell) {

      // QUIRK: PhantomJS might return object instead of NodeList
      if (isNode(cell)) {
        classes(cell).add('dragged');
      }
    });
  }

  function removeFadeOut(container) {
    var cells = all('.dragged', container);

    forEach(cells, function (cell) {

      // QUIRK: PhantomJS might return object instead of NodeList
      if (isNode(cell)) {
        classes(cell).remove('dragged');
      }
    });
  }

  function getHorizontalPosition(event, dragOverElement) {
    var bounds = dragOverElement.getBoundingClientRect();

    return event.clientX < bounds.left + bounds.width / 2 ? LEFT : RIGHT;
  }

  function getVerticalPosition(event, dragOverElement) {
    var bounds = dragOverElement.getBoundingClientRect();

    return event.clientY < bounds.top + bounds.height / 2 ? TOP : BOTTOM;
  }

  function getTargetRow(draggedRow, targetRow, verticalPosition, rows) {
    if (rows.indexOf(draggedRow) > rows.indexOf(targetRow)) {
      targetRow = getRowBelow(targetRow, rows);
    }

    if (verticalPosition === TOP) {

      // return row above or row
      return getRowAbove(targetRow, rows);
    } else {

      // return row
      return targetRow;
    }
  }

  function getTargetCol(draggedCol, targetCol, horizontalPosition, cols) {
    if (cols.indexOf(draggedCol) > cols.indexOf(targetCol)) {
      targetCol = getColRight(targetCol, cols);
    }

    if (horizontalPosition === LEFT) {

      // return col left or col
      return getColLeft(targetCol, cols);
    } else {

      // return col
      return targetCol;
    }
  }

  function getRowAbove(row, rows) {
    var index = rows.indexOf(row);

    return rows[Math.max(0, index - 1)];
  }

  function getRowBelow(row, rows) {
    var index = rows.indexOf(row);

    return rows[Math.min(rows.length - 1, index + 1)];
  }

  function getColLeft(col, cols) {
    var index = cols.indexOf(col);

    if (isOutput(col)) {
      var firstOutput = cols.filter(function (col) {
        return isOutput(col);
      })[0];

      var firstOutputIndex = cols.indexOf(firstOutput);

      return cols[Math.max(firstOutputIndex, index - 1)];
    }

    return cols[Math.max(0, index - 1)];
  }

  function getColRight(col, cols) {
    var index = cols.indexOf(col);

    if (isInput(col)) {
      var inputs = cols.filter(function (col) {
        return isInput(col);
      });

      var lastInput = inputs[inputs.length - 1];

      var lastInputIndex = cols.indexOf(lastInput);

      return cols[Math.min(lastInputIndex, index + 1)];
    }

    return cols[Math.min(cols.length - 1, index + 1)];
  }

  // QUIRK: PhantomJS requires check if actual DOM node
  function isNode(node) {
    return node && (node.nodeType === 1 || node.nodeType == 11);
  }

  var dragAndDropModule = {
    __depends__: [DragAndDrop$1, Rules$6],
    __init__: ['dmnDragAndDrop'],
    dmnDragAndDrop: ['type', DragAndDrop$2]
  };

  var _typeof$53 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$62 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$77(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$42(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$53(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$42(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$53(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var DescriptionEditor = function (_Component) {
    _inherits$42(DescriptionEditor, _Component);

    function DescriptionEditor(props, context) {
      _classCallCheck$77(this, DescriptionEditor);

      var _this = _possibleConstructorReturn$42(this, (DescriptionEditor.__proto__ || Object.getPrototypeOf(DescriptionEditor)).call(this, props, context));

      _this.onElementsChanged = function () {
        _this.forceUpdate();
      };

      _this.changeDescription = function (value) {
        _this._modeling.updateProperties(_this._element, {
          description: value
        });
      };

      _this._elementRegistry = context.injector.get('elementRegistry');
      _this._modeling = context.injector.get('modeling');

      _this._changeSupport = _this.context.changeSupport;

      var id = _this.props.context.id;

      _this._element = _this._elementRegistry.get(id);
      return _this;
    }

    _createClass$62(DescriptionEditor, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        if (this._element) {
          this._changeSupport.onElementsChanged(this._element.id, this.onElementsChanged);
        }
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        var autoFocus = this.props.context.autoFocus;

        if (autoFocus && this.node) {
          var editor = getEditor(this.node);

          editor.focus();
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (this._element) {
          this._changeSupport.offElementsChanged(this._element.id, this.onElementsChanged);

          var businessObject = this._element.businessObject;
          var description = businessObject.description;

          // if empty description remove description

          if (isString(description) && !description.length) {
            this.changeDescription(null);
          }
        }
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _this2 = this;

        if (!this._element) {
          return;
        }

        var businessObject = this._element.businessObject;
        var description = businessObject.description;

        if (!isString(description)) {
          return;
        }

        return createVNode(1, 'div', 'context-menu-container description-editor', createComponentVNode(2, Editor, {
          'className': 'dms-input',
          'onChange': this.changeDescription,
          'value': description
        }), 2, null, null, function (node) {
          return _this2.node = node;
        });
      }
    }]);

    return DescriptionEditor;
  }(Component);

  var Editor = function (_EditableComponent) {
    _inherits$42(Editor, _EditableComponent);

    function Editor() {
      _classCallCheck$77(this, Editor);

      return _possibleConstructorReturn$42(this, (Editor.__proto__ || Object.getPrototypeOf(Editor)).apply(this, arguments));
    }

    _createClass$62(Editor, [{
      key: 'render',
      value: function render$$1() {
        return createVNode(1, 'div', this.getClassName(), this.getEditor(), 0);
      }
    }]);

    return Editor;
  }(EditableComponent);

  // helpers //////////

  function getEditor(container) {
    return query('.content-editable', container);
  }

  function _classCallCheck$78(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var LOW_PRIORITY$10 = 500;

  var LOWER_PRIORITY = 750;

  var OFFSET_X = 26;

  var Description = function Description(components, contextMenu, elementRegistry, eventBus, modeling, renderer) {
    var _this = this;

    _classCallCheck$78(this, Description);

    this.addDescription = function (cell) {
      _this._modeling.updateProperties(cell, {
        description: ''
      });

      var container = _this._renderer.getContainer();

      var node = getNodeById(cell.id, container);

      var bounds = node.getBoundingClientRect();

      var position = getPosition(container, bounds);

      _this._contextMenu.open(position, {
        contextMenuType: 'cell-description',
        id: cell.id,
        autoFocus: true,
        offset: {
          x: 4,
          y: 4
        }
      });
    };

    this.removeDescription = function (cell) {
      _this._modeling.updateProperties(cell, {
        description: null
      });

      _this._contextMenu.close();
    };

    this._contextMenu = contextMenu;
    this._modeling = modeling;
    this._renderer = renderer;

    eventBus.on('cell.click', LOWER_PRIORITY, function (event) {

      if (event.defaultPrevented) {
        return;
      }

      var target = event.target,
          id = event.id;

      var element = elementRegistry.get(id);

      if (!element) {
        return;
      }

      var description = getDescription(element);

      if (!description) {
        // prevent focus
        event.preventDefault();
      }

      var container = renderer.getContainer(),
          bounds = target.getBoundingClientRect();

      var position = getPosition(container, bounds);

      contextMenu.open(position, {
        contextMenuType: 'cell-description',
        autoFocus: false,
        id: id,
        offset: {
          x: 4,
          y: 4
        }
      });
    });

    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (context.contextMenuType && context.contextMenuType === 'cell-description') {

        var element = elementRegistry.get(context.id);

        var description = getDescription(element);

        if (isString(description)) {
          return DescriptionEditor;
        }
      }
    });

    components.onGetComponent('context-menu-cell-additional', LOW_PRIORITY$10, function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (context.contextMenuType && context.contextMenuType === 'context-menu') {
        var id = context.id;

        if (!id) {
          return;
        }

        var element = elementRegistry.get(id);

        // element might not be in element registry (e.g. cut)
        if (!element) {
          return;
        }

        var businessObject = element.businessObject;
        var description = businessObject.description;

        var existingDescription = isString(description);

        var className = existingDescription ? 'remove-description' : 'add-description';

        var onClick = existingDescription ? function () {
          return _this.removeDescription(element);
        } : function () {
          return _this.addDescription(element);
        };

        var icon = existingDescription ? 'dmn-icon-clear' : 'dmn-icon-plus';

        return createVNode(1, 'div', 'context-menu-group-entry ' + className, [createVNode(1, 'span', 'context-menu-group-entry-icon ' + icon), isString(description) ? 'Remove' : 'Add', createTextVNode(' Description')], 0, {
          'onClick': onClick
        });
      }
    });
  };

  Description.$inject = ['components', 'contextMenu', 'elementRegistry', 'eventBus', 'modeling', 'renderer'];

  // helpers //////////

  function getPosition(container, bounds) {
    var top = bounds.top,
        left = bounds.left,
        width = bounds.width,
        height = bounds.height;

    return {
      x: left + container.parentNode.scrollLeft - OFFSET_X,
      y: top + container.parentNode.scrollTop,
      width: width + 2 * OFFSET_X,
      height: height
    };
  }

  function getDescription(element) {
    return element && element.businessObject && element.businessObject.description;
  }

  var descriptionModule = {
    __depends__: [ContextMenu$2, InteractionModule],
    __init__: ['description'],
    description: ['type', Description]
  };

  var _createClass$63 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$79(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var INPUT_EXPRESSION_LANGUAGE_OPTIONS = [{
    label: 'FEEL',
    value: 'feel'
  }, {
    label: 'JUEL',
    value: 'juel'
  }, {
    label: 'JavaScript',
    value: 'javascript'
  }, {
    label: 'Groovy',
    value: 'groovy'
  }, {
    label: 'Python',
    value: 'python'
  }, {
    label: 'JRuby',
    value: 'jruby'
  }];

  var ExpressionLanguage = function () {
    function ExpressionLanguage(components, elementRegistry, modeling) {
      var _this = this;

      _classCallCheck$79(this, ExpressionLanguage);

      this._modeling = modeling;

      components.onGetComponent('context-menu-cell-additional', function () {
        var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (context.contextMenuType && context.contextMenuType === 'context-menu') {
          var id = context.id;

          if (!id) {
            return;
          }

          var element = elementRegistry.get(id);

          // element might not be in element registry (e.g. cut)
          if (!element) {
            return;
          }

          var expressionLanguage = element.businessObject.expressionLanguage || (isInput(element.col) ? 'feel' : 'juel');

          return createVNode(1, 'div', 'context-menu-group-entry context-menu-entry-set-expression-language', [createVNode(1, 'div', null, [createVNode(1, 'span', 'context-menu-group-entry-icon dmn-icon-file-code'), createTextVNode('Expression Language')], 4), createComponentVNode(2, InputSelect, {
            'className': 'expression-language',
            'onChange': function onChange(value) {
              return _this.onChange(element, value);
            },
            'options': INPUT_EXPRESSION_LANGUAGE_OPTIONS,
            'value': expressionLanguage
          })], 4);
        }
      });
    }

    _createClass$63(ExpressionLanguage, [{
      key: 'onChange',
      value: function onChange(cell, expressionLanguage) {
        this._modeling.editExpressionLanguage(cell.businessObject, expressionLanguage);
      }
    }]);

    return ExpressionLanguage;
  }();

  ExpressionLanguage.$inject = ['components', 'elementRegistry', 'modeling'];

  var expressionLanguageModule = {
    __init__: ['expressionLanguage'],
    expressionLanguage: ['type', ExpressionLanguage]
  };

  var SPACE_REGEX = /\s/;

  // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar
  var QNAME_REGEX = /^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i;

  // for ID validation as per BPMN Schema (QName - Namespace)
  var ID_REGEX = /^[a-z_][\w-.]*$/i;

  var PLACEHOLDER_REGEX = /\$\{([^}]*)\}/g;

  /**
   * Validates an ID.
   *
   * @param {ModdleElement} businessObject
   * @param {String} id
   *
   * @return {String} error message
   */
  function validateId(businessObject, id) {
    var assigned = businessObject.$model.ids.assigned(id);

    var idExists = assigned && assigned !== businessObject;

    if (!id || idExists) {
      return 'Element must have an unique id.';
    }

    return validateIdFormat(id);
  }

  function validateIdFormat(id) {

    id = stripPlaceholders(id);

    if (containsSpace(id)) {
      return 'Id must not contain spaces.';
    }

    if (!ID_REGEX.test(id)) {

      if (QNAME_REGEX.test(id)) {
        return 'Id must not contain prefix.';
      }

      return 'Id must be a valid QName.';
    }
  }

  function containsSpace(value) {
    return SPACE_REGEX.test(value);
  }

  function stripPlaceholders(id) {

    // replace expression e.g. ${VERSION_TAG}
    // use only the content between ${}
    // for the REGEX check
    return id.replace(PLACEHOLDER_REGEX, '$1');
  }

  var _typeof$54 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$64 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$80(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$43(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$54(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$43(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$54(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var DecisionTablePropertiesComponent$1 = function (_Component) {
    _inherits$43(DecisionTablePropertiesComponent, _Component);

    function DecisionTablePropertiesComponent(props, context) {
      _classCallCheck$80(this, DecisionTablePropertiesComponent);

      var _this = _possibleConstructorReturn$43(this, (DecisionTablePropertiesComponent.__proto__ || Object.getPrototypeOf(DecisionTablePropertiesComponent)).call(this, props, context));

      _this.onElementsChanged = function () {
        _this.forceUpdate();
      };

      _this.setDecisionTableName = function (name) {
        _this.modeling.editDecisionTableName(name);
      };

      _this.setDecisionTableId = function (id) {

        var oldId = _this.getBusinessObject().id;

        if (oldId === id) {
          return;
        }

        _this.modeling.editDecisionTableId(id);
      };

      _this.validateId = function (id) {
        var bo = _this.getBusinessObject();
        return validateId(bo, id);
      };

      inject(_this);
      return _this;
    }

    _createClass$64(DecisionTablePropertiesComponent, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        var injector = this.context.injector;

        this.sheet = injector.get('sheet');
        this.modeling = injector.get('modeling');

        this.setupChangeListeners({ bind: this.getBusinessObject().id });
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this.setupChangeListeners({
          unbind: this.getBusinessObject().id
        });
      }
    }, {
      key: 'setupChangeListeners',
      value: function setupChangeListeners(_ref) {
        var bind = _ref.bind,
            unbind = _ref.unbind;

        if (typeof unbind === 'string') {
          this.changeSupport.offElementsChanged(unbind, this.onElementsChanged);
        }

        if (typeof bind === 'string') {
          this.changeSupport.onElementsChanged(bind, this.onElementsChanged);
        }
      }
    }, {
      key: 'getBusinessObject',
      value: function getBusinessObject() {
        return this.sheet.getRoot().businessObject.$parent;
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var bo = this.getBusinessObject();

        var id = bo.id,
            name = bo.name;

        return createVNode(1, 'header', 'decision-table-properties', [createComponentVNode(2, DecisionTableName, {
          'className': 'decision-table-name',
          'value': name,
          'ctrlForNewline': true,
          'onChange': this.setDecisionTableName,
          'elementId': '__decisionProperties_name',
          'coords': '0:__decisionProperties'
        }), createComponentVNode(2, DecisionTableId, {
          'className': 'decision-table-id',
          'value': id,
          'ctrlForNewline': true,
          'validate': this.validateId,
          'onChange': this.setDecisionTableId,
          'elementId': '__decisionProperties_id',
          'coords': '1:__decisionProperties'
        })], 4);
      }
    }]);

    return DecisionTablePropertiesComponent;
  }(Component);

  DecisionTablePropertiesComponent$1.$inject = ['sheet', 'modeling', 'changeSupport'];

  var DecisionTableName = function (_EditableComponent) {
    _inherits$43(DecisionTableName, _EditableComponent);

    function DecisionTableName(props, context) {
      _classCallCheck$80(this, DecisionTableName);

      var _this2 = _possibleConstructorReturn$43(this, (DecisionTableName.__proto__ || Object.getPrototypeOf(DecisionTableName)).call(this, props, context));

      mixin(_this2, SelectionAware);
      return _this2;
    }

    _createClass$64(DecisionTableName, [{
      key: 'render',
      value: function render$$1() {

        var className = classNames(this.getSelectionClasses(), this.getClassName());

        return createVNode(1, 'h3', className, this.getEditor(), 0, {
          'data-element-id': this.props.elementId,
          'data-coords': this.props.coords,
          'title': 'Decision Name'
        });
      }
    }]);

    return DecisionTableName;
  }(EditableComponent);

  var DecisionTableId = function (_EditableComponent2) {
    _inherits$43(DecisionTableId, _EditableComponent2);

    function DecisionTableId(props, context) {
      _classCallCheck$80(this, DecisionTableId);

      var _this3 = _possibleConstructorReturn$43(this, (DecisionTableId.__proto__ || Object.getPrototypeOf(DecisionTableId)).call(this, props, context));

      mixin(_this3, SelectionAware);
      return _this3;
    }

    _createClass$64(DecisionTableId, [{
      key: 'render',
      value: function render$$1() {

        var className = classNames(this.getSelectionClasses(), this.getClassName());

        return createVNode(1, 'h5', className, this.getEditor(), 0, {
          'title': 'Decision Id',
          'data-element-id': this.props.elementId,
          'data-coords': this.props.coords
        });
      }
    }]);

    return DecisionTableId;
  }(EditableComponent);

  function _classCallCheck$81(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var DecisionTableProperties$1 = function DecisionTableProperties(components) {
    _classCallCheck$81(this, DecisionTableProperties);

    components.onGetComponent('table.before', function () {
      return DecisionTablePropertiesComponent$1;
    });
  };

  DecisionTableProperties$1.$inject = ['components'];

  var tablePropertiesEditorModule = {
    __depends__: [DebounceInput],
    __init__: ['decisionTableProperties'],
    decisionTableProperties: ['type', DecisionTableProperties$1]
  };

  var _typeof$55 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$65 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$82(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$44(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$55(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$44(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$55(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var EditableHitPolicyCell = function (_Component) {
    _inherits$44(EditableHitPolicyCell, _Component);

    function EditableHitPolicyCell(props, context) {
      _classCallCheck$82(this, EditableHitPolicyCell);

      var _this = _possibleConstructorReturn$44(this, (EditableHitPolicyCell.__proto__ || Object.getPrototypeOf(EditableHitPolicyCell)).call(this, props, context));

      _this.onClick = function (event) {
        _this.eventBus.fire('hitPolicy.edit', {
          event: event
        });
      };

      _this.onElementsChanged = function () {
        _this.forceUpdate();
      };

      inject(_this);
      return _this;
    }

    _createClass$65(EditableHitPolicyCell, [{
      key: 'getRoot',
      value: function getRoot() {
        return this.sheet.getRoot();
      }
    }, {
      key: 'componentWillMount',
      value: function componentWillMount() {
        this.changeSupport.onElementsChanged(this.getRoot().id, this.onElementsChanged);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this.changeSupport.offElementsChanged(this.getRoot().id, this.onElementsChanged);
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var root = this.getRoot(),
            businessObject = root.businessObject,
            hitPolicy = businessObject.hitPolicy,
            hitPolicyLabel = hitPolicy.charAt(0),
            aggregation = businessObject.aggregation;

        var aggregationLabel = getAggregationLabel$1(aggregation);

        return createVNode(1, 'th', 'hit-policy header', [hitPolicyLabel, aggregationLabel], 0, {
          'data-hit-policy': 'true',
          'title': 'Hit Policy = ' + hitPolicy,
          'onClick': this.onClick,
          'rowspan': '3'
        });
      }
    }]);

    return EditableHitPolicyCell;
  }(Component);

  EditableHitPolicyCell.$inject = ['changeSupport', 'sheet', 'eventBus'];

  // helpers //////////////////////

  function getAggregationLabel$1(aggregation) {
    switch (aggregation) {
      case 'SUM':
        return '+';
      case 'MIN':
        return '<';
      case 'MAX':
        return '>';
      case 'COUNT':
        return '#';
      default:
        return '';
    }
  }

  var _typeof$56 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$66 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$83(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$45(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$56(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$45(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$56(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var HIT_POLICIES = ['UNIQUE', 'FIRST', 'PRIORITY', 'ANY', 'COLLECT', 'RULE ORDER', 'OUTPUT ORDER'];

  var LIST_FUNCTIONS = ['SUM', 'MIN', 'MAX', 'COUNT'];

  var HitPolicyCellContextMenu = function (_Component) {
    _inherits$45(HitPolicyCellContextMenu, _Component);

    function HitPolicyCellContextMenu(props, context) {
      _classCallCheck$83(this, HitPolicyCellContextMenu);

      var _this = _possibleConstructorReturn$45(this, (HitPolicyCellContextMenu.__proto__ || Object.getPrototypeOf(HitPolicyCellContextMenu)).call(this, props, context));

      _this.onHitPolicyChange = _this.onHitPolicyChange.bind(_this);
      _this.onAggregationChange = _this.onAggregationChange.bind(_this);
      _this.onElementsChanged = _this.onElementsChanged.bind(_this);
      return _this;
    }

    _createClass$66(HitPolicyCellContextMenu, [{
      key: 'onHitPolicyChange',
      value: function onHitPolicyChange(hitPolicy) {
        this._modeling.editHitPolicy(hitPolicy, undefined);
      }
    }, {
      key: 'onAggregationChange',
      value: function onAggregationChange(value) {
        var aggregation = value === '' ? undefined : value;

        this._modeling.editHitPolicy('COLLECT', aggregation);
      }
    }, {
      key: 'onElementsChanged',
      value: function onElementsChanged() {
        this.forceUpdate();
      }
    }, {
      key: 'componentWillMount',
      value: function componentWillMount() {
        var injector = this.context.injector;

        var changeSupport = this._changeSupport = this.context.changeSupport;

        this._sheet = injector.get('sheet');
        this._modeling = injector.get('modeling');

        var root = this._sheet.getRoot(),
            businessObject = root.businessObject,
            hitPolicy = businessObject.hitPolicy,
            aggregation = businessObject.aggregation;

        changeSupport.onElementsChanged(root.id, this.onElementsChanged);

        this.state = {
          hitPolicy: hitPolicy,
          aggregation: aggregation
        };
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        var root = this._sheet.getRoot();

        this._changeSupport.onElementsChanged(root.id, this.onElementsChanged);
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var root = this._sheet.getRoot(),
            businessObject = root.businessObject,
            hitPolicy = businessObject.hitPolicy,
            aggregation = businessObject.aggregation;

        var hitPolicyOptions = HIT_POLICIES.map(function (h) {
          return {
            label: h,
            value: h
          };
        });

        var aggregationOptions = LIST_FUNCTIONS.map(function (l) {
          return {
            label: l === 'NONE' ? '-' : l,
            value: l
          };
        });

        return createVNode(1, 'div', 'context-menu-container hit-policy-edit', [createVNode(1, 'p', 'hit-policy-edit-policy', [createVNode(1, 'label', 'dms-label', createTextVNode('Hit Policy:'), 2), createComponentVNode(2, InputSelect, {
          'className': 'hit-policy-edit-policy-select',
          'onChange': this.onHitPolicyChange,
          'options': hitPolicyOptions,
          'value': hitPolicy
        })], 4), hitPolicy === 'COLLECT' && createVNode(1, 'p', 'hit-policy-edit-operator', [createVNode(1, 'label', 'dms-label', createTextVNode('Aggregation:'), 2), createComponentVNode(2, InputSelect, {
          'className': 'hit-policy-edit-operator-select',
          'onChange': this.onAggregationChange,
          'options': aggregationOptions,
          'value': aggregation
        })], 4)], 0);
      }
    }]);

    return HitPolicyCellContextMenu;
  }(Component);

  function HitPolicyEditingProvider(components, contextMenu, eventBus, renderer) {

    components.onGetComponent('cell', function (_ref) {
      var cellType = _ref.cellType;

      if (cellType === 'before-label-cells') {
        return EditableHitPolicyCell;
      }
    });

    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (context.contextMenuType && context.contextMenuType === 'hit-policy-edit') {
        return HitPolicyCellContextMenu;
      }
    });

    eventBus.on('hitPolicy.edit', function (_ref2) {
      var event = _ref2.event;

      var node = closest(event.target, 'th', true);

      var _node$getBoundingClie = node.getBoundingClientRect(),
          left = _node$getBoundingClie.left,
          top = _node$getBoundingClie.top,
          width = _node$getBoundingClie.width,
          height = _node$getBoundingClie.height;

      var container = renderer.getContainer();

      contextMenu.open({
        x: left + container.parentNode.scrollLeft,
        y: top + container.parentNode.scrollTop,
        width: width,
        height: height
      }, {
        contextMenuType: 'hit-policy-edit',
        offset: {
          x: 4,
          y: 4
        }
      });
    });
  }

  HitPolicyEditingProvider.$inject = ['components', 'contextMenu', 'eventBus', 'renderer'];

  var hitPolicyEditorModule = {
    __depends__: [ContextMenu$2],
    __init__: ['hitPolicyProvider'],
    hitPolicyProvider: ['type', HitPolicyEditingProvider]
  };

  var _createClass$67 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$84(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * A keyboard abstraction that may be activated and
   * deactivated by users at will, consuming key events
   * and triggering diagram actions.
   *
   * The implementation fires the following key events that allow
   * other components to hook into key handling:
   *
   *  - keyboard.bind
   *  - keyboard.unbind
   *  - keyboard.init
   *  - keyboard.destroy
   *
   * All events contain the fields (node, listeners).
   *
   * A default binding for the keyboard may be specified via the
   * `keyboard.bindTo` configuration option.
   *
   * @param {Config} config
   * @param {EventBus} eventBus
   * @param {EditorActions} editorActions
   */

  var Keyboard$1 = function () {
    function Keyboard(config, eventBus, editorActions) {
      var _this = this;

      _classCallCheck$84(this, Keyboard);

      this._init = function () {
        _this._registerDefaultBindings();

        _this._fire('init');
      };

      this._destroy = function () {
        _this._fire('destroy');

        _this.unbind();
        _this._listeners = null;
      };

      this._keyHandler = function (event$$1) {

        var i,
            l,
            listeners = _this._listeners,
            code = event$$1.keyCode || event$$1.charCode || -1;

        for (i = 0; l = listeners[i]; i++) {
          if (l(code, event$$1)) {
            event$$1.preventDefault();
            event$$1.stopPropagation();

            return;
          }
        }
      };

      this.unbind = function () {
        var node = _this._node;

        if (node) {
          _this._fire('unbind');

          // unbind key events
          componentEvent.unbind(node, 'keydown', _this._keyHandler, true);
        }

        _this._node = null;
      };

      this._config = config || {};
      this._editorActions = editorActions;
      this._eventBus = eventBus;

      this._listeners = [];

      eventBus.on('table.destroy', this._destroy);
      eventBus.on('table.init', this._init);

      eventBus.on('attach', function () {

        if (_this._config.bindTo) {
          _this.bind(config.bindTo);
        }
      });

      eventBus.on('detach', this.unbind);
    }

    // our key handler is a singleton that passes
    // (keycode, modifiers) to each listener.
    //
    // listeners must indicate that they handled a key event
    // by returning true. This stops the event propagation.
    //


    _createClass$67(Keyboard, [{
      key: 'bind',
      value: function bind(node) {
        // make sure that the keyboard is only bound once to the DOM
        this.unbind();

        this._node = node;

        // bind key events
        componentEvent.bind(node, 'keydown', this._keyHandler, true);

        this._fire('bind');
      }
    }, {
      key: 'getBinding',
      value: function getBinding() {
        return this._node;
      }
    }, {
      key: '_fire',
      value: function _fire(event$$1) {
        this._eventBus.fire('keyboard.' + event$$1, {
          node: this._node,
          listeners: this._listeners
        });
      }
    }, {
      key: '_registerDefaultBindings',
      value: function _registerDefaultBindings() {

        var listeners = this._listeners;

        var editorActions = this._editorActions;

        // init default listeners

        // undo
        // (CTRL|CMD) + Z
        function undo(key, modifiers) {

          if (isCmd$2(modifiers) && !isShift$1(modifiers) && key === 90) {
            editorActions.trigger('undo');

            return true;
          }
        }

        // redo
        // CTRL + Y
        // CMD + SHIFT + Z
        function redo(key, modifiers) {

          if (isCmd$2(modifiers) && (key === 89 || key === 90 && isShift$1(modifiers))) {
            editorActions.trigger('redo');

            return true;
          }
        }

        listeners.push(undo);
        listeners.push(redo);

        function selectCell(key, event$$1) {

          if (key !== 13 || isCmd$2(event$$1)) {
            return;
          }

          if (!findSelectableAncestor(event$$1.target)) {
            return;
          }

          var cmd = isShift$1(event$$1) ? 'selectCellAbove' : 'selectCellBelow';

          editorActions.trigger(cmd);

          return true;
        }

        listeners.push(selectCell);
      }

      /**
       * Add a listener function that is notified with (key, modifiers) whenever
       * the keyboard is bound and the user presses a key.
       *
       * @param {Function} listenerFn
       */

    }, {
      key: 'addListener',
      value: function addListener(listenerFn) {
        this._listeners.unshift(listenerFn);
      }
    }, {
      key: 'removeListener',
      value: function removeListener(listenerFn) {
        this._listeners = this._listeners.filter(function (l) {
          return l !== listenerFn;
        });
      }
    }]);

    return Keyboard;
  }();

  Keyboard$1.$inject = ['config.keyboard', 'eventBus', 'editorActions'];

  var Keyboard$2 = {
    __depends__: [EditorActions$3],
    __init__: ['keyboard'],
    keyboard: ['type', Keyboard$1]
  };

  var _typeof$57 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$68 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$85(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$46(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$57(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$46(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$57(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  /**
   * A handler responsible for updating the underlying DMN
   * once changes on the table happen.
   */

  var DmnUpdater = function (_CommandInterceptor) {
    _inherits$46(DmnUpdater, _CommandInterceptor);

    function DmnUpdater(eventBus, sheet) {
      _classCallCheck$85(this, DmnUpdater);

      var _this = _possibleConstructorReturn$46(this, (DmnUpdater.__proto__ || Object.getPrototypeOf(DmnUpdater)).call(this, eventBus));

      _this.executed(['row.add', 'row.remove', 'col.add', 'col.remove'], ifDmn(function (e) {
        var context = e.context;

        var element = context.row || context.col;

        _this.updateRoot(element, context.oldRoot);
      }));

      _this.reverted(['row.add', 'row.remove', 'col.add', 'col.remove'], ifDmn(function (e) {
        var context = e.context;

        var element = context.row || context.col;

        _this.updateRoot(element, context.newRoot);
      }));

      return _this;
    }

    _createClass$68(DmnUpdater, [{
      key: 'updateRoot',
      value: function updateRoot(element, oldRoot) {
        var _this2 = this;

        var newRoot = element.root;

        var businessObject = element.businessObject;

        if (is(element, 'dmn:DecisionRule')) {

          // we're removing
          if (oldRoot) {
            var oldTable = oldRoot.businessObject;

            var oldRules = oldTable.get('rule');
            var oldIdx = oldRules.indexOf(businessObject);

            // unwire Row <-> Table
            oldRules.splice(oldIdx, 1);
            businessObject.$parent = null;
          }

          // we're adding
          if (newRoot) {
            var newTable = newRoot.businessObject;

            var newIdx = newRoot.rows.indexOf(element);

            // wire Row <-> Table
            newTable.get('rule').splice(newIdx, 0, businessObject);
            businessObject.$parent = newTable;

            element.cells.forEach(function (cell, idx) {

              // wire Cell <-> Row
              _this2.wireCell(cell, element, idx);
            });
          }
        }

        if (is(element, 'dmn:InputClause') || is(element, 'dmn:OutputClause')) {

          var collection = void 0,
              collectionIdx = void 0;

          // we're removing
          if (oldRoot) {
            var _oldTable = oldRoot.businessObject;

            var inputs = _oldTable.get('input');
            var outputs = _oldTable.get('output');

            if (is(element, 'dmn:InputClause')) {
              collection = inputs;
              collectionIdx = inputs.indexOf(businessObject);
            }

            if (is(element, 'dmn:OutputClause')) {
              collection = outputs;
              collectionIdx = outputs.indexOf(businessObject);
            }

            if (collectionIdx === -1) {
              throw new Error('inconsistent model: clause not in table');
            }

            // unwire Col <-> Table
            collection.splice(collectionIdx, 1);
            businessObject.$parent = null;

            element.cells.forEach(function (cel, rowIdx) {

              // unwire Cell <-> Row
              _this2.unwireCell(cel, oldRoot.rows[rowIdx]);
            });
          }

          if (newRoot) {
            var _newTable = newRoot.businessObject;

            var _inputs = _newTable.get('input');
            var _outputs = _newTable.get('output');

            var colIdx = newRoot.cols.indexOf(element);

            var _collectionIdx = void 0,
                _collection = void 0;

            if (is(element, 'dmn:InputClause')) {
              _collection = _inputs;
              _collectionIdx = colIdx;
            }

            if (is(element, 'dmn:OutputClause')) {
              _collection = _outputs;
              _collectionIdx = colIdx - _inputs.length;
            }

            // wire Col <-> Table
            _collection.splice(_collectionIdx, 0, businessObject);
            businessObject.$parent = _newTable;

            element.cells.forEach(function (cell, rowIdx) {

              // wire Cell <-> Row
              _this2.wireCell(cell, newRoot.rows[rowIdx], colIdx);
            });
          }
        }
      }
    }, {
      key: 'unwireCell',
      value: function unwireCell(cell, oldRow) {

        var cellBo = cell.businessObject;

        var oldRowBo = oldRow.businessObject;

        var inputEntries = oldRowBo.get('inputEntry');
        var outputEntries = oldRowBo.get('outputEntry');

        var collection = void 0,
            collectionIdx = void 0;

        // remove from inputEntries
        if (is(cell, 'dmn:UnaryTests')) {
          collection = inputEntries;
        }

        // remove from outputEntries
        if (is(cell, 'dmn:LiteralExpression')) {
          collection = outputEntries;
        }

        collectionIdx = collection.indexOf(cellBo);

        if (collectionIdx === -1) {
          throw new Error('cell not in row');
        }

        // unwire Cell <-> Row relationship
        collection.splice(collectionIdx, 1);
        cellBo.$parent = null;
      }
    }, {
      key: 'wireCell',
      value: function wireCell(cell, row, colIdx) {

        var cellBo = cell.businessObject;

        var rowBo = row.businessObject;

        var inputEntries = rowBo.get('inputEntry');
        var outputEntries = rowBo.get('outputEntry');

        var collection = void 0,
            collectionIdx = void 0;

        // ensure we handle already wired cells
        if (cellBo.$parent === rowBo) {
          return;
        }

        // add to inputEntries
        if (is(cell, 'dmn:UnaryTests')) {
          collection = inputEntries;
          collectionIdx = colIdx;
        }

        // add to outputEntries
        if (is(cell, 'dmn:LiteralExpression')) {
          collection = outputEntries;
          collectionIdx = colIdx - inputEntries.length;
        }

        // wire Cell <-> Row relationship
        collection.splice(collectionIdx, 0, cellBo);
        cellBo.$parent = rowBo;
      }
    }]);

    return DmnUpdater;
  }(CommandInterceptor);

  DmnUpdater.$inject = ['eventBus', 'sheet'];

  // helpers //////////////////////

  /**
   * Make sure the event listener is only called
   * if the touched element is a DMN element.
   *
   * @param  {Function} fn
   * @return {Function} guarded function
   */
  function ifDmn(fn) {

    return function (event) {

      var context = event.context,
          element = context.row || context.col;

      if (is(element, 'dmn:DMNElement')) {
        fn(event);
      }
    };
  }

  var _createClass$69 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$86(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var DmnFactory = function () {
    function DmnFactory(moddle) {
      _classCallCheck$86(this, DmnFactory);

      this._model = moddle;
    }

    _createClass$69(DmnFactory, [{
      key: 'create',
      value: function create(type) {
        var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var element = this._model.create(type, attrs || {});

        if (is(element, 'dmn:InputClause')) {

          if (attrs.inputExpression) {
            element.inputExpression = attrs.inputExpression;
          } else {
            element.inputExpression = this.create('dmn:LiteralExpression', {
              typeRef: 'string'
            });

            element.inputExpression.$parent = element;
          }
        }

        if (is(element, 'dmn:OutputClause')) {
          element.typeRef = attrs.typeRef || 'string';
        }

        if (is(element, 'dmn:UnaryTests') || is(element, 'dmn:LiteralExpression')) {

          element.text = attrs.text || '';
        }

        this._ensureId(element);

        return element;
      }
    }, {
      key: '_needsId',
      value: function _needsId(element) {
        return is(element, 'dmn:DMNElement');
      }
    }, {
      key: '_ensureId',
      value: function _ensureId(element) {

        // generate semantic ids for elements
        // dmn:UnaryTests -> UnaryTests_ID
        var prefix = (element.$type || '').replace(/^[^:]*:/g, '') + '_';

        if (!element.id && this._needsId(element)) {
          element.id = this._model.ids.nextPrefixed(prefix, element);
        }
      }
    }]);

    return DmnFactory;
  }();

  DmnFactory.$inject = ['moddle'];

  var _typeof$58 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _extends$12 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass$70 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _get$2 = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;if (getter === undefined) {
        return undefined;
      }return getter.call(receiver);
    }
  };

  function _objectWithoutProperties$6(obj, keys) {
    var target = {};for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
    }return target;
  }

  function _classCallCheck$87(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$47(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$58(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$47(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$58(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ElementFactory$3 = function (_BaseElementFactory) {
    _inherits$47(ElementFactory, _BaseElementFactory);

    function ElementFactory(dmnFactory) {
      _classCallCheck$87(this, ElementFactory);

      var _this = _possibleConstructorReturn$47(this, (ElementFactory.__proto__ || Object.getPrototypeOf(ElementFactory)).call(this));

      _this._dmnFactory = dmnFactory;
      return _this;
    }

    _createClass$70(ElementFactory, [{
      key: 'create',
      value: function create(tType, attrs) {

        var dmnFactory = this._dmnFactory;

        var businessObject = attrs.businessObject,
            type = attrs.type,
            additionalAttrs = _objectWithoutProperties$6(attrs, ['businessObject', 'type']);

        if (!businessObject) {

          if (!type) {

            if (tType === 'root') {
              type = 'dmn:DecisionTable';
            } else if (tType === 'cell') {
              var col = additionalAttrs.col;

              if (is(col, 'dmn:OutputClause')) {
                type = 'dmn:LiteralExpression';
              }

              if (is(col, 'dmn:InputClause')) {
                type = 'dmn:UnaryTests';
              }
            }

            if (!type) {
              throw new Error('cannot guess <type>');
            }
          }

          businessObject = dmnFactory.create(type);
        }

        return _get$2(ElementFactory.prototype.__proto__ || Object.getPrototypeOf(ElementFactory.prototype), 'create', this).call(this, tType, _extends$12({
          businessObject: businessObject,
          id: businessObject.id
        }, additionalAttrs));
      }
    }]);

    return ElementFactory;
  }(ElementFactory$2);

  ElementFactory$3.$inject = ['dmnFactory'];

  var _typeof$59 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$71 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$88(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$48(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$59(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$48(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$59(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ID$1 = 'id';

  var IdChangeBehavior = function (_CommandInterceptor) {
    _inherits$48(IdChangeBehavior, _CommandInterceptor);

    function IdChangeBehavior(eventBus) {
      _classCallCheck$88(this, IdChangeBehavior);

      var _this = _possibleConstructorReturn$48(this, (IdChangeBehavior.__proto__ || Object.getPrototypeOf(IdChangeBehavior)).call(this, eventBus));

      _this.executed('updateProperties', _this.updateIds.bind(_this));
      return _this;
    }

    _createClass$71(IdChangeBehavior, [{
      key: 'updateIds',
      value: function updateIds(_ref) {
        var context = _ref.context;
        var element = context.element,
            oldProperties = context.oldProperties,
            properties = context.properties;

        if (!is(element, 'dmn:DRGElement') || !isIdChange$1(oldProperties, properties)) {
          return;
        }

        var drgElements = getDrgElements(element);

        drgElements.forEach(function (drgElement) {
          updateElementReferences(drgElement, oldProperties.id, properties.id);

          updateEdges(drgElement, oldProperties.id, properties.id);
        });
      }
    }]);

    return IdChangeBehavior;
  }(CommandInterceptor);

  IdChangeBehavior.$inject = ['eventBus'];

  // helpers //////////////////////

  function isIdChange$1(oldProperties, properties) {
    return ID$1 in oldProperties && ID$1 in properties;
  }

  function getDrgElements(element) {
    var definitions = element.$parent;

    var drgElements = definitions.drgElements;

    return drgElements;
  }

  function updateElementReferences(element, oldId, id) {

    var handlers = {

      authorityRequirement: function authorityRequirement() {
        element.authorityRequirement.forEach(function (authorityRequirement) {
          var requiredAuthority = authorityRequirement.requiredAuthority,
              requiredDecision = authorityRequirement.requiredDecision,
              requiredInput = authorityRequirement.requiredInput;

          if (requiredAuthority && requiredAuthority.href === '#' + oldId) {
            requiredAuthority.href = '#' + id;
          }

          if (requiredDecision && requiredDecision.href === '#' + oldId) {
            requiredDecision.href = '#' + id;
          }

          if (requiredInput && requiredInput.href === '#' + oldId) {
            requiredInput.href = '#' + id;
          }
        });
      },

      informationRequirement: function informationRequirement() {
        element.informationRequirement.forEach(function (informationRequirement) {
          var requiredDecision = informationRequirement.requiredDecision,
              requiredInput = informationRequirement.requiredInput;

          if (requiredDecision && requiredDecision.href === '#' + oldId) {
            requiredDecision.href = '#' + id;
          }

          if (requiredInput && requiredInput.href === '#' + oldId) {
            requiredInput.href = '#' + id;
          }
        });
      },

      knowledgeRequirement: function knowledgeRequirement() {
        element.knowledgeRequirement.forEach(function (knowledgeRequirement) {
          var requiredKnowledge = knowledgeRequirement.requiredKnowledge;

          if (requiredKnowledge && requiredKnowledge.href === '#' + oldId) {
            requiredKnowledge.href = '#' + id;
          }
        });
      }

    };

    forEach(handlers, function (handler, key) {

      if (element[key]) {
        handler();
      }
    });
  }

  function updateEdges(element, oldId, id) {

    if (element.extensionElements) {
      element.extensionElements.values.forEach(function (extensionElement) {

        if (is(extensionElement, 'biodi:Edge')) {

          if (extensionElement.source === oldId) {
            extensionElement.source = id;
          }
        }
      });
    }
  }

  var _createClass$72 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$89(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * A handler that implements row addition.
   */
  var AddRowHandler = function () {
    function AddRowHandler(sheet, elementFactory) {
      _classCallCheck$89(this, AddRowHandler);

      this._sheet = sheet;
      this._elementFactory = elementFactory;
    }

    /**
     * <do>
     */

    _createClass$72(AddRowHandler, [{
      key: 'execute',
      value: function execute(context) {

        var sheet = this._sheet,
            elementFactory = this._elementFactory,
            root = sheet.getRoot();

        var row = context.row,
            index = context.index;

        if (typeof index === 'undefined') {
          index = context.index = root.rows.length;
        }

        context.newRoot = root;

        if (!row.cells.length) {
          root.cols.forEach(function (col, idx) {
            var cell = elementFactory.create('cell', { row: row, col: col });

            row.cells[idx] = cell;
          });
        }

        sheet.addRow(row, index);

        return sheet.getRoot();
      }

      /**
       * <undo>
       */

    }, {
      key: 'revert',
      value: function revert(context) {
        var row = context.row;

        var sheet = this._sheet;

        sheet.removeRow(row);

        return sheet.getRoot();
      }
    }]);

    return AddRowHandler;
  }();

  AddRowHandler.$inject = ['sheet', 'elementFactory'];

  var _createClass$73 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$90(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * A handler that implements row deletion.
   */
  var RemoveRowHandler = function () {
    function RemoveRowHandler(sheet) {
      _classCallCheck$90(this, RemoveRowHandler);

      this._sheet = sheet;
    }

    /**
     * <do>
     */

    _createClass$73(RemoveRowHandler, [{
      key: 'execute',
      value: function execute(context) {

        var sheet = this._sheet,
            root = sheet.getRoot();

        var row = context.row;

        // retrieve and remember previous row position

        var oldIndex = context.oldIndex = root.rows.indexOf(row);

        context.oldRoot = row.root;

        if (oldIndex === -1) {
          throw new Error('row#' + row.id + ' not in sheet');
        }

        sheet.removeRow(row);

        return sheet.getRoot();
      }

      /**
       * <undo>
       */

    }, {
      key: 'revert',
      value: function revert(context) {
        var row = context.row,
            oldIndex = context.oldIndex;

        var sheet = this._sheet;

        sheet.addRow(row, oldIndex);

        return sheet.getRoot();
      }
    }]);

    return RemoveRowHandler;
  }();

  RemoveRowHandler.$inject = ['sheet'];

  var _createClass$74 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$91(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * A handler that implements row movement.
   */
  var MoveRowHandler = function () {
    function MoveRowHandler(modeling) {
      _classCallCheck$91(this, MoveRowHandler);

      this._modeling = modeling;
    }

    /**
     * <preexecute>
     */

    _createClass$74(MoveRowHandler, [{
      key: 'preExecute',
      value: function preExecute(context) {
        var row = context.row;

        this._modeling.removeRow(row);
      }

      /**
       * <postexecute>
       */

    }, {
      key: 'postExecute',
      value: function postExecute(context) {
        var row = context.row,
            index = context.index;

        this._modeling.addRow(row, index);
      }
    }]);

    return MoveRowHandler;
  }();

  MoveRowHandler.$inject = ['modeling'];

  var _createClass$75 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$92(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * A handler that implements column addition.
   */
  var AddColHandler = function () {
    function AddColHandler(sheet, elementFactory) {
      _classCallCheck$92(this, AddColHandler);

      this._sheet = sheet;
      this._elementFactory = elementFactory;
    }

    /**
     * <do>
     */

    _createClass$75(AddColHandler, [{
      key: 'execute',
      value: function execute(context) {

        var sheet = this._sheet,
            elementFactory = this._elementFactory,
            root = sheet.getRoot();

        var col = context.col,
            index = context.index;

        if (typeof index === 'undefined') {
          index = context.index = root.cols.length;
        }

        context.newRoot = root;

        if (!col.cells.length) {
          root.rows.forEach(function (row, idx) {
            var cell = elementFactory.create('cell', { row: row, col: col });

            col.cells[idx] = cell;
          });
        }

        sheet.addCol(col, index);

        return sheet.getRoot();
      }

      /**
       * <undo>
       */

    }, {
      key: 'revert',
      value: function revert(context) {
        var col = context.col;

        var sheet = this._sheet;

        sheet.removeCol(col);

        return sheet.getRoot();
      }
    }]);

    return AddColHandler;
  }();

  AddColHandler.$inject = ['sheet', 'elementFactory'];

  var _createClass$76 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$93(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * A handler that implements column deletion.
   */
  var RemoveColHandler = function () {
    function RemoveColHandler(sheet, elementFactory) {
      _classCallCheck$93(this, RemoveColHandler);

      this._sheet = sheet;
      this._elementFactory = elementFactory;
    }

    /**
     * <do>
     */

    _createClass$76(RemoveColHandler, [{
      key: 'execute',
      value: function execute(context) {

        var sheet = this._sheet;

        var col = context.col;

        var root = context.oldRoot = col.root;

        // retrieve and remember previous col position
        var oldIndex = context.oldIndex = root.cols.indexOf(col);

        if (oldIndex === -1) {
          throw new Error('col#' + col.id + ' not in sheet');
        }

        sheet.removeCol(col);

        return sheet.getRoot();
      }

      /**
       * <undo>
       */

    }, {
      key: 'revert',
      value: function revert(context) {
        var col = context.col,
            oldIndex = context.oldIndex;

        var sheet = this._sheet;

        sheet.addCol(col, oldIndex);

        return sheet.getRoot();
      }
    }]);

    return RemoveColHandler;
  }();

  RemoveColHandler.$inject = ['sheet', 'elementFactory'];

  var _createClass$77 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$94(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * A handler that implements col movement.
   */
  var MoveColHandler = function () {
    function MoveColHandler(modeling) {
      _classCallCheck$94(this, MoveColHandler);

      this._modeling = modeling;
    }

    /**
     * <preexecute>
     */

    _createClass$77(MoveColHandler, [{
      key: 'preExecute',
      value: function preExecute(context) {
        var col = context.col;

        this._modeling.removeCol(col);
      }

      /**
       * <postexecute>
       */

    }, {
      key: 'postExecute',
      value: function postExecute(context) {
        var col = context.col,
            index = context.index;

        this._modeling.addCol(col, index);
      }
    }]);

    return MoveColHandler;
  }();

  MoveColHandler.$inject = ['modeling'];

  var _createClass$78 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$95(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * A handler that implements cell editing.
   *
   * Per default, this handler does nothing.
   * Interested parties may hook into the edit commands
   * `preExecute` or `postExecute` phases to carry out
   * the actual editing.
   */
  var EditCellHandler = function () {
    function EditCellHandler() {
      _classCallCheck$95(this, EditCellHandler);
    }

    _createClass$78(EditCellHandler, [{
      key: "execute",

      /**
       * <do>
       */
      value: function execute(context) {
        var cell = context.cell;

        return cell;
      }

      /**
       * <undo>
       */

    }, {
      key: "revert",
      value: function revert(context) {
        var cell = context.cell;

        return cell;
      }
    }]);

    return EditCellHandler;
  }();

  var _extends$13 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass$79 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$96(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * The basic modeling entry point.
   *
   * @param {EventBus} eventBus
   * @param {ElementFactory} elementFactory
   * @param {CommandStack} commandStack
   */

  var Modeling$2 = function () {
    function Modeling(eventBus, elementFactory, commandStack) {
      var _this = this;

      _classCallCheck$96(this, Modeling);

      this._eventBus = eventBus;
      this._elementFactory = elementFactory;
      this._commandStack = commandStack;

      eventBus.on('table.init', function () {

        // register modeling handlers
        registerHandlers(_this.getHandlers(), commandStack);
      });
    }

    _createClass$79(Modeling, [{
      key: 'getHandlers',
      value: function getHandlers() {
        return Modeling._getHandlers();
      }
    }, {
      key: '_create',
      value: function _create(type, attrs) {
        if (attrs instanceof Base$2) {
          return attrs;
        } else {
          return this._elementFactory.create(type, attrs);
        }
      }

      // public API

    }, {
      key: 'addRow',
      value: function addRow(attrs, index) {
        var row = this._create('row', attrs);

        var context = {
          row: row,
          index: index
        };

        this._commandStack.execute('row.add', context);

        return row;
      }
    }, {
      key: 'removeRow',
      value: function removeRow(row) {
        this._commandStack.execute('row.remove', { row: row });
      }
    }, {
      key: 'moveRow',
      value: function moveRow(row, index) {
        var context = {
          row: row,
          index: index
        };

        this._commandStack.execute('row.move', context);
      }
    }, {
      key: 'addCol',
      value: function addCol(attrs, index) {
        var col = this._create('col', attrs);

        var context = {
          col: col,
          index: index
        };

        this._commandStack.execute('col.add', context);

        return col;
      }
    }, {
      key: 'removeCol',
      value: function removeCol(col) {
        this._commandStack.execute('col.remove', { col: col });
      }
    }, {
      key: 'moveCol',
      value: function moveCol(col, index) {
        var context = {
          col: col,
          index: index
        };

        this._commandStack.execute('col.move', context);
      }
    }, {
      key: 'editCell',
      value: function editCell(cell, changedAttrs) {
        var context = _extends$13({
          cell: cell
        }, changedAttrs);

        this._commandStack.execute('cell.edit', context);
      }
    }], [{
      key: '_getHandlers',
      value: function _getHandlers() {
        return {
          'row.add': AddRowHandler,
          'row.remove': RemoveRowHandler,
          'row.move': MoveRowHandler,

          'col.add': AddColHandler,
          'col.remove': RemoveColHandler,
          'col.move': MoveColHandler,

          'cell.edit': EditCellHandler
        };
      }
    }]);

    return Modeling;
  }();

  Modeling$2.$inject = ['eventBus', 'elementFactory', 'commandStack'];

  // helpers /////////////


  /**
   * Register handlers with the command stack
   *
   * @param {Object} handlers { id -> Handler } map
   * @param {CommandStack} commandStack
   */
  function registerHandlers(handlers, commandStack) {
    forEach(handlers, function (handler, id) {
      commandStack.registerHandler(id, handler);
    });
  }

  var _createClass$80 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$97(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * A handler that implements adding/removing allowed values.
   */

  var UpdateAllowedValuesHandler = function () {
    function UpdateAllowedValuesHandler(dmnFactory, moddle, modeling) {
      _classCallCheck$97(this, UpdateAllowedValuesHandler);

      this._dmnFactory = dmnFactory;
      this._moddle = moddle;
      this._modeling = modeling;
    }

    /**
     * <do>
     */

    _createClass$80(UpdateAllowedValuesHandler, [{
      key: 'execute',
      value: function execute(context) {
        var element = context.element,
            allowedValues = context.allowedValues;

        var isInput$$1 = is(element, 'dmn:InputClause');

        if (isInput$$1) {

          if (element.inputValues) {
            context.oldAllowedValues = element.inputValues.text;
          } else {

            if (!isNull$2(allowedValues)) {
              element.inputValues = this._dmnFactory.create('dmn:UnaryTests', {
                text: ''
              });
            }
          }

          if (isNull$2(allowedValues)) {
            if (element.inputValues) {
              delete element.inputValues;
            }
          } else {
            element.inputValues.text = allowedValues.join(',');
          }
        } else {

          if (element.outputValues && element) {
            context.oldAllowedValues = element.outputValues.text;
          } else {

            if (!isNull$2(allowedValues)) {
              element.outputValues = this._dmnFactory.create('dmn:UnaryTests', {
                text: ''
              });
            }
          }

          if (isNull$2(allowedValues)) {
            if (element.outputValues) {
              delete element.outputValues;
            }
          } else {
            element.outputValues.text = allowedValues.join(',');
          }
        }

        return element;
      }

      /**
       * <undo>
       */

    }, {
      key: 'revert',
      value: function revert(context) {
        var element = context.element,
            oldAllowedValues = context.oldAllowedValues;

        var isInput$$1 = is(element, 'dmn:InputClause');

        if (isInput$$1) {

          if (oldAllowedValues) {

            if (!element.inputValues) {
              element.inputValues = this._dmnFactory.create('dmn:UnaryTests', {
                text: ''
              });
            }

            element.inputValues.text = oldAllowedValues;
          } else {
            delete element.inputValues;
          }
        } else {

          if (oldAllowedValues) {

            if (!element.outputValues) {
              element.outputValues = this._dmnFactory.create('dmn:UnaryTests', {
                text: ''
              });
            }

            element.outputValues.text = oldAllowedValues;
          } else {
            delete element.outputValues;
          }
        }

        return element;
      }
    }]);

    return UpdateAllowedValuesHandler;
  }();

  UpdateAllowedValuesHandler.$inject = ['dmnFactory', 'moddle', 'modeling'];

  // helpers //////////////////////

  function isNull$2(value) {
    return value === null;
  }

  var _extends$14 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass$81 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _defineProperty$2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }return obj;
  }

  function _toConsumableArray$9(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function _classCallCheck$98(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var ID$2 = 'id';

  /**
   * A generic handler that implements property editing.
   */

  var EditPropertiesHandler = function () {
    function EditPropertiesHandler(elementRegistry, moddle) {
      _classCallCheck$98(this, EditPropertiesHandler);

      this._elementRegistry = elementRegistry;
      this._moddle = moddle;
    }

    /**
     * <do>
     */

    _createClass$81(EditPropertiesHandler, [{
      key: 'execute',
      value: function execute(context) {
        var element = context.element,
            properties = context.properties;

        var bo = getBusinessObject(element);

        var _updateProperties = this.updateProperties(bo, properties),
            changed = _updateProperties.changed,
            oldProperties = _updateProperties.oldProperties;

        context.oldProperties = oldProperties;

        return [].concat(_toConsumableArray$9(changed), [element]);
      }

      /**
       * <undo>
       */

    }, {
      key: 'revert',
      value: function revert(context) {
        var element = context.element,
            oldProperties = context.oldProperties;

        var bo = getBusinessObject(element);

        var _updateProperties2 = this.updateProperties(bo, oldProperties),
            changed = _updateProperties2.changed;

        return [].concat(_toConsumableArray$9(changed), [element]);
      }

      /**
       * Update properties of the given business object
       * and return { changed, oldProperties }.
       */

    }, {
      key: 'updateProperties',
      value: function updateProperties(bo, newProps) {
        var _this = this;

        var ids = this._moddle.ids;

        // Reduce over all new properties and return
        //
        // {
        //  changed,
        //  oldProperties
        // }
        return reduce(newProps, function (result, value, key) {

          var propertyValue = bo.get(key);

          // handle nested update
          if (isContainer(value)) {

            if (!isContainer(propertyValue)) {
              throw new Error('non-existing property <' + key + '>: cannot update values');
            }

            var _updateProperties3 = _this.updateProperties(propertyValue, value),
                changed = _updateProperties3.changed,
                oldProperties = _updateProperties3.oldProperties;

            return {
              changed: [].concat(_toConsumableArray$9(result.changed), _toConsumableArray$9(changed), [propertyValue]),
              oldProperties: _extends$14({}, result.oldProperties, _defineProperty$2({}, key, oldProperties))
            };
          }

          // handle ID change
          if (key === ID$2 && isIdChange$2(bo, value)) {
            ids.unclaim(bo[ID$2]);

            _this._elementRegistry.updateId(bo, value);

            ids.claim(value, bo);
          }

          // handle plain update
          bo.set(key, value);

          return {
            changed: result.changed,
            oldProperties: _extends$14({}, result.oldProperties, _defineProperty$2({}, key, propertyValue))
          };
        }, { changed: [], oldProperties: {} });
      }
    }]);

    return EditPropertiesHandler;
  }();

  EditPropertiesHandler.$inject = ['elementRegistry', 'moddle'];

  // helpers //////////////////////

  function isIdChange$2(element, newId) {
    return element[ID$2] !== newId;
  }

  function isContainer(o) {
    return isDefined(o) && isObject(o);
  }

  var _createClass$82 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$99(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var IdClaimHandler$1 = function () {
    function IdClaimHandler(moddle) {
      _classCallCheck$99(this, IdClaimHandler);

      this._moddle = moddle;
    }

    /**
     * <do>
     */

    _createClass$82(IdClaimHandler, [{
      key: 'execute',
      value: function execute(context) {
        var ids = this._moddle.ids,
            id = context.id,
            element = context.element,
            claiming = context.claiming;

        if (claiming) {
          ids.claim(id, element);
        } else {
          ids.unclaim(id);
        }
      }

      /**
       * <undo>
       */

    }, {
      key: 'revert',
      value: function revert(context) {
        var ids = this._moddle.ids,
            id = context.id,
            element = context.element,
            claiming = context.claiming;

        if (claiming) {
          ids.unclaim(id);
        } else {
          ids.claim(id, element);
        }
      }
    }]);

    return IdClaimHandler;
  }();

  IdClaimHandler$1.$inject = ['moddle'];

  var _typeof$60 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$83 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _get$3 = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;if (getter === undefined) {
        return undefined;
      }return getter.call(receiver);
    }
  };

  function _classCallCheck$100(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$49(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$60(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$49(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$60(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var Modeling$3 = function (_BaseModeling) {
    _inherits$49(Modeling, _BaseModeling);

    function Modeling(eventBus, elementFactory, commandStack, sheet) {
      _classCallCheck$100(this, Modeling);

      var _this = _possibleConstructorReturn$49(this, (Modeling.__proto__ || Object.getPrototypeOf(Modeling)).call(this, eventBus, elementFactory, commandStack));

      _this._eventBus = eventBus;
      _this._elementFactory = elementFactory;
      _this._commandStack = commandStack;
      _this._sheet = sheet;
      return _this;
    }

    _createClass$83(Modeling, [{
      key: 'getHandlers',
      value: function getHandlers() {
        return Modeling._getHandlers();
      }
    }, {
      key: 'editDecisionTableName',
      value: function editDecisionTableName(name) {
        var root = this._sheet.getRoot(),
            businessObject = root.businessObject,
            parentBusinessObject = businessObject.$parent;

        var context = {
          element: parentBusinessObject,
          properties: {
            name: name
          }
        };

        this._commandStack.execute('updateProperties', context);
      }
    }, {
      key: 'editDecisionTableId',
      value: function editDecisionTableId(id) {
        var root = this._sheet.getRoot(),
            businessObject = root.businessObject,
            parentBusinessObject = businessObject.$parent;

        var context = {
          element: parentBusinessObject,
          properties: {
            id: id
          }
        };

        this._commandStack.execute('updateProperties', context);
      }
    }, {
      key: 'editHitPolicy',
      value: function editHitPolicy(hitPolicy, aggregation) {
        var root = this._sheet.getRoot(),
            businessObject = root.businessObject;

        var context = {
          element: businessObject,
          properties: {
            hitPolicy: hitPolicy,
            aggregation: aggregation
          }
        };

        this._commandStack.execute('updateProperties', context);
      }
    }, {
      key: 'updateProperties',
      value: function updateProperties(el, props) {
        var context = {
          element: el,
          properties: props
        };

        this._commandStack.execute('updateProperties', context);
      }
    }, {
      key: 'editInputExpression',
      value: function editInputExpression(inputExpression, props) {
        var context = {
          element: inputExpression,
          properties: props
        };

        this._commandStack.execute('updateProperties', context);
      }
    }, {
      key: 'editOutputName',
      value: function editOutputName(output, name) {
        var context = {
          element: output,
          properties: {
            name: name
          }
        };

        this._commandStack.execute('updateProperties', context);
      }
    }, {
      key: 'editInputExpressionTypeRef',
      value: function editInputExpressionTypeRef(inputExpression, typeRef) {
        var context = {
          element: inputExpression,
          properties: {
            typeRef: typeRef
          }
        };

        this._commandStack.execute('updateProperties', context);
      }
    }, {
      key: 'editOutputTypeRef',
      value: function editOutputTypeRef(output, typeRef) {
        var context = {
          element: output,
          properties: {
            typeRef: typeRef
          }
        };

        this._commandStack.execute('updateProperties', context);
      }
    }, {
      key: 'editCell',
      value: function editCell(cell, text) {
        var context = {
          element: cell,
          properties: {
            text: text
          }
        };

        this._commandStack.execute('updateProperties', context);
      }
    }, {
      key: 'editAnnotation',
      value: function editAnnotation(rule, description) {
        var context = {
          element: rule,
          properties: {
            description: description
          }
        };

        this._commandStack.execute('updateProperties', context);
      }
    }, {
      key: 'editAllowedValues',
      value: function editAllowedValues(element, allowedValues) {
        var context = {
          element: element,
          allowedValues: allowedValues
        };

        this._commandStack.execute('editAllowedValues', context);
      }
    }, {
      key: 'editExpressionLanguage',
      value: function editExpressionLanguage(element, expressionLanguage) {
        var context = {
          element: element,
          properties: {
            expressionLanguage: expressionLanguage
          }
        };

        this._commandStack.execute('updateProperties', context);
      }
    }, {
      key: 'claimId',
      value: function claimId(id, moddleElement) {
        var context = {
          id: id,
          element: moddleElement,
          claiming: true
        };

        this._commandStack.execute('id.updateClaim', context);
      }
    }, {
      key: 'unclaimId',
      value: function unclaimId(id, moddleElement) {
        var context = {
          id: id,
          element: moddleElement
        };

        this._commandStack.execute('id.updateClaim', context);
      }
    }], [{
      key: '_getHandlers',
      value: function _getHandlers() {
        return assign({}, _get$3(Modeling.__proto__ || Object.getPrototypeOf(Modeling), '_getHandlers', this).call(this), {
          'editAllowedValues': UpdateAllowedValuesHandler,
          'updateProperties': EditPropertiesHandler,
          'id.updateClaim': IdClaimHandler$1
        });
      }
    }]);

    return Modeling;
  }(Modeling$2);

  Modeling$3.$inject = ['eventBus', 'elementFactory', 'commandStack', 'sheet'];

  var _typeof$61 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$84 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$101(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$50(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$61(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$50(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$61(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var IdClaimBehavior = function (_CommandInterceptor) {
    _inherits$50(IdClaimBehavior, _CommandInterceptor);

    function IdClaimBehavior(eventBus, moddle, modeling) {
      _classCallCheck$101(this, IdClaimBehavior);

      var _this = _possibleConstructorReturn$50(this, (IdClaimBehavior.__proto__ || Object.getPrototypeOf(IdClaimBehavior)).call(this, eventBus));

      _this._ids = moddle.ids;
      _this._modeling = modeling;

      _this.preExecute(['row.add', 'col.add'], function (event) {
        var context = event.context,
            element = context.row || context.col;

        _this.claimId(element.businessObject);

        if (element.cells) {
          element.cells.forEach(function (cell) {
            return _this.claimId(cell.businessObject);
          });
        }
      });
      return _this;
    }

    _createClass$84(IdClaimBehavior, [{
      key: 'claimId',
      value: function claimId(businessObject) {
        var _this2 = this;

        if (businessObject.id && !this._ids.assigned(businessObject.id)) {
          this._modeling.claimId(businessObject.id, businessObject);
        }

        businessObject.$descriptor.properties.forEach(function (property) {
          var value = businessObject[property.name];

          // not set
          if (!value) {
            return;
          }

          // array of moddle elements
          if (isArray(value)) {
            value.forEach(function (v) {
              return _this2.claimId(v);
            });
          }

          // moddle element
          if (value.$type) {
            _this2.claimId(value);
          }
        });
      }
    }]);

    return IdClaimBehavior;
  }(CommandInterceptor);

  IdClaimBehavior.$inject = ['eventBus', 'moddle', 'modeling'];

  var _typeof$62 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$85 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$102(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$51(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$62(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$51(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$62(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var IdUnclaimBehavior = function (_CommandInterceptor) {
    _inherits$51(IdUnclaimBehavior, _CommandInterceptor);

    function IdUnclaimBehavior(eventBus, modeling) {
      _classCallCheck$102(this, IdUnclaimBehavior);

      var _this = _possibleConstructorReturn$51(this, (IdUnclaimBehavior.__proto__ || Object.getPrototypeOf(IdUnclaimBehavior)).call(this, eventBus));

      _this._modeling = modeling;

      _this.preExecute(['row.remove', 'col.remove'], function (event) {
        var context = event.context,
            element = context.row || context.col;

        _this.unclaimId(element.businessObject);

        if (element.cells) {
          element.cells.forEach(function (cell) {
            return _this.unclaimId(cell.businessObject);
          });
        }
      });
      return _this;
    }

    _createClass$85(IdUnclaimBehavior, [{
      key: 'unclaimId',
      value: function unclaimId(businessObject) {
        var _this2 = this;

        if (businessObject.id) {
          this._modeling.unclaimId(businessObject.id, businessObject);
        }

        businessObject.$descriptor.properties.forEach(function (property) {
          var value = businessObject[property.name];

          // not set
          if (!value) {
            return;
          }

          // array of moddle elements
          if (isArray(value)) {
            value.forEach(function (v) {
              return _this2.unclaimId(v);
            });
          }

          // moddle element
          if (value.$type) {
            _this2.unclaimId(value);
          }
        });
      }
    }]);

    return IdUnclaimBehavior;
  }(CommandInterceptor);

  IdUnclaimBehavior.$inject = ['eventBus', 'modeling'];

  var Behavior = {
    __init__: ['idClaimBehavior', 'idUnclaimBehavior'],
    idClaimBehavior: ['type', IdClaimBehavior],
    idUnclaimBehavior: ['type', IdUnclaimBehavior]
  };

  var modelingModule = {
    __init__: ['dmnUpdater', 'idChangeBehavior', 'modeling'],
    __depends__: [Behavior, CommandStack$1],
    dmnUpdater: ['type', DmnUpdater],
    dmnFactory: ['type', DmnFactory],
    elementFactory: ['type', ElementFactory$3],
    idChangeBehavior: ['type', IdChangeBehavior],
    modeling: ['type', Modeling$3]
  };

  var _typeof$63 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$86 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$103(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$52(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$63(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$52(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$63(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var EXPRESSION_LANGUAGE_LABELS = {
    feel: 'FEEL',
    juel: 'JUEL',
    python: 'Python',
    javascript: 'JavaScript',
    groovy: 'Groovy',
    jruby: 'JRuby'
  };

  var DecisionRulesEditorCellComponent = function (_Component) {
    _inherits$52(DecisionRulesEditorCellComponent, _Component);

    function DecisionRulesEditorCellComponent(props, context) {
      _classCallCheck$103(this, DecisionRulesEditorCellComponent);

      var _this = _possibleConstructorReturn$52(this, (DecisionRulesEditorCellComponent.__proto__ || Object.getPrototypeOf(DecisionRulesEditorCellComponent)).call(this, props, context));

      _this.state = {
        isFocussed: false
      };

      _this.changeCellValue = _this.changeCellValue.bind(_this);
      _this.onFocus = _this.onFocus.bind(_this);
      _this.onBlur = _this.onBlur.bind(_this);
      _this.onElementsChanged = _this.onElementsChanged.bind(_this);
      return _this;
    }

    _createClass$86(DecisionRulesEditorCellComponent, [{
      key: 'onElementsChanged',
      value: function onElementsChanged() {
        this.forceUpdate();
      }
    }, {
      key: 'componentWillMount',
      value: function componentWillMount() {
        var injector = this.context.injector;
        var cell = this.props.cell;

        var changeSupport = this._changeSupport = this.context.changeSupport;

        this._modeling = injector.get('modeling');

        changeSupport.onElementsChanged(cell.id, this.onElementsChanged);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        var cell = this.props.cell;

        this._changeSupport.offElementsChanged(cell.id, this.onElementsChanged);
      }
    }, {
      key: 'changeCellValue',
      value: function changeCellValue(value) {
        var cell = this.props.cell;

        this._modeling.editCell(cell.businessObject, value);
      }
    }, {
      key: 'onFocus',
      value: function onFocus() {
        this.setState({
          isFocussed: true
        });
      }
    }, {
      key: 'onBlur',
      value: function onBlur() {
        this.setState({
          isFocussed: false
        });
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _props = this.props,
            cell = _props.cell,
            rowIndex = _props.rowIndex,
            row = _props.row,
            col = _props.col,
            colIndex = _props.colIndex;
        var isFocussed = this.state.isFocussed;

        var className = is(cell, 'dmn:UnaryTests') ? 'input-cell' : 'output-cell';

        var businessObject = cell.businessObject;

        return createComponentVNode(2, HeaderCell, {
          'className': className,
          'elementId': cell.id,
          'coords': rowIndex + ':' + colIndex,
          'data-row-id': row.id,
          'data-col-id': col.id,
          children: createComponentVNode(2, TableCellEditor, {
            'className': 'cell-editor',
            'ctrlForNewline': true,
            'onFocus': this.onFocus,
            'onBlur': this.onBlur,
            'isFocussed': isFocussed,
            'onChange': this.changeCellValue,
            'value': businessObject.text,
            'businessObject': businessObject
          })
        });
      }
    }]);

    return DecisionRulesEditorCellComponent;
  }(Component);

  var TableCellEditor = function (_EditableComponent) {
    _inherits$52(TableCellEditor, _EditableComponent);

    function TableCellEditor() {
      _classCallCheck$103(this, TableCellEditor);

      return _possibleConstructorReturn$52(this, (TableCellEditor.__proto__ || Object.getPrototypeOf(TableCellEditor)).apply(this, arguments));
    }

    _createClass$86(TableCellEditor, [{
      key: 'isDefaultExpressionLanguage',
      value: function isDefaultExpressionLanguage(businessObject) {
        var expressionLanguage = businessObject.expressionLanguage;

        var isInput$$1 = is(businessObject, 'dmn:UnaryTests');

        var _context$injector$get = this.context.injector.get('config'),
            defaultInputExpressionLanguage = _context$injector$get.defaultInputExpressionLanguage,
            defaultOutputExpressionLanguage = _context$injector$get.defaultOutputExpressionLanguage;

        if (isInput$$1) {
          return !expressionLanguage && !defaultInputExpressionLanguage || expressionLanguage === (defaultInputExpressionLanguage || 'feel');
        } else {
          return !expressionLanguage && !defaultOutputExpressionLanguage || expressionLanguage === (defaultOutputExpressionLanguage || 'juel');
        }
      }
    }, {
      key: 'getDescription',
      value: function getDescription(businessObject) {
        return businessObject.description;
      }
    }, {
      key: 'getExpressionLanguageLabel',
      value: function getExpressionLanguageLabel(businessObject) {
        var expressionLanguage = businessObject.expressionLanguage;

        var isInput$$1 = is(businessObject, 'dmn:UnaryTests');

        if (isInput$$1) {
          return expressionLanguage ? EXPRESSION_LANGUAGE_LABELS[businessObject.expressionLanguage.toLowerCase()] : 'FEEL';
        } else {
          return expressionLanguage ? EXPRESSION_LANGUAGE_LABELS[businessObject.expressionLanguage.toLowerCase()] : 'JUEL';
        }
      }
    }, {
      key: 'isScript',
      value: function isScript(businessObject) {

        return is(businessObject, 'dmn:UnaryTests') && ((businessObject.expressionLanguage || 'FEEL') !== 'FEEL' || businessObject.text.indexOf('\n') !== -1);
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _props2 = this.props,
            businessObject = _props2.businessObject,
            isFocussed = _props2.isFocussed;

        var description = this.getDescription(businessObject);

        var isDefaultExpressionLanguage = this.isDefaultExpressionLanguage(businessObject);

        var expressionLanguageLabel = this.getExpressionLanguageLabel(businessObject) || businessObject.expressionLanguage;

        var isScript = this.isScript(businessObject);

        return createVNode(1, 'div', this.getClassName(), [isString(description) && !isFocussed && createVNode(1, 'div', 'description-indicator'), this.getEditor({
          className: isScript ? 'script-editor' : null
        }), !isDefaultExpressionLanguage && !isFocussed && createVNode(1, 'span', 'dms-badge dmn-expression-language', [createVNode(1, 'span', 'dms-badge-icon dmn-icon-file-code'), createVNode(1, 'span', 'dms-badge-label', expressionLanguageLabel, 0)], 4, {
          'title': 'Expression Language = ' + expressionLanguageLabel
        })], 0);
      }
    }]);

    return TableCellEditor;
  }(EditableComponent);

  function _classCallCheck$104(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var HIGH_PRIORITY$2 = 1500;

  var RulesEditor = function RulesEditor(components) {
    _classCallCheck$104(this, RulesEditor);

    components.onGetComponent('cell', HIGH_PRIORITY$2, function (_ref) {
      var cellType = _ref.cellType;

      if (cellType === 'rule') {
        return DecisionRulesEditorCellComponent;
      }
    });
  };

  RulesEditor.$inject = ['components'];

  var decisionRulesEditorModule = {
    __depends__: [DebounceInput, Rules$4],
    __init__: ['decisionRulesEditor'],
    decisionRulesEditor: ['type', RulesEditor]
  };

  var _typeof$64 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$87 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$105(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$53(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$64(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$53(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$64(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var OFFSET = 4;

  var SimpleModeButtonComponent = function (_Component) {
    _inherits$53(SimpleModeButtonComponent, _Component);

    function SimpleModeButtonComponent(props, context) {
      _classCallCheck$105(this, SimpleModeButtonComponent);

      var _this = _possibleConstructorReturn$53(this, (SimpleModeButtonComponent.__proto__ || Object.getPrototypeOf(SimpleModeButtonComponent)).call(this, props, context));

      _this.state = {
        top: 0,
        left: 0,
        isVisible: false,
        isDisabled: true
      };

      var injector = context.injector;

      var eventBus = _this._eventBus = injector.get('eventBus'),
          simpleMode = injector.get('simpleMode');

      _this._renderer = injector.get('renderer');

      _this._selection = context.injector.get('selection');

      _this.updatePosition = _this.updatePosition.bind(_this);

      eventBus.on('selection.changed', function (_ref) {
        var selection = _ref.selection;

        if (!selection || !simpleMode.canSimpleEdit(selection)) {
          _this.setState({
            isVisible: false
          });

          return;
        }

        var isDisabled;

        _this.setState({
          isVisible: true,
          selection: selection
        }, _this.updatePosition);

        var expressionLanguage = getExpressionLanguage(selection);

        if (isDefaultExpressionLanguage(selection, expressionLanguage)) {
          isDisabled = false;
        } else {
          isDisabled = true;
        }

        _this.setState({
          isVisible: true,
          selection: selection,
          isDisabled: isDisabled
        }, _this.updatePosition);
      });

      _this.onClick = _this.onClick.bind(_this);
      return _this;
    }

    // position button always on opposite site of context menu


    _createClass$87(SimpleModeButtonComponent, [{
      key: 'updatePosition',
      value: function updatePosition() {
        var selection = this.state.selection;

        if (!selection || !this.node) {
          return;
        }

        var container = this._container = this._renderer.getContainer();

        var cellNode = getNodeById(selection.id, container);

        var cellBounds = cellNode.getBoundingClientRect();

        var nodeBounds = this.node.getBoundingClientRect();

        var containerBounds = container.getBoundingClientRect();

        var scrollLeft = container.scrollLeft,
            scrollTop = container.scrollTop;

        var nodePosition = {};

        if (cellBounds.left + cellBounds.width / 2 > containerBounds.width / 2) {
          nodePosition.left = window.scrollX - containerBounds.left + cellBounds.left - nodeBounds.width + OFFSET + scrollLeft + 'px';
        } else {
          nodePosition.left = window.scrollX - containerBounds.left + cellBounds.left + cellBounds.width - OFFSET + scrollLeft + 'px';
        }

        if (cellBounds.top + cellBounds.height / 2 > containerBounds.height / 2) {
          nodePosition.top = window.scrollY - containerBounds.top + cellBounds.top - nodeBounds.height + OFFSET + scrollTop + 'px';
        } else {
          nodePosition.top = window.scrollY - containerBounds.top + cellBounds.top - OFFSET + scrollTop + 'px';
        }

        assign(this.node.style, nodePosition);
      }
    }, {
      key: 'onClick',
      value: function onClick() {
        var isDisabled = this.state.isDisabled;

        if (isDisabled) {
          return;
        }

        var element = this._selection.get();

        if (!element) {
          return;
        }

        this._eventBus.fire('simpleMode.open', {
          element: element,
          node: getNodeById(element.id, this._container)
        });

        this.setState({
          isVisible: false
        });
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _this2 = this;

        var _state = this.state,
            isDisabled = _state.isDisabled,
            isVisible = _state.isVisible,
            top = _state.top,
            left = _state.left;

        var classes = ['simple-mode-button', 'no-deselect'];

        if (isDisabled) {
          classes.push('disabled');
        }

        return isVisible ? createVNode(1, 'div', classes.join(' '), createVNode(1, 'span', 'dmn-icon-edit'), 2, {
          'onClick': this.onClick,
          'style': { top: top, left: left },
          'title': isDisabled ? 'Editing not supported for set expression language' : 'Edit'
        }, null, function (node) {
          return _this2.node = node;
        }) : null;
      }
    }]);

    return SimpleModeButtonComponent;
  }(Component);
  function getExpressionLanguage(cell) {
    return cell.businessObject.expressionLanguage;
  }

  function isDefaultExpressionLanguage(cell, expressionLanguage) {
    if (isInput(cell.col)) {
      return !expressionLanguage || expressionLanguage === 'feel';
    } else if (isOutput(cell.col)) {
      return !expressionLanguage || expressionLanguage === 'juel';
    }
  }

  var _createClass$88 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$106(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var SimpleMode = function () {
    function SimpleMode(components, contextMenu, elementRegistry, eventBus, renderer) {
      _classCallCheck$106(this, SimpleMode);

      this._providers = [];

      components.onGetComponent('table.before', function () {
        return SimpleModeButtonComponent;
      });

      eventBus.on('simpleMode.open', function (_ref) {
        var element = _ref.element,
            node = _ref.node;

        var _node$getBoundingClie = node.getBoundingClientRect(),
            left = _node$getBoundingClie.left,
            top = _node$getBoundingClie.top,
            width = _node$getBoundingClie.width,
            height = _node$getBoundingClie.height;

        var container = renderer.getContainer();

        contextMenu.open({
          x: left + container.parentNode.scrollLeft,
          y: top + container.parentNode.scrollTop,
          width: width,
          height: height
        }, {
          contextMenuType: 'simple-mode-edit',
          element: element,
          offset: {
            x: 4,
            y: 4
          }
        });
      });

      eventBus.on('cell.click', function (e) {
        var event = e.event,
            node = e.node,
            id = e.id;

        if (isCmd$3(event)) {
          var element = elementRegistry.get(id);

          if (element) {
            eventBus.fire('simpleMode.open', {
              node: node,
              element: element
            });
          }

          // prevent focus
          e.preventDefault();
        }
      });
    }

    _createClass$88(SimpleMode, [{
      key: 'registerProvider',
      value: function registerProvider(provider) {
        this._providers.push(provider);
      }
    }, {
      key: 'canSimpleEdit',
      value: function canSimpleEdit(element) {
        return this._providers.reduce(function (canSimpleEdit, provider) {
          return canSimpleEdit || provider(element);
        }, false);
      }
    }]);

    return SimpleMode;
  }();

  SimpleMode.$inject = ['components', 'contextMenu', 'elementRegistry', 'eventBus', 'renderer'];

  // helpers //////////

  function isCmd$3(event) {
    // ensure we don't react to AltGr
    // (mapped to CTRL + ALT)
    if (event.altKey) {
      return false;
    }

    return event.ctrlKey || event.metaKey;
  }

  var SimpleMode$1 = {
    __depends__: [ContextMenu$2, CellSelection$1],
    __init__: ['simpleMode'],
    simpleMode: ['type', SimpleMode]
  };

  function parseString$1(string) {
    if (!string || isEmptyString$1(string)) {
      return 'none';
    } else if (string.trim() === 'true') {
      return 'true';
    } else if (string.trim() === 'false') {
      return 'false';
    }
  }

  function isEmptyString$1(string) {
    return string === '';
  }

  var _typeof$65 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$89 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$107(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$54(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$65(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$54(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$65(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var TRUE = 'true',
      FALSE = 'false',
      NONE = 'none';

  var BooleanEdit = function (_Component) {
    _inherits$54(BooleanEdit, _Component);

    function BooleanEdit(props, context) {
      _classCallCheck$107(this, BooleanEdit);

      var _this = _possibleConstructorReturn$54(this, (BooleanEdit.__proto__ || Object.getPrototypeOf(BooleanEdit)).call(this, props, context));

      _this._modeling = context.injector.get('modeling');

      var element = _this.props.context.element;

      var parsedString = parseString$1(element.businessObject.text);

      _this.state = {
        value: parsedString || NONE
      };

      _this.editCell = _this.editCell.bind(_this);

      _this.onChange = _this.onChange.bind(_this);
      return _this;
    }

    _createClass$89(BooleanEdit, [{
      key: 'editCell',
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }
    }, {
      key: 'onChange',
      value: function onChange(value) {
        var element = this.props.context.element;

        this.editCell(element.businessObject, value === NONE ? '' : value);

        this.setState({
          value: value
        });
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var value = this.state.value;

        var options$$1 = [{
          label: '-',
          value: NONE
        }, {
          label: 'Yes',
          value: TRUE
        }, {
          label: 'No',
          value: FALSE
        }];

        return createVNode(1, 'div', 'simple-boolean-edit context-menu-container', [createVNode(1, 'h3', 'dms-heading', createTextVNode('Edit Boolean'), 2), createVNode(1, 'h4', 'dms-heading', createTextVNode('Set Value'), 2), createComponentVNode(2, InputSelect, {
          'noInput': true,
          'className': 'dms-block',
          'onChange': this.onChange,
          'options': options$$1,
          'value': value
        })], 4);
      }
    }]);

    return BooleanEdit;
  }(Component);

  function _classCallCheck$108(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var SimpleBooleanEdit = function SimpleBooleanEdit(components, simpleMode) {
    _classCallCheck$108(this, SimpleBooleanEdit);

    simpleMode.registerProvider(function (element) {
      return (isInput(element.col) || isOutput(element.col)) && getTypeRef(element) === 'boolean';
    });

    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (context.contextMenuType && context.contextMenuType === 'simple-mode-edit') {

        if (!context.element) {
          return;
        }

        var typeRef = getTypeRef(context.element);

        if (typeRef === 'boolean') {
          return BooleanEdit;
        }
      }
    });
  };

  SimpleBooleanEdit.$inject = ['components', 'simpleMode'];

  // helpers //////////////////////

  function getTypeRef(element) {
    if (isInput(element.col)) {
      return element.col && element.col.businessObject.inputExpression.typeRef;
    } else {
      return element.col && element.col.businessObject.typeRef;
    }
  }

  var simpleBooleanEditModule = {
    __depends__: [Keyboard$2, SimpleMode$1],
    __init__: ['simpleBooleanEdit'],
    simpleBooleanEdit: ['type', SimpleBooleanEdit]
  };

  var ISO_DATE_REGEX = /^\d{4}(?:-\d\d){2}T(?:\d\d:){2}\d\d$/;

  // eslint-disable-next-line
  var BETWEEN_DATE_REGEX = /^\[date and time\("(\d{4}(?:-\d\d){2}T(?:\d\d:){2}\d\d)"\)..date and time\("(\d{4}(?:-\d\d){2}T(?:\d\d:){2}\d\d)"/;

  // eslint-disable-next-line
  var BEFORE_AFTER_DATE_REGEX = /^(<|>)\s*date and time\("(\d{4}(?:-\d\d){2}T(?:\d\d:){2}\d\d)"\)/;

  var EXACT_DATE_REGEX = /^date and time\("(\d{4}(?:-\d\d){2}T(?:\d\d:){2}\d\d)"\)$/;

  var EXACT = 'exact',
      BEFORE = 'before',
      AFTER = 'after',
      BETWEEN = 'between';

  function validateISOString(string) {
    if (!ISO_DATE_REGEX.test(string.trim())) {
      return 'Date must match pattern yyyy-MM-ddTHH:mm:ss.';
    }
  }

  function getDateString(type, dates) {
    if (type === EXACT) {
      return 'date and time("' + dates[0] + '")';
    } else if (type === BEFORE) {
      return '< date and time("' + dates[0] + '")';
    } else if (type === AFTER) {
      return '> date and time("' + dates[0] + '")';
    } else if (type === BETWEEN) {
      return '[date and time("' + dates[0] + '")..date and time("' + dates[1] + '")]';
    }
  }

  function getSampleDate() {
    var date = new Date();

    date.setUTCHours(0, 0, 0, 0);

    return date.toISOString().slice(0, -5);
  }

  function parseString$2(string) {

    // emtpy
    if (!string || string.trim() === '') {
      return {
        type: 'exact',
        date: ''
      };
    }

    // between
    var matches = string.match(BETWEEN_DATE_REGEX);

    if (matches) {
      return {
        type: 'between',
        dates: [matches[1], matches[2]]
      };
    }

    // before or after
    matches = string.match(BEFORE_AFTER_DATE_REGEX);

    if (matches) {
      return {
        type: matches[1] === '<' ? 'before' : 'after',
        date: matches[2]
      };
    }

    // exact
    matches = string.match(EXACT_DATE_REGEX);

    if (matches) {
      return {
        type: 'exact',
        date: matches[1]
      };
    }
  }

  var _typeof$66 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$90 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$109(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$55(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$66(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$55(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$66(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var EXACT$1 = 'exact',
      BEFORE$1 = 'before',
      AFTER$1 = 'after',
      BETWEEN$1 = 'between';

  var InputDateEdit = function (_Component) {
    _inherits$55(InputDateEdit, _Component);

    function InputDateEdit(props, context) {
      _classCallCheck$109(this, InputDateEdit);

      var _this = _possibleConstructorReturn$55(this, (InputDateEdit.__proto__ || Object.getPrototypeOf(InputDateEdit)).call(this, props, context));

      _this._modeling = context.injector.get('modeling');

      var element = _this.props.context.element;

      var parsedString = parseString$2(element.businessObject.text);

      if (parsedString) {
        var dates = void 0;

        if (parsedString.date) {
          dates = [parsedString.date, ''];
        } else if (parsedString.dates) {
          dates = parsedString.dates;
        } else {
          dates = ['', ''];
        }

        _this.state = {
          type: parsedString.type,
          dates: dates
        };
      } else {
        _this.state = {
          type: EXACT$1,
          dates: ['', '']
        };
      }

      var debounceInput = context.injector.get('debounceInput');

      _this.debouncedEditCell = debounceInput(_this.editCell.bind(_this));
      _this.editCell = _this.editCell.bind(_this);

      _this.onTypeChange = _this.onTypeChange.bind(_this);
      _this.onSetStartDateTodayClick = _this.onSetStartDateTodayClick.bind(_this);
      _this.onSetEndDateTodayClick = _this.onSetEndDateTodayClick.bind(_this);
      _this.onStartDateInput = _this.onStartDateInput.bind(_this);
      _this.onEndDateInput = _this.onEndDateInput.bind(_this);
      return _this;
    }

    _createClass$90(InputDateEdit, [{
      key: 'editCell',
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }
    }, {
      key: 'onTypeChange',
      value: function onTypeChange(value) {
        var element = this.props.context.element;
        var dates = this.state.dates;

        this.setState({
          type: value
        });

        if (parseString$2(getDateString(value, dates))) {
          this.editCell(element.businessObject, getDateString(value, dates));
        }
      }
    }, {
      key: 'onSetStartDateTodayClick',
      value: function onSetStartDateTodayClick() {
        var element = this.props.context.element;
        var _state = this.state,
            dates = _state.dates,
            type = _state.type;

        var date = getSampleDate();

        this.setState({
          dates: [date, dates[1]]
        });

        if (parseString$2(getDateString(type, [date, dates[1]]))) {
          this.editCell(element.businessObject, getDateString(type, [date, dates[1]]));
        }
      }
    }, {
      key: 'onSetEndDateTodayClick',
      value: function onSetEndDateTodayClick() {
        var element = this.props.context.element;
        var _state2 = this.state,
            dates = _state2.dates,
            type = _state2.type;

        var date = getSampleDate();

        this.setState({
          dates: [dates[0], date]
        });

        if (parseString$2(getDateString(type, [dates[0], date]))) {
          this.editCell(element.businessObject, getDateString(type, [dates[0], date]));
        }
      }
    }, {
      key: 'onStartDateInput',
      value: function onStartDateInput(_ref) {
        var isValid = _ref.isValid,
            value = _ref.value;

        if (isValid) {
          var element = this.props.context.element;
          var _state3 = this.state,
              dates = _state3.dates,
              type = _state3.type;

          this.setState({
            dates: [value, dates[1]]
          });

          this.debouncedEditCell(element.businessObject, getDateString(type, [value, dates[1]]));
        }
      }
    }, {
      key: 'onEndDateInput',
      value: function onEndDateInput(_ref2) {
        var isValid = _ref2.isValid,
            value = _ref2.value;

        if (isValid) {
          var element = this.props.context.element;
          var _state4 = this.state,
              dates = _state4.dates,
              type = _state4.type;

          this.setState({
            dates: [dates[0], value]
          });

          this.debouncedEditCell(element.businessObject, getDateString(type, [dates[0], value]));
        }
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _state5 = this.state,
            dates = _state5.dates,
            type = _state5.type;

        var options$$1 = [{
          label: 'Exactly',
          value: EXACT$1
        }, {
          label: 'Before',
          value: BEFORE$1
        }, {
          label: 'After',
          value: AFTER$1
        }, {
          label: 'Between',
          value: BETWEEN$1
        }];

        return createVNode(1, 'div', 'context-menu-container simple-date-edit', [createVNode(1, 'h3', 'dms-heading', createTextVNode('Edit Date'), 2), createVNode(1, 'div', 'dms-fill-row', createComponentVNode(2, InputSelect, {
          'noInput': true,
          'onChange': this.onTypeChange,
          'options': options$$1,
          'value': type
        }), 2), createVNode(1, 'h4', 'dms-heading', type === BETWEEN$1 ? 'Edit Start Date' : 'Set Date', 0), createVNode(1, 'div', null, [createComponentVNode(2, ValidatedInput, {
          'className': 'start-date-input dms-block',
          'onInput': this.onStartDateInput,
          'placeholder': 'e.g. ' + getSampleDate(),
          'validate': validateISOString,
          'value': dates[0]
        }), createVNode(1, 'p', 'dms-hint', [createVNode(1, 'a', 'use-today', createTextVNode('Use today'), 2, {
          'href': '#',
          'onClick': this.onSetStartDateTodayClick
        }), createTextVNode('.')], 4)], 4), type === BETWEEN$1 && createVNode(1, 'h4', 'dms-heading', createTextVNode('Edit End Date'), 2), type === BETWEEN$1 && createVNode(1, 'div', null, [createComponentVNode(2, ValidatedInput, {
          'className': 'end-date-input dms-block',
          'onInput': this.onEndDateInput,
          'placeholder': 'e.g. ' + getSampleDate(),
          'validate': validateISOString,
          'value': dates[1]
        }), createVNode(1, 'p', 'dms-hint', [createVNode(1, 'a', 'use-today', createTextVNode('Use today'), 2, {
          'href': '#',
          'onClick': this.onSetEndDateTodayClick
        }), createTextVNode('.')], 4)], 4)], 0);
      }
    }]);

    return InputDateEdit;
  }(Component);

  var _typeof$67 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$91 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$110(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$56(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$67(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$56(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$67(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var OutputDateEdit = function (_Component) {
    _inherits$56(OutputDateEdit, _Component);

    function OutputDateEdit(props, context) {
      _classCallCheck$110(this, OutputDateEdit);

      var _this = _possibleConstructorReturn$56(this, (OutputDateEdit.__proto__ || Object.getPrototypeOf(OutputDateEdit)).call(this, props, context));

      _this._modeling = context.injector.get('modeling');

      var element = _this.props.context.element;

      var parsedString = parseString$2(element.businessObject.text);

      _this.state = {
        date: parsedString ? parsedString.date : ''
      };

      var debounceInput = context.injector.get('debounceInput');

      _this.debouncedEditCell = debounceInput(_this.editCell.bind(_this));
      _this.editCell = _this.editCell.bind(_this);

      _this.onClick = _this.onClick.bind(_this);
      _this.onInput = _this.onInput.bind(_this);
      return _this;
    }

    _createClass$91(OutputDateEdit, [{
      key: 'editCell',
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }
    }, {
      key: 'onClick',
      value: function onClick() {
        var element = this.props.context.element;

        var date = getSampleDate();

        this.setState({
          date: date
        });

        this.editCell(element.businessObject, 'date and time("' + date + '")');
      }
    }, {
      key: 'onInput',
      value: function onInput(_ref) {
        var isValid = _ref.isValid,
            value = _ref.value;

        if (isValid) {
          var element = this.props.context.element;

          this.setState({
            date: value
          });

          this.debouncedEditCell(element.businessObject, 'date and time("' + value + '")');
        }
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var date = this.state.date;

        return createVNode(1, 'div', 'context-menu-container simple-date-edit', [createVNode(1, 'h3', 'dms-heading', createTextVNode('Edit Date'), 2), createVNode(1, 'h4', 'dms-heading', createTextVNode('Set Date'), 2), createVNode(1, 'div', null, [createComponentVNode(2, ValidatedInput, {
          'onInput': this.onInput,
          'placeholder': 'e.g. ' + getSampleDate(),
          'validate': validateISOString,
          'value': date,
          'className': 'dms-block'
        }), createVNode(1, 'p', 'dms-hint', [createTextVNode('Set date '), createVNode(1, 'a', 'use-today', createTextVNode('to today'), 2, {
          'href': '#',
          'onClick': this.onClick
        }), createTextVNode('.')], 4)], 4)], 4);
      }
    }]);

    return OutputDateEdit;
  }(Component);

  function _classCallCheck$111(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var SimpleDateEdit = function SimpleDateEdit(components, simpleMode) {
    _classCallCheck$111(this, SimpleDateEdit);

    simpleMode.registerProvider(function (element) {
      var typeRef = getTypeRef$1(element);

      return (isInput(element.col) || isOutput(element.col)) && isDate(typeRef);
    });

    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (context.contextMenuType && context.contextMenuType === 'simple-mode-edit') {

        if (!context.element) {
          return;
        }

        var typeRef = getTypeRef$1(context.element);

        if (isDate(typeRef)) {

          if (isInput(context.element.col)) {
            return InputDateEdit;
          } else if (isOutput(context.element.col)) {
            return OutputDateEdit;
          }
        }
      }
    });
  };

  SimpleDateEdit.$inject = ['components', 'simpleMode'];

  // helpers //////////////////////

  function getTypeRef$1(element) {
    if (isInput(element.col)) {
      return element.col && element.col.businessObject.inputExpression.typeRef;
    } else {
      return element.col && element.col.businessObject.typeRef;
    }
  }

  function isDate(typeRef) {
    return typeRef === 'date';
  }

  var simpleDateEditModule = {
    __depends__: [Keyboard$2, SimpleMode$1],
    __init__: ['simpleDateEdit'],
    simpleDateEdit: ['type', SimpleDateEdit]
  };

  // eslint-disable-next-line
  var COMPARISON_REGULAR_EXPRESSION = /^(-?(?:[0-9]|\.[0-9])+)$|^((?:<|>|=){0,2})\s*(-?(?:[0-9]|\.[0-9])+)$/;

  // eslint-disable-next-line
  var RANGE_REGULAR_EXPRESSION = /^(\[|\]){1}(-?(?:[0-9]|\.[0-9])+){1,}\.\.(-?(?:[0-9]|\.[0-9])+){1,}(\[|\]){1}$/;

  var operators = {
    equals: '=',
    less: '<',
    lessEquals: '<=',
    greater: '>',
    greaterEquals: '>='
  };

  function getOperatorName(string) {
    return keys(operators).filter(function (key) {
      return string === operators[key];
    })[0];
  }

  function parseString$3(string) {
    if (!string || isEmptyString$2(string.trim())) {
      return {
        type: 'comparison'
      };
    }

    var comparisonMatches = string.match(COMPARISON_REGULAR_EXPRESSION),
        rangeMatches = string.match(RANGE_REGULAR_EXPRESSION);

    if (comparisonMatches) {
      if (isNumber$2(comparisonMatches)) {
        return {
          type: 'comparison',
          value: parseFloat(comparisonMatches[1]),
          operator: 'equals'
        };
      } else if (isComparison(comparisonMatches)) {
        return {
          type: 'comparison',
          value: parseFloat(comparisonMatches[3]),
          operator: getOperatorName(comparisonMatches[2])
        };
      }
    } else if (rangeMatches) {
      return {
        type: 'range',
        values: [rangeMatches[2], rangeMatches[3]].map(function (value) {
          return parseFloat(value);
        }),
        start: rangeMatches[1] === ']' ? 'exclude' : 'include',
        end: rangeMatches[4] === '[' ? 'exclude' : 'include'
      };
    }
  }

  function isEmptyString$2(string) {
    return string === '';
  }

  function isNumber$2(matches) {
    return matches[0] && matches[1] && !matches[2] && !matches[3];
  }

  function isComparison(matches) {
    return matches[0] && !matches[1] && matches[2] && matches[3];
  }

  function getComparisonString(comparisonOperator, comparisonValue) {
    if (comparisonOperator === 'equals') {
      return '' + comparisonValue;
    } else {
      return operators[comparisonOperator] + ' ' + comparisonValue;
    }
  }

  function getRangeString(rangeStartValue, rangeEndValue, rangeStartType, rangeEndType) {
    var rangeStartChar = rangeStartType === 'exclude' ? ']' : '[',
        rangeEndChar = rangeEndType === 'exclude' ? '[' : ']';

    return '' + rangeStartChar + rangeStartValue + '..' + rangeEndValue + rangeEndChar;
  }

  var _typeof$68 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$92 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$112(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$57(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$68(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$57(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$68(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var COMPARISON = 'comparison',
      RANGE$1 = 'range';

  var InputNumberEdit = function (_Component) {
    _inherits$57(InputNumberEdit, _Component);

    function InputNumberEdit(props, context) {
      _classCallCheck$112(this, InputNumberEdit);

      var _this = _possibleConstructorReturn$57(this, (InputNumberEdit.__proto__ || Object.getPrototypeOf(InputNumberEdit)).call(this, props, context));

      _this._modeling = context.injector.get('modeling');

      var element = _this.props.context.element;

      var parsedString = parseString$3(element.businessObject.text);

      if (parsedString) {
        _this.state = {
          type: parsedString.type,
          comparisonOperator: parsedString.operator || 'equals',
          comparisonValue: parsedString.value || 0,
          rangeStartValue: parsedString.values ? parsedString.values[0] : 0,
          rangeEndValue: parsedString.values ? parsedString.values[1] : 0,
          rangeStartType: parsedString.start || 'include',
          rangeEndType: parsedString.end || 'include'
        };
      } else {
        _this.state = {
          type: COMPARISON,
          comparisonOperator: 'equals',
          comparisonValue: 0,
          rangeStartValue: 0,
          rangeEndValue: 0,
          rangeStartType: 'include',
          rangeEndType: 'include'
        };
      }

      var debounceInput = context.injector.get('debounceInput');

      _this.debouncedEditCell = debounceInput(_this.editCell.bind(_this));
      _this.editCell = _this.editCell.bind(_this);

      _this.onComparisonOperatorChange = _this.onComparisonOperatorChange.bind(_this);
      _this.onComparisonValueChange = _this.onComparisonValueChange.bind(_this);
      _this.onTypeChange = _this.onTypeChange.bind(_this);
      _this.onRangeStartTypeChange = _this.onRangeStartTypeChange.bind(_this);
      _this.onRangeStartValueChange = _this.onRangeStartValueChange.bind(_this);
      _this.onRangeEndTypeChange = _this.onRangeEndTypeChange.bind(_this);
      _this.onRangeEndValueChange = _this.onRangeEndValueChange.bind(_this);
      return _this;
    }

    _createClass$92(InputNumberEdit, [{
      key: 'editCell',
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }
    }, {
      key: 'onTypeChange',
      value: function onTypeChange(value) {
        var element = this.props.context.element;
        var _state = this.state,
            comparisonOperator = _state.comparisonOperator,
            comparisonValue = _state.comparisonValue,
            rangeStartValue = _state.rangeStartValue,
            rangeEndValue = _state.rangeEndValue,
            rangeStartType = _state.rangeStartType,
            rangeEndType = _state.rangeEndType;

        if (value === COMPARISON) {
          this.editCell(element.businessObject, getComparisonString(comparisonOperator, comparisonValue));
        } else {
          this.editCell(element.businessObject, getRangeString(rangeStartValue, rangeEndValue, rangeStartType, rangeEndType));
        }

        this.setState({
          type: value
        });
      }
    }, {
      key: 'onComparisonOperatorChange',
      value: function onComparisonOperatorChange(value) {
        var element = this.props.context.element;
        var _state2 = this.state,
            type = _state2.type,
            comparisonValue = _state2.comparisonValue;

        if (type === COMPARISON) {
          this.editCell(element.businessObject, getComparisonString(value, comparisonValue));

          this.setState({
            comparisonOperator: value
          });
        }
      }
    }, {
      key: 'onComparisonValueChange',
      value: function onComparisonValueChange(comparisonValue) {
        var element = this.props.context.element;
        var _state3 = this.state,
            type = _state3.type,
            comparisonOperator = _state3.comparisonOperator;

        if (type === COMPARISON) {
          this.debouncedEditCell(element.businessObject, getComparisonString(comparisonOperator, comparisonValue));

          this.setState({
            comparisonValue: comparisonValue
          });
        }
      }
    }, {
      key: 'onRangeStartTypeChange',
      value: function onRangeStartTypeChange(value) {
        var element = this.props.context.element;
        var _state4 = this.state,
            type = _state4.type,
            rangeStartValue = _state4.rangeStartValue,
            rangeEndValue = _state4.rangeEndValue,
            rangeEndType = _state4.rangeEndType;

        if (type === RANGE$1) {
          this.editCell(element.businessObject, getRangeString(rangeStartValue, rangeEndValue, value, rangeEndType));

          this.setState({
            rangeStartType: value
          });
        }
      }
    }, {
      key: 'onRangeStartValueChange',
      value: function onRangeStartValueChange(value) {
        var element = this.props.context.element;
        var _state5 = this.state,
            type = _state5.type,
            rangeEndValue = _state5.rangeEndValue,
            rangeStartType = _state5.rangeStartType,
            rangeEndType = _state5.rangeEndType;

        if (type === RANGE$1) {
          this.editCell(element.businessObject, getRangeString(value, rangeEndValue, rangeStartType, rangeEndType));

          this.setState({
            rangeStartValue: value
          });
        }
      }
    }, {
      key: 'onRangeEndTypeChange',
      value: function onRangeEndTypeChange(value) {
        var element = this.props.context.element;
        var _state6 = this.state,
            type = _state6.type,
            rangeStartValue = _state6.rangeStartValue,
            rangeEndValue = _state6.rangeEndValue,
            rangeStartType = _state6.rangeStartType;

        if (type === RANGE$1) {
          this.editCell(element.businessObject, getRangeString(rangeStartValue, rangeEndValue, rangeStartType, value));

          this.setState({
            rangeEndType: value
          });
        }
      }
    }, {
      key: 'onRangeEndValueChange',
      value: function onRangeEndValueChange(value) {
        var element = this.props.context.element;
        var _state7 = this.state,
            type = _state7.type,
            rangeStartValue = _state7.rangeStartValue,
            rangeStartType = _state7.rangeStartType,
            rangeEndType = _state7.rangeEndType;

        if (type === RANGE$1) {
          this.editCell(element.businessObject, getRangeString(rangeStartValue, value, rangeStartType, rangeEndType));

          this.setState({
            rangeEndValue: value
          });
        }
      }
    }, {
      key: 'renderComparison',
      value: function renderComparison(comparisonOperator, comparisonValue) {
        var comparisonOperatorOptions = [{
          label: 'Equals',
          value: 'equals'
        }, {
          label: 'Less',
          value: 'less'
        }, {
          label: 'Less or equals',
          value: 'lessEquals'
        }, {
          label: 'Greater',
          value: 'greater'
        }, {
          label: 'Greater or equals',
          value: 'greaterEquals'
        }];

        return createVNode(1, 'div', 'comparison', [createVNode(1, 'h4', 'dms-heading', createTextVNode('Value'), 2), createVNode(1, 'div', 'dms-fill-row', [createComponentVNode(2, InputSelect, {
          'noInput': true,
          'onChange': this.onComparisonOperatorChange,
          'options': comparisonOperatorOptions,
          'value': comparisonOperator
        }), createTextVNode('\xA0'), createComponentVNode(2, Input, {
          'className': 'comparison-number-input',
          'onInput': this.onComparisonValueChange,
          'type': 'number',
          'value': comparisonValue
        })], 4)], 4);
      }
    }, {
      key: 'renderRange',
      value: function renderRange(rangeStartValue, rangeEndValue, rangeStartType, rangeEndType) {
        var rangeTypeOptions = [{
          label: 'Include',
          value: 'include'
        }, {
          label: 'Exclude',
          value: 'exclude'
        }];

        return createVNode(1, 'div', 'range', [createVNode(1, 'h4', 'dms-heading', createTextVNode('Start Value'), 2), createVNode(1, 'div', 'dms-fill-row', [createComponentVNode(2, InputSelect, {
          'noInput': true,
          'onChange': this.onRangeStartTypeChange,
          'options': rangeTypeOptions,
          'value': rangeStartType
        }), createTextVNode('\xA0'), createComponentVNode(2, Input, {
          'className': 'range-start-number-input',
          'onInput': this.onRangeStartValueChange,
          'type': 'number',
          'value': rangeStartValue
        })], 4), createVNode(1, 'h4', 'dms-heading', createTextVNode('End Value'), 2), createVNode(1, 'div', 'dms-fill-row', [createComponentVNode(2, InputSelect, {
          'noInput': true,
          'onChange': this.onRangeEndTypeChange,
          'options': rangeTypeOptions,
          'value': rangeEndType
        }), createTextVNode('\xA0'), createComponentVNode(2, Input, {
          'className': 'range-end-number-input',
          'onInput': this.onRangeEndValueChange,
          'type': 'number',
          'value': rangeEndValue
        })], 4)], 4);
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _state8 = this.state,
            type = _state8.type,
            comparisonOperator = _state8.comparisonOperator,
            comparisonValue = _state8.comparisonValue,
            rangeStartValue = _state8.rangeStartValue,
            rangeEndValue = _state8.rangeEndValue,
            rangeStartType = _state8.rangeStartType,
            rangeEndType = _state8.rangeEndType;

        var typeOptions = [{
          label: 'Comparison',
          value: COMPARISON
        }, {
          label: 'Range',
          value: RANGE$1
        }];

        return createVNode(1, 'div', 'context-menu-container simple-number-edit', [createVNode(1, 'h3', 'dms-heading', createTextVNode('Edit Number'), 2), createVNode(1, 'div', 'dms-fill-row', createComponentVNode(2, InputSelect, {
          'noInput': true,
          'onChange': this.onTypeChange,
          'options': typeOptions,
          'value': type
        }), 2), type === COMPARISON && this.renderComparison(comparisonOperator, comparisonValue), type === RANGE$1 && this.renderRange(rangeStartValue, rangeEndValue, rangeStartType, rangeEndType)], 0);
      }
    }]);

    return InputNumberEdit;
  }(Component);

  var _typeof$69 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$93 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$113(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$58(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$69(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$58(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$69(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var OutputNumberEdit = function (_Component) {
    _inherits$58(OutputNumberEdit, _Component);

    function OutputNumberEdit(props, context) {
      _classCallCheck$113(this, OutputNumberEdit);

      var _this = _possibleConstructorReturn$58(this, (OutputNumberEdit.__proto__ || Object.getPrototypeOf(OutputNumberEdit)).call(this, props, context));

      _this._modeling = context.injector.get('modeling');

      var element = _this.props.context.element;

      var parsedString = parseString$3(element.businessObject.text);

      if (parsedString) {
        _this.state = {
          value: parsedString.value
        };
      } else {
        _this.state = {
          value: ''
        };
      }

      var debounceInput = context.injector.get('debounceInput');

      _this.debouncedEditCell = debounceInput(_this.editCell.bind(_this));
      _this.editCell = _this.editCell.bind(_this);

      _this.onInput = _this.onInput.bind(_this);
      return _this;
    }

    _createClass$93(OutputNumberEdit, [{
      key: 'editCell',
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }
    }, {
      key: 'onInput',
      value: function onInput(value) {
        var element = this.props.context.element;

        this.debouncedEditCell(element.businessObject, value);

        this.setState({
          value: value
        });
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var value = this.state.value;

        return createVNode(1, 'div', 'context-menu-container simple-number-edit', [createVNode(1, 'h3', 'dms-heading', createTextVNode('Edit Number'), 2), createVNode(1, 'h4', 'dms-heading', createTextVNode('Set Value'), 2), createComponentVNode(2, Input, {
          'onInput': this.onInput,
          'type': 'number',
          'value': value
        })], 4);
      }
    }]);

    return OutputNumberEdit;
  }(Component);

  function _classCallCheck$114(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var SimpleNumberEdit = function SimpleNumberEdit(components, simpleMode) {
    _classCallCheck$114(this, SimpleNumberEdit);

    simpleMode.registerProvider(function (element) {
      var typeRef = getTypeRef$2(element);

      return (isInput(element.col) || isOutput(element.col)) && (typeRef === 'integer' || typeRef === 'long' || typeRef === 'double');
    });

    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (context.contextMenuType && context.contextMenuType === 'simple-mode-edit') {

        if (!context.element) {
          return;
        }

        var typeRef = getTypeRef$2(context.element);

        if (isNumber$3(typeRef)) {

          if (isInput(context.element.col)) {
            return InputNumberEdit;
          } else if (isOutput(context.element.col)) {
            return OutputNumberEdit;
          }
        }
      }
    });
  };

  SimpleNumberEdit.$inject = ['components', 'simpleMode'];

  // helpers //////////////////////

  function getTypeRef$2(element) {
    if (isInput(element.col)) {
      return element.col && element.col.businessObject.inputExpression.typeRef;
    } else {
      return element.col && element.col.businessObject.typeRef;
    }
  }

  function isNumber$3(typeRef) {
    return typeRef === 'integer' || typeRef === 'long' || typeRef === 'double';
  }

  var simpleNumberEditModule = {
    __depends__: [Keyboard$2, SimpleMode$1],
    __init__: ['simpleNumberEdit'],
    simpleNumberEdit: ['type', SimpleNumberEdit]
  };

  /**
   * Parse input/output entry string to unary tests and type of unary tests.
   *
   * Example:
   *
   * not("foo", "bar")
   *
   * returns
   *
   * {
   *   type: 'negation',
   *   values: [ "foo", "bar, baz" ]
   * }
   *
   * @param {String} string - Input/Output entry as string e.g. "foo", "bar".
   */
  function parseString$4(string) {

    // empty string or no string at all
    if (!string || isEmptyString$3(string.trim())) {
      return {
        type: 'disjunction',
        values: []
      };
    }

    // disjunction
    var values = string.split(',');

    var result = {
      type: 'disjunction',
      values: []
    };

    var openString = '';

    values.forEach(function (value) {
      openString += value;

      if (/^"[^"]*"$/.test(openString.trim())) {
        result.values.push(openString.trim());

        openString = '';
      } else {
        openString += ',';
      }
    });

    if (!openString) {
      return result;
    }

    // negation
    result.type = 'negation';
    result.values = [];

    openString = '';

    var matches = string.match(/^\s*not\((.*)\)\s*$/);

    if (matches) {
      values = matches[1].split(',');

      values.forEach(function (value) {
        openString += value;

        if (/^"[^"]*"$/.test(openString.trim())) {
          result.values.push(openString.trim());

          openString = '';
        } else {
          openString += ',';
        }
      });

      if (!openString) {
        return result;
      }
    }
  }

  // TODO(philippfromme): seperate when refactoring component
  function getInputOrOutputValues(inputOrOutput) {
    var inputOrOutputValues = isInput(inputOrOutput) ? inputOrOutput.inputValues : inputOrOutput.outputValues;

    if (!inputOrOutputValues || isEmptyString$3(inputOrOutputValues.text)) {
      return [];
    } else {
      return inputOrOutputValues.text.split(',').map(function (value) {
        return value.trim();
      });
    }
  }

  function isEmptyString$3(string) {
    return string === '';
  }

  var _typeof$70 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$94 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$115(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$59(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$70(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$59(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$70(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var DISJUNCTION = 'disjunction',
      NEGATION = 'negation';

  var INPUT_VALUES_LABEL = 'Predefined Values',
      OUTPUT_VALUES_LABEL = 'Predefined Values',
      INPUT_ENTRY_VALUES_LABEL = 'Custom Values';

  var SimpleStringEditContextMenuComponent = function (_Component) {
    _inherits$59(SimpleStringEditContextMenuComponent, _Component);

    function SimpleStringEditContextMenuComponent(props, context) {
      _classCallCheck$115(this, SimpleStringEditContextMenuComponent);

      var _this = _possibleConstructorReturn$59(this, (SimpleStringEditContextMenuComponent.__proto__ || Object.getPrototypeOf(SimpleStringEditContextMenuComponent)).call(this, props, context));

      _this._modeling = context.injector.get('modeling');

      var parsedString = parseString$4(props.context.element.businessObject.text);

      // could not parse
      if (!parsedString) {
        parsedString = {
          values: [],
          type: DISJUNCTION
        };
      }

      var inputOrOutputValues = getInputOrOutputValues(props.context.element.col.businessObject);

      var filteredValues = parsedString.values.filter(function (value) {
        return !includes(inputOrOutputValues, value);
      });

      var isInputClause = isInput(props.context.element.col);

      var items = inputOrOutputValues.map(function (value) {
        return {
          value: value,
          isChecked: includes(parsedString.values, value),
          isRemovable: false,
          group: isInputClause ? INPUT_VALUES_LABEL : OUTPUT_VALUES_LABEL
        };
      });

      if (isInputClause) {
        items = items.concat(filteredValues.map(function (value) {
          return {
            value: value,
            isChecked: true,
            isRemovable: true,
            group: INPUT_ENTRY_VALUES_LABEL
          };
        }));
      }

      var inputValue = '';

      if (!isInputClause && parsedString.values.length && !includes(inputOrOutputValues, parsedString.values[0])) {
        inputValue = parsedString.values[0];
      }

      _this.state = {
        items: items,
        unaryTestsType: parsedString.type,
        inputValue: inputValue,
        isOutputValueInputChecked: inputValue !== ''
      };

      var debounceInput = context.injector.get('debounceInput');

      _this.debouncedEditCell = debounceInput(_this.editCell.bind(_this));
      _this.editCell = _this.editCell.bind(_this);
      _this.addUnaryTestsListItem = _this.addUnaryTestsListItem.bind(_this);
      _this.onInput = _this.onInput.bind(_this);
      _this.onKeyDown = _this.onKeyDown.bind(_this);
      _this.onOutputValueInputClick = _this.onOutputValueInputClick.bind(_this);
      _this.onUnaryTestsListChanged = _this.onUnaryTestsListChanged.bind(_this);
      _this.onUnaryTestsTypeChange = _this.onUnaryTestsTypeChange.bind(_this);
      return _this;
    }

    _createClass$94(SimpleStringEditContextMenuComponent, [{
      key: 'editCell',
      value: function editCell(cell, text) {
        this._modeling.editCell(cell, text);
      }

      /**
       * Change type of unary tests.
       */

    }, {
      key: 'onUnaryTestsTypeChange',
      value: function onUnaryTestsTypeChange(value) {
        var items = this.state.items;

        var values = getValues(items);

        var element = this.props.context.element;

        if (value === DISJUNCTION) {
          this.editCell(element.businessObject, values.join(','));

          this.setState({
            unaryTestsType: DISJUNCTION
          });
        } else {
          this.editCell(element.businessObject, 'not(' + values.join(',') + ')');

          this.setState({
            unaryTestsType: NEGATION
          });
        }
      }

      /**
       * Change list of unary tests.
       */

    }, {
      key: 'onUnaryTestsListChanged',
      value: function onUnaryTestsListChanged(items) {

        // get checked items
        var values = getValues(items);

        var element = this.props.context.element;
        var unaryTestsType = this.state.unaryTestsType;

        if (unaryTestsType === DISJUNCTION) {
          this.editCell(element.businessObject, values.join(','));
        } else {
          this.editCell(element.businessObject, 'not(' + values.join(',') + ')');
        }

        this.setState({
          items: items,
          isOutputValueInputChecked: false
        });
      }

      /**
       * Set output value to input value.
       */

    }, {
      key: 'onOutputValueInputClick',
      value: function onOutputValueInputClick() {
        var element = this.props.context.element;
        var _state = this.state,
            inputValue = _state.inputValue,
            items = _state.items;

        var parsedString = parseString$4(inputValue);

        if (!parsedString || parsedString.values.length > 1) {
          return;
        }

        this.editCell(element.businessObject, '' + parsedString.values.join(''));

        // uncheck all other values
        this.setState({
          items: items.map(function (item) {
            item.isChecked = false;

            return item;
          }),
          isOutputValueInputChecked: true
        });
      }

      /**
       * Set output value if valid.
       */

    }, {
      key: 'onInput',
      value: function onInput(_ref) {
        var isValid = _ref.isValid,
            value = _ref.value;
        var isOutputValueInputChecked = this.state.isOutputValueInputChecked;

        this.setState({
          inputValue: value
        });

        var element = this.props.context.element;

        if (!isInput(element) && isValid && isOutputValueInputChecked) {
          this.debouncedEditCell(element.businessObject, value);
        }
      }

      /**
       * Add new value on ENTER.
       */

    }, {
      key: 'onKeyDown',
      value: function onKeyDown(_ref2) {
        var isValid = _ref2.isValid,
            event = _ref2.event;

        if (!isEnter$1(event.keyCode)) {
          return;
        }

        var element = this.props.context.element;

        var isInputClause = isInput(element.col);

        // stop ENTER propagation (and ContextMenu close)
        if (isInputClause || !isValid) {
          event.stopPropagation();
          event.preventDefault();
        }

        if (isValid) {
          if (isInputClause) {
            this.addUnaryTestsListItem();
          } else {
            this.onOutputValueInputClick();
          }
        }
      }

      /**
       * Add unary tests to list.
       */

    }, {
      key: 'addUnaryTestsListItem',
      value: function addUnaryTestsListItem() {
        var _state2 = this.state,
            inputValue = _state2.inputValue,
            items = _state2.items,
            unaryTestsType = _state2.unaryTestsType;

        var parsedInput = parseString$4(inputValue);

        if (!parsedInput) {
          return;
        }

        var element = this.props.context.element;

        var values = getValues(items);

        var newValues = [].concat(values, parsedInput.values);

        if (unaryTestsType === DISJUNCTION) {
          this.editCell(element.businessObject, newValues.join(','));
        } else {
          this.editCell(element.businessObject, 'not(' + newValues.join(',') + ')');
        }

        var newItems = items.concat(parsedInput.values.map(function (value) {
          return {
            value: value,
            isChecked: true,
            isRemovable: true,
            group: 'Custom Values'
          };
        }));

        this.setState({
          items: newItems,
          inputValue: ''
        });
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _this2 = this;

        var element = this.props.context.element;
        var _state3 = this.state,
            inputValue = _state3.inputValue,
            isOutputValueInputChecked = _state3.isOutputValueInputChecked,
            items = _state3.items,
            unaryTestsType = _state3.unaryTestsType;

        var options$$1 = [{
          label: 'Match one',
          value: DISJUNCTION
        }, {
          label: 'Match none',
          value: NEGATION
        }];

        var isInputClause = isInput(element.col);

        var isNegation = unaryTestsType === NEGATION;

        var showRadio = !isInputClause && items.length > 0;

        return createVNode(1, 'div', 'simple-string-edit context-menu-container', [createVNode(1, 'h3', 'dms-heading', createTextVNode('Edit String'), 2), isInputClause && createVNode(1, 'p', null, createComponentVNode(2, InputSelect, {
          'noInput': true,
          'onChange': this.onUnaryTestsTypeChange,
          'options': options$$1,
          'value': isNegation ? NEGATION : DISJUNCTION
        }, null, function (node) {
          return _this2.selectNode = node;
        }), 2), createComponentVNode(2, List, {
          'onChange': this.onUnaryTestsListChanged,
          'items': items,
          'type': isInputClause ? 'checkbox' : 'radio'
        }), isInputClause ? createVNode(1, 'h4', 'dms-heading', createTextVNode('Add Values'), 2) : createVNode(1, 'h4', 'dms-heading', createTextVNode('Set Value'), 2), createVNode(1, 'div', 'dms-fill-row', [showRadio && createVNode(64, 'input', 'cursor-pointer', null, 1, {
          'checked': isOutputValueInputChecked,
          'onClick': this.onOutputValueInputClick,
          'type': 'radio',
          'style': {
            marginRight: '8px'
          }
        }), createComponentVNode(2, ValidatedInput, {
          'className': 'dms-block',
          'onKeyDown': this.onKeyDown,
          'onInput': this.onInput,
          'placeholder': isInputClause ? '"value", "value", ...' : '"value"',
          'type': 'text',
          'validate': function validate(value) {
            if (!parseString$4(value)) {
              return 'Strings must be in double quotes.';
            }
          },
          'value': inputValue
        })], 0)], 0);
      }
    }]);

    return SimpleStringEditContextMenuComponent;
  }(Component);
  function isEnter$1(keyCode) {
    return keyCode === 13;
  }

  /**
   * Get array of actual values from array of items.
   *
   * @param {Array} items - Array of items.
   */
  function getValues(items) {
    return items.filter(function (item) {
      return item.isChecked;
    }).map(function (item) {
      return item.value;
    });
  }

  function includes(array, value) {
    return array.indexOf(value) !== -1;
  }

  function _classCallCheck$116(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var SimpleStringEdit = function SimpleStringEdit(components, simpleMode) {
    _classCallCheck$116(this, SimpleStringEdit);

    simpleMode.registerProvider(function (element) {
      return (isInput(element.col) || isOutput(element.col)) && getTypeRef$3(element) === 'string';
    });

    components.onGetComponent('context-menu', function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (context.contextMenuType && context.contextMenuType === 'simple-mode-edit') {

        if (!context.element) {
          return;
        }

        var typeRef = getTypeRef$3(context.element);

        if (typeRef === 'string') {
          return SimpleStringEditContextMenuComponent;
        }
      }
    });
  };

  SimpleStringEdit.$inject = ['components', 'simpleMode'];

  // helpers //////////////////////

  function getTypeRef$3(element) {
    if (isInput(element.col)) {
      return element.col && element.col.businessObject.inputExpression.typeRef;
    } else {
      return element.col && element.col.businessObject.typeRef;
    }
  }

  var simpleStringEditModule = {
    __depends__: [Keyboard$2, SimpleMode$1],
    __init__: ['simpleStringEdit'],
    simpleStringEdit: ['type', SimpleStringEdit]
  };

  var _typeof$71 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$95 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _toConsumableArray$10(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function _classCallCheck$117(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$60(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$71(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$60(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$71(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var Editor$1 = function (_Viewer) {
    _inherits$60(Editor, _Viewer);

    function Editor() {
      _classCallCheck$117(this, Editor);

      return _possibleConstructorReturn$60(this, (Editor.__proto__ || Object.getPrototypeOf(Editor)).apply(this, arguments));
    }

    _createClass$95(Editor, [{
      key: 'getModules',
      value: function getModules() {
        return [].concat(_toConsumableArray$10(Viewer$1._getModules()), _toConsumableArray$10(Editor._getModules()));
      }
    }], [{
      key: '_getModules',
      value: function _getModules() {
        return [addRuleModule, annotationsEditorModule, CellSelection$1, ContextMenu$2, CopyCutPaste, copyCutPasteKeybindingsModule, createInputsModule, decisionTableContextMenu, EditorActions$3, tableHeadEditorModule, dragAndDropModule, descriptionModule, expressionLanguageModule, Keyboard$2, tableHeadEditorModule, tablePropertiesEditorModule, EditorActions$2, hitPolicyEditorModule, InteractionModule, modelingModule, decisionRulesEditorModule, Selection$2, SimpleMode$1, simpleBooleanEditModule, simpleDateEditModule, simpleNumberEditModule, simpleStringEditModule];
      }
    }]);

    return Editor;
  }(Viewer$1);

  var _createClass$96 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$118(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var ChangeSupport$2 = function () {
    function ChangeSupport(eventBus) {
      var _this = this;

      _classCallCheck$118(this, ChangeSupport);

      this._listeners = {};

      eventBus.on('elements.changed', function (_ref) {
        var elements = _ref.elements;

        _this.elementsChanged(elements);
      });

      eventBus.on('element.updateId', function (_ref2) {
        var element = _ref2.element,
            newId = _ref2.newId;

        _this.updateId(element.id, newId);
      });
    }

    _createClass$96(ChangeSupport, [{
      key: 'elementsChanged',
      value: function elementsChanged(elements) {
        var invoked = {};

        var elementsLength = elements.length;

        for (var i = 0; i < elementsLength; i++) {
          var id = elements[i].id;

          if (invoked[id]) {
            return;
          }

          invoked[id] = true;

          var listenersLength = this._listeners[id] && this._listeners[id].length;

          if (listenersLength) {
            for (var j = 0; j < listenersLength; j++) {

              // listeners might remove themselves before they get called
              this._listeners[id][j] && this._listeners[id][j]();
            }
          }
        }
      }
    }, {
      key: 'onElementsChanged',
      value: function onElementsChanged(id, listener) {
        if (!this._listeners[id]) {
          this._listeners[id] = [];
        }

        // avoid push for better performance
        this._listeners[id][this._listeners[id].length] = listener;
      }
    }, {
      key: 'offElementsChanged',
      value: function offElementsChanged(id, listener) {
        if (!this._listeners[id]) {
          return;
        }

        if (listener) {
          var idx = this._listeners[id].indexOf(listener);

          if (idx !== -1) {
            this._listeners[id].splice(idx, 1);
          }
        } else {
          this._listeners[id].length = 0;
        }
      }
    }, {
      key: 'updateId',
      value: function updateId(oldId, newId) {
        if (this._listeners[oldId]) {

          this._listeners[newId] = this._listeners[oldId];

          delete this._listeners[oldId];
        }
      }
    }]);

    return ChangeSupport;
  }();

  ChangeSupport$2.$inject = ['eventBus'];

  var _createClass$97 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$119(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var DEFAULT_PRIORITY$3 = 1000;

  var Components$1 = function () {
    function Components() {
      _classCallCheck$119(this, Components);

      this._listeners = {};
    }

    _createClass$97(Components, [{
      key: 'getComponent',
      value: function getComponent(type, context) {
        var listeners = this._listeners[type];

        if (!listeners) {
          return;
        }

        var component = void 0;

        for (var i = 0; i < listeners.length; i++) {
          component = listeners[i].callback(context);

          if (component) {
            break;
          }
        }

        return component;
      }
    }, {
      key: 'getComponents',
      value: function getComponents(type, context) {
        var listeners = this._listeners[type];

        if (!listeners) {
          return;
        }

        var components = [];

        for (var i = 0; i < listeners.length; i++) {
          var component = listeners[i].callback(context);

          if (component) {
            components.push(component);
          }
        }

        if (!components.length) {
          return;
        }

        return components;
      }
    }, {
      key: 'onGetComponent',
      value: function onGetComponent(type, priority, callback) {
        if (isFunction(priority)) {
          callback = priority;
          priority = DEFAULT_PRIORITY$3;
        }

        if (!isNumber(priority)) {
          throw new Error('priority must be a number');
        }

        var listeners = this._getListeners(type);

        var existingListener = void 0,
            idx = void 0;

        var newListener = { priority: priority, callback: callback };

        for (idx = 0; existingListener = listeners[idx]; idx++) {
          if (existingListener.priority < priority) {

            // prepend newListener at before existingListener
            listeners.splice(idx, 0, newListener);
            return;
          }
        }

        listeners.push(newListener);
      }
    }, {
      key: 'offGetComponent',
      value: function offGetComponent(type, callback) {
        var listeners = this._getListeners(type);

        var listener = void 0,
            listenerCallback = void 0,
            idx = void 0;

        if (callback) {

          // move through listeners from back to front
          // and remove matching listeners
          for (idx = listeners.length - 1; listener = listeners[idx]; idx--) {
            listenerCallback = listener.callback;

            if (listenerCallback === callback) {
              listeners.splice(idx, 1);
            }
          }
        } else {
          // clear listeners
          listeners.length = 0;
        }
      }
    }, {
      key: '_getListeners',
      value: function _getListeners(type) {
        var listeners = this._listeners[type];

        if (!listeners) {
          this._listeners[type] = listeners = [];
        }

        return listeners;
      }
    }]);

    return Components;
  }();

  var _typeof$72 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$98 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$120(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$61(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$72(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$61(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$72(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ViewerComponent = function (_Component) {
    _inherits$61(ViewerComponent, _Component);

    function ViewerComponent(props) {
      _classCallCheck$120(this, ViewerComponent);

      var _this = _possibleConstructorReturn$61(this, (ViewerComponent.__proto__ || Object.getPrototypeOf(ViewerComponent)).call(this, props));

      var injector = _this._injector = props.injector;

      _this._changeSupport = injector.get('changeSupport');
      _this._components = injector.get('components');
      _this._renderer = injector.get('renderer');
      return _this;
    }

    _createClass$98(ViewerComponent, [{
      key: 'getChildContext',
      value: function getChildContext() {
        return {
          changeSupport: this._changeSupport,
          components: this._components,
          renderer: this._renderer,
          injector: this._injector
        };
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var components = this._components.getComponents('viewer');

        return createVNode(1, 'div', 'viewer-container', components && components.map(function (Component$$1, index) {
          return createComponentVNode(2, Component$$1, null, index);
        }), 0);
      }
    }]);

    return ViewerComponent;
  }(Component);

  var _createClass$99 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$121(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Renderer$1 = function () {
    function Renderer(changeSupport, components, config, eventBus, injector) {
      _classCallCheck$121(this, Renderer);

      var container = config.container;

      this._container = container;

      eventBus.on('renderer.mount', function () {
        render(createComponentVNode(2, ViewerComponent, {
          'injector': injector
        }), container);
      });

      eventBus.on('renderer.unmount', function () {
        render(null, container);
      });
    }

    _createClass$99(Renderer, [{
      key: 'getContainer',
      value: function getContainer() {
        return this._container;
      }
    }]);

    return Renderer;
  }();

  Renderer$1.$inject = ['changeSupport', 'components', 'config.renderer', 'eventBus', 'injector'];

  var core$1 = {
    __init__: ['changeSupport', 'components', 'renderer'],
    changeSupport: ['type', ChangeSupport$2],
    components: ['type', Components$1],
    eventBus: ['type', EventBus],
    renderer: ['type', Renderer$1]
  };

  var _createClass$100 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _objectWithoutProperties$7(obj, keys) {
    var target = {};for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
    }return target;
  }

  function _classCallCheck$122(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * A base for React-style viewers.
   */

  var Viewer$2 = function () {
    function Viewer() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck$122(this, Viewer);

      var injector = options.injector;

      if (!injector) {
        var _init2 = this._init(options),
            modules = _init2.modules,
            config = _init2.config;

        injector = createInjector$2(config, modules);
      }

      this.get = injector.get;

      this.invoke = injector.invoke;

      this.get('eventBus').fire('viewer.init');
    }

    /**
     * Intialize and return modules and config used for creation.
     *
     * @param  {Object} options
     *
     * @return {Object} { modules=[], config }
     */

    _createClass$100(Viewer, [{
      key: '_init',
      value: function _init(options) {
        var modules = options.modules,
            config = _objectWithoutProperties$7(options, ['modules']);

        return { modules: modules, config: config };
      }

      /**
       * Destroy. This results in removing the attachment from the container.
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        var eventBus = this.get('eventBus');

        eventBus.fire('viewer.destroy');
      }

      /**
       * Clear. Should be used to reset the state of any stateful services.
       */

    }, {
      key: 'clear',
      value: function clear() {
        var eventBus = this.get('eventBus');

        eventBus.fire('viewer.clear');
      }
    }]);

    return Viewer;
  }();
  function bootstrap$2(bootstrapModules) {

    var modules = [],
        components = [];

    function hasModule(m) {
      return modules.indexOf(m) >= 0;
    }

    function addModule(m) {
      modules.push(m);
    }

    function visit(m) {
      if (hasModule(m)) {
        return;
      }

      (m.__depends__ || []).forEach(visit);

      if (hasModule(m)) {
        return;
      }

      addModule(m);

      (m.__init__ || []).forEach(function (c) {
        components.push(c);
      });
    }

    bootstrapModules.forEach(visit);

    var injector = new Injector(modules);

    components.forEach(function (c) {

      try {
        // eagerly resolve component (fn or string)
        injector[typeof c === 'string' ? 'get' : 'invoke'](c);
      } catch (e) {
        console.error('Failed to instantiate component');
        console.error(e.stack);

        throw e;
      }
    });

    return injector;
  }

  function createInjector$2(config, modules) {
    var bootstrapModules = [{
      config: ['value', config]
    }, core$1].concat(modules || []);

    return bootstrap$2(bootstrapModules);
  }

  var _createClass$101 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$123(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * A single decision element registry.
   *
   * The sole purpose of this service is to provide the necessary API
   * to serve shared components, i.e. the UpdatePropertiesHandler.
   */
  var ElementRegistry$2 = function () {
    function ElementRegistry(viewer, eventBus) {
      _classCallCheck$123(this, ElementRegistry);

      this._eventBus = eventBus;
      this._viewer = viewer;
    }

    _createClass$101(ElementRegistry, [{
      key: 'getDecision',
      value: function getDecision() {
        return this._viewer.getDecision();
      }
    }, {
      key: 'updateId',
      value: function updateId(element, newId) {

        var decision = this.getDecision();

        if (element !== decision) {
          throw new Error('element !== decision');
        }

        this._eventBus.fire('element.updateId', {
          element: element,
          newId: newId
        });

        element.id = newId;
      }
    }]);

    return ElementRegistry;
  }();

  ElementRegistry$2.$inject = ['viewer', 'eventBus'];

  var CoreModule$2 = {
    __init__: ['elementRegistry'],
    elementRegistry: ['type', ElementRegistry$2]
  };

  var _typeof$73 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$102 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$124(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$62(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$73(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$62(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$73(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var DecisionPropertiesComponent = function (_Component) {
    _inherits$62(DecisionPropertiesComponent, _Component);

    function DecisionPropertiesComponent(props, context) {
      _classCallCheck$124(this, DecisionPropertiesComponent);

      var _this = _possibleConstructorReturn$62(this, (DecisionPropertiesComponent.__proto__ || Object.getPrototypeOf(DecisionPropertiesComponent)).call(this, props, context));

      _this._viewer = context.injector.get('viewer');
      return _this;
    }

    _createClass$102(DecisionPropertiesComponent, [{
      key: 'render',
      value: function render$$1() {

        // there is only one single element
        var _viewer$getDecision = this._viewer.getDecision(),
            name = _viewer$getDecision.name,
            id = _viewer$getDecision.id;

        return createVNode(1, 'div', 'decision-properties', [createVNode(1, 'h3', 'decision-name', name, 0), createVNode(1, 'h5', 'decision-id', id, 0)], 4);
      }
    }]);

    return DecisionPropertiesComponent;
  }(Component);

  function _classCallCheck$125(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var HIGH_PRIORITY$3 = 2000;

  var DecisionProperties = function DecisionProperties(components) {
    _classCallCheck$125(this, DecisionProperties);

    components.onGetComponent('viewer', HIGH_PRIORITY$3, function () {
      return DecisionPropertiesComponent;
    });
  };

  DecisionProperties.$inject = ['components'];

  var DecisionPropertiesModule = {
    __init__: ['decisionProperties'],
    decisionProperties: ['type', DecisionProperties]
  };

  var _typeof$74 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$103 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$126(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$63(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$74(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$63(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$74(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var LiteralExpressionPropertiesComponent = function (_Component) {
    _inherits$63(LiteralExpressionPropertiesComponent, _Component);

    function LiteralExpressionPropertiesComponent(props, context) {
      _classCallCheck$126(this, LiteralExpressionPropertiesComponent);

      var _this = _possibleConstructorReturn$63(this, (LiteralExpressionPropertiesComponent.__proto__ || Object.getPrototypeOf(LiteralExpressionPropertiesComponent)).call(this, props, context));

      _this._viewer = context.injector.get('viewer');
      return _this;
    }

    _createClass$103(LiteralExpressionPropertiesComponent, [{
      key: 'render',
      value: function render$$1() {
        var _viewer$getDecision = this._viewer.getDecision(),
            literalExpression = _viewer$getDecision.literalExpression,
            variable = _viewer$getDecision.variable;

        return createVNode(1, 'div', 'literal-expression-properties', createVNode(1, 'table', null, [createVNode(1, 'tr', null, [createVNode(1, 'td', null, createTextVNode('Variable Name:'), 2), createVNode(1, 'td', null, createVNode(1, 'span', null, variable.name || '-', 0), 2)], 4), createVNode(1, 'tr', null, [createVNode(1, 'td', null, createTextVNode('Variable Type:'), 2), createVNode(1, 'td', null, createVNode(1, 'span', null, variable.typeRef || '-', 0), 2)], 4), createVNode(1, 'tr', null, [createVNode(1, 'td', null, createTextVNode('Expression Language:'), 2), createVNode(1, 'td', null, createVNode(1, 'span', null, literalExpression.expressionLanguage || '-', 0), 2)], 4)], 4), 2);
      }
    }]);

    return LiteralExpressionPropertiesComponent;
  }(Component);

  function _classCallCheck$127(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var LOW_PRIORITY$11 = 500;

  var DecisionProperties$1 = function DecisionProperties(components) {
    _classCallCheck$127(this, DecisionProperties);

    components.onGetComponent('viewer', LOW_PRIORITY$11, function () {
      return LiteralExpressionPropertiesComponent;
    });
  };

  DecisionProperties$1.$inject = ['components'];

  var LiteralExpressionPropertiesModule = {
    __init__: ['literalExpressionProperties'],
    literalExpressionProperties: ['type', DecisionProperties$1]
  };

  var _typeof$75 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$104 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$128(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$64(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$75(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$64(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$75(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  // eslint-disable-next-line
  var logo$2 = 'iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAMAAADypuvZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADBQTFRFiMte9PrwldFwfcZPqtqN0+zEyOe1XLgjvuKncsJAZ70y6fXh3vDT////UrQV////G2zN+AAAABB0Uk5T////////////////////AOAjXRkAAAHDSURBVHjavJZJkoUgDEBJmAX8979tM8u3E6x20VlYJfFFMoL4vBDxATxZcakIOJTWSmxvKWVIkJ8jHvlRv1F2LFrVISCZI+tCtQx+XfewgVTfyY3plPiQEAzI3zWy+kR6NBhFBYeBuscJLOUuA2WVLpCjVIaFzrNQZArxAZKUQm6gsj37L9Cb7dnIBUKxENaaMJQqMpDXvSL+ktxdGRm2IsKgJGGPg7atwUG5CcFUEuSv+CwQqizTrvDTNXdMU2bMiDWZd8d7QIySWVRsb2vBBioxOFt4OinPBapL+neAb5KL5IJ8szOza2/DYoipUCx+CjO0Bpsv0V6mktNZ+k8rlABlWG0FrOpKYVo8DT3dBeLEjUBAj7moDogVii7nSS9QzZnFcOVBp1g2PyBQ3Vr5aIapN91VJy33HTJLC1iX2FY6F8gRdaAeIEfVONgtFCzZTmoLEdOjBDfsIOA6128gw3eu1shAajdZNAORxuQDJN5A5PbEG6gNIu24QJD5iNyRMZIr6bsHbCtCU/OaOaSvgkUyDMdDa1BXGf5HJ1To+/Ym6mCKT02Y+/Sa126ZKyd3jxhzpc1r8zVL6YM1Qy/kR4ABAFJ6iQUnivhAAAAAAElFTkSuQmCC';

  var PoweredByLogoComponent$1 = function (_Component) {
    _inherits$64(PoweredByLogoComponent, _Component);

    function PoweredByLogoComponent(props, context) {
      _classCallCheck$128(this, PoweredByLogoComponent);

      var _this = _possibleConstructorReturn$64(this, (PoweredByLogoComponent.__proto__ || Object.getPrototypeOf(PoweredByLogoComponent)).call(this, props, context));

      _this.onClick = function () {
        _this._eventBus.fire('poweredBy.show');
      };

      var injector = context.injector;

      _this._eventBus = injector.get('eventBus');
      return _this;
    }

    _createClass$104(PoweredByLogoComponent, [{
      key: 'render',
      value: function render$$1() {
        var _this2 = this;

        return createVNode(1, 'div', 'powered-by-logo', createVNode(1, 'img', 'logo', null, 1, {
          'src': 'data:image/png;base64,' + logo$2
        }), 2, {
          'onClick': this.onClick,
          'title': 'Powered by bpmn.io'
        }, null, function (node) {
          return _this2.node = node;
        });
      }
    }]);

    return PoweredByLogoComponent;
  }(Component);

  var _typeof$76 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$105 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$129(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$65(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$76(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$65(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$76(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  // eslint-disable-next-line
  var logo$3 = 'iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAMAAADypuvZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADBQTFRFiMte9PrwldFwfcZPqtqN0+zEyOe1XLgjvuKncsJAZ70y6fXh3vDT////UrQV////G2zN+AAAABB0Uk5T////////////////////AOAjXRkAAAHDSURBVHjavJZJkoUgDEBJmAX8979tM8u3E6x20VlYJfFFMoL4vBDxATxZcakIOJTWSmxvKWVIkJ8jHvlRv1F2LFrVISCZI+tCtQx+XfewgVTfyY3plPiQEAzI3zWy+kR6NBhFBYeBuscJLOUuA2WVLpCjVIaFzrNQZArxAZKUQm6gsj37L9Cb7dnIBUKxENaaMJQqMpDXvSL+ktxdGRm2IsKgJGGPg7atwUG5CcFUEuSv+CwQqizTrvDTNXdMU2bMiDWZd8d7QIySWVRsb2vBBioxOFt4OinPBapL+neAb5KL5IJ8szOza2/DYoipUCx+CjO0Bpsv0V6mktNZ+k8rlABlWG0FrOpKYVo8DT3dBeLEjUBAj7moDogVii7nSS9QzZnFcOVBp1g2PyBQ3Vr5aIapN91VJy33HTJLC1iX2FY6F8gRdaAeIEfVONgtFCzZTmoLEdOjBDfsIOA6128gw3eu1shAajdZNAORxuQDJN5A5PbEG6gNIu24QJD5iNyRMZIr6bsHbCtCU/OaOaSvgkUyDMdDa1BXGf5HJ1To+/Ym6mCKT02Y+/Sa126ZKyd3jxhzpc1r8zVL6YM1Qy/kR4ABAFJ6iQUnivhAAAAAAElFTkSuQmCC';

  var PoweredByOverlayComponent$1 = function (_Component) {
    _inherits$65(PoweredByOverlayComponent, _Component);

    function PoweredByOverlayComponent(props) {
      _classCallCheck$129(this, PoweredByOverlayComponent);

      var _this = _possibleConstructorReturn$65(this, (PoweredByOverlayComponent.__proto__ || Object.getPrototypeOf(PoweredByOverlayComponent)).call(this, props));

      _this.state = {
        show: false
      };

      _this.onClick = _this.onClick.bind(_this);
      _this.onShow = _this.onShow.bind(_this);
      return _this;
    }

    _createClass$105(PoweredByOverlayComponent, [{
      key: 'onClick',
      value: function onClick() {
        this.setState({
          show: false
        });
      }
    }, {
      key: 'onShow',
      value: function onShow() {
        this.setState({
          show: true
        });
      }
    }, {
      key: 'componentWillMount',
      value: function componentWillMount() {
        var eventBus = this._eventBus = this.context.injector.get('eventBus');

        eventBus.on('poweredBy.show', this.onShow);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this._eventBus.off('poweredBy.show', this.onShow);
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var show = this.state.show;

        return show && createVNode(1, 'div', 'powered-by-overlay', createVNode(1, 'div', 'powered-by-overlay-content', [createVNode(1, 'div', null, createVNode(1, 'img', 'logo', null, 1, {
          'src': 'data:image/png;base64,' + logo$3
        }), 2), createVNode(1, 'div', null, [createTextVNode('Web-based tooling for BPMN, DMN and CMMN diagrams powered by '), createVNode(1, 'a', null, createTextVNode('bpmn.io'), 2, {
          'href': 'http://bpmn.io',
          'target': '_blank'
        }), createTextVNode('.')], 4)], 4, {
          'onClick': function onClick(e) {
            return e.stopPropagation();
          }
        }), 2, {
          'onClick': this.onClick
        });
      }
    }]);

    return PoweredByOverlayComponent;
  }(Component);

  function _classCallCheck$130(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var HIGHER_PRIORITY = 2000;

  var PoweredBy$1 = function PoweredBy(components, eventBus) {
    _classCallCheck$130(this, PoweredBy);

    components.onGetComponent('viewer', HIGHER_PRIORITY, function () {
      return PoweredByLogoComponent$1;
    });

    components.onGetComponent('viewer', function () {
      return PoweredByOverlayComponent$1;
    });
  };

  PoweredBy$1.$inject = ['components', 'eventBus'];

  var PoweredByModule$1 = {
    __init__: ['poweredBy'],
    poweredBy: ['type', PoweredBy$1]
  };

  var _typeof$77 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$106 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$131(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$66(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$77(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$66(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$77(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var TextareaComponent = function (_Component) {
    _inherits$66(TextareaComponent, _Component);

    function TextareaComponent(props, context) {
      _classCallCheck$131(this, TextareaComponent);

      var _this = _possibleConstructorReturn$66(this, (TextareaComponent.__proto__ || Object.getPrototypeOf(TextareaComponent)).call(this, props, context));

      _this._viewer = context.injector.get('viewer');
      return _this;
    }

    _createClass$106(TextareaComponent, [{
      key: 'render',
      value: function render$$1() {
        var text = this._viewer.getDecision().literalExpression.text;

        return createVNode(1, 'div', 'textarea', createVNode(1, 'div', 'content', text, 0), 2);
      }
    }]);

    return TextareaComponent;
  }(Component);

  function _classCallCheck$132(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Textarea = function Textarea(components) {
    _classCallCheck$132(this, Textarea);

    components.onGetComponent('viewer', function () {
      return TextareaComponent;
    });
  };

  Textarea.$inject = ['components'];

  var TextareaModule = {
    __init__: ['textarea'],
    textarea: ['type', Textarea]
  };

  var _typeof$78 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$107 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$133(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$67(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$78(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$67(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$78(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ViewDrdComponent$1 = function (_Component) {
    _inherits$67(ViewDrdComponent, _Component);

    function ViewDrdComponent(props, context) {
      _classCallCheck$133(this, ViewDrdComponent);

      var _this = _possibleConstructorReturn$67(this, (ViewDrdComponent.__proto__ || Object.getPrototypeOf(ViewDrdComponent)).call(this, props, context));

      _this.onClick = function () {
        _this._eventBus.fire('showDrd');
      };

      var injector = context.injector;

      _this._eventBus = injector.get('eventBus');
      return _this;
    }

    _createClass$107(ViewDrdComponent, [{
      key: 'render',
      value: function render$$1() {
        var _this2 = this;

        return createVNode(1, 'div', 'view-drd', createVNode(1, 'button', 'view-drd-button', createTextVNode('View DRD'), 2, {
          'onClick': this.onClick
        }), 2, null, null, function (node) {
          return _this2.node = node;
        });
      }
    }]);

    return ViewDrdComponent;
  }(Component);

  var _createClass$108 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$134(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var HIGH_PRIORITY$4 = 1500;

  var ViewDrd$1 = function () {
    function ViewDrd(components, viewer, eventBus, injector) {
      var _this = this;

      _classCallCheck$134(this, ViewDrd);

      this._injector = injector;
      this._viewer = viewer;

      components.onGetComponent('viewer', HIGH_PRIORITY$4, function () {
        if (_this.canViewDrd()) {
          return ViewDrdComponent$1;
        }
      });

      eventBus.on('showDrd', function () {
        var parent = injector.get('_parent', false);

        // there is only one single element
        var definitions = _this.getDefinitions();

        // open definitions
        var view = parent.getView(definitions);

        parent.open(view);
      });
    }

    _createClass$108(ViewDrd, [{
      key: 'canViewDrd',
      value: function canViewDrd() {
        var parent = this._injector.get('_parent', false);

        if (!parent) {
          return;
        }

        // there is only one single element
        var definitions = this.getDefinitions();

        return !!parent.getView(definitions);
      }
    }, {
      key: 'getDefinitions',
      value: function getDefinitions() {
        return _getDefinitions(this._viewer.getDecision());
      }
    }]);

    return ViewDrd;
  }();

  ViewDrd$1.$inject = ['components', 'viewer', 'eventBus', 'injector'];

  // helpers //////////////////////

  function _getDefinitions(decision) {
    var definitions = decision.$parent;

    return definitions;
  }

  var ViewDrdModule = {
    __init__: ['viewDrd'],
    viewDrd: ['type', ViewDrd$1]
  };

  var _typeof$79 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$109 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _get$4 = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;if (getter === undefined) {
        return undefined;
      }return getter.call(receiver);
    }
  };

  function _toConsumableArray$11(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function _objectWithoutProperties$8(obj, keys$$1) {
    var target = {};for (var i in obj) {
      if (keys$$1.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
    }return target;
  }

  function _classCallCheck$135(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$68(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$79(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$68(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$79(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var Viewer$3 = function (_BaseViewer) {
    _inherits$68(Viewer, _BaseViewer);

    function Viewer() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck$135(this, Viewer);

      var container = Viewer._createContainer();

      var _this = _possibleConstructorReturn$68(this, (Viewer.__proto__ || Object.getPrototypeOf(Viewer)).call(this, assign(options, {
        renderer: {
          container: container
        }
      })));

      _this._container = container;
      return _this;
    }

    _createClass$109(Viewer, [{
      key: 'open',
      value: function open(decision, done) {

        var err;

        // use try/catch to not swallow synchronous exceptions
        // that may be raised during model parsing
        try {

          if (this._decision) {

            // clear existing literal expression
            this.clear();

            // unmount first
            this.get('eventBus').fire('renderer.unmount');
          }

          // update literal expression
          this._decision = decision;

          // let others know about import
          this.get('eventBus').fire('import', decision);

          this.get('eventBus').fire('renderer.mount');
        } catch (e) {
          err = e;
        }

        // handle synchronously thrown exception
        return done(err);
      }

      /**
       * Initialize the literal expression, returning { modules: [], config }.
       *
       * @param  {Object} options
       *
       * @return {Object} init config
       */

    }, {
      key: '_init',
      value: function _init(options) {
        var modules = options.modules,
            additionalModules = options.additionalModules,
            config = _objectWithoutProperties$8(options, ['modules', 'additionalModules']);

        var baseModules = modules || this.getModules();
        var extraModules = additionalModules || [];
        var staticModules = [{
          viewer: ['value', this]
        }];

        var allModules = [].concat(_toConsumableArray$11(baseModules), _toConsumableArray$11(extraModules), staticModules);

        return {
          modules: allModules,
          config: config
        };
      }

      /**
       * Register an event listener
       *
       * Remove a previously added listener via {@link #off(event, callback)}.
       *
       * @param {String} event
       * @param {Number} [priority]
       * @param {Function} callback
       * @param {Object} [that]
       */

    }, {
      key: 'on',
      value: function on(event, priority, callback, target) {
        return this.get('eventBus').on(event, priority, callback, target);
      }

      /**
       * De-register an event listener
       *
       * @param {String} event
       * @param {Function} callback
       */

    }, {
      key: 'off',
      value: function off(event, callback) {
        this.get('eventBus').off(event, callback);
      }

      /**
       * Emit an event on the underlying {@link EventBus}
       *
       * @param  {String} type
       * @param  {Object} event
       *
       * @return {Object} event processing result (if any)
       */

    }, {
      key: '_emit',
      value: function _emit(type, event) {
        return this.get('eventBus').fire(type, event);
      }

      /**
       * Returns the currently displayed decision.
       *
       * @return {ModdleElement}
       */

    }, {
      key: 'getDecision',
      value: function getDecision() {
        return this._decision;
      }

      /**
       * Attach viewer to given parent node.
       *
       * @param  {Element} parentNode
       */

    }, {
      key: 'attachTo',
      value: function attachTo(parentNode) {

        if (!parentNode) {
          throw new Error('parentNode required');
        }

        // ensure we detach from the
        // previous, old parent
        this.detach();

        parentNode.appendChild(this._container);

        this._emit('attach', {});
      }

      /**
       * Detach viewer from parent node, if attached.
       */

    }, {
      key: 'detach',
      value: function detach() {

        var container = this._container,
            parentNode = container.parentNode;

        if (!parentNode) {
          return;
        }

        this._emit('detach', {});

        remove(container);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        _get$4(Viewer.prototype.__proto__ || Object.getPrototypeOf(Viewer.prototype), 'destroy', this).call(this);

        this.detach();
      }
    }, {
      key: 'getModules',
      value: function getModules() {
        return Viewer._getModules();
      }
    }], [{
      key: '_getModules',
      value: function _getModules() {
        return [CoreModule$2, DecisionPropertiesModule, LiteralExpressionPropertiesModule, PoweredByModule$1, TextareaModule, ViewDrdModule];
      }
    }, {
      key: '_createContainer',
      value: function _createContainer() {
        return domify('<div class="dmn-literal-expression-container"></div>');
      }
    }]);

    return Viewer;
  }(Viewer$2);

  var _typeof$80 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$110 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$136(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$69(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$80(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$69(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$80(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var DecisionPropertiesEditorComponent = function (_Component) {
    _inherits$69(DecisionPropertiesEditorComponent, _Component);

    function DecisionPropertiesEditorComponent(props, context) {
      _classCallCheck$136(this, DecisionPropertiesEditorComponent);

      var _this = _possibleConstructorReturn$69(this, (DecisionPropertiesEditorComponent.__proto__ || Object.getPrototypeOf(DecisionPropertiesEditorComponent)).call(this, props, context));

      _this.onElementsChanged = function () {
        _this.forceUpdate();
      };

      _this.setDecisionName = function (name) {
        _this._modeling.editDecisionName(name);
      };

      _this.setDecisionId = function (id) {
        var oldId = _this.getDecision().id;

        if (oldId === id) {
          return;
        }

        _this._modeling.editDecisionId(id);
      };

      _this.validateId = function (id) {
        return validateId(_this.getDecision(), id);
      };

      _this._viewer = context.injector.get('viewer');
      _this._modeling = context.injector.get('modeling');

      _this.setupChangeListeners({
        bind: _this.getDecision().id
      });
      return _this;
    }

    _createClass$110(DecisionPropertiesEditorComponent, [{
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this.setupChangeListeners({
          unbind: this.getDecision().id
        });
      }
    }, {
      key: 'getDecision',
      value: function getDecision() {
        return this._viewer.getDecision();
      }
    }, {
      key: 'setupChangeListeners',
      value: function setupChangeListeners(_ref) {
        var bind = _ref.bind,
            unbind = _ref.unbind;
        var changeSupport = this.context.changeSupport;

        if (typeof unbind === 'string') {
          changeSupport.offElementsChanged(unbind, this.onElementsChanged);
        }

        if (typeof bind === 'string') {
          changeSupport.onElementsChanged(bind, this.onElementsChanged);
        }
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _getDecision = this.getDecision(),
            name = _getDecision.name,
            id = _getDecision.id;

        return createVNode(1, 'header', 'decision-properties', [createComponentVNode(2, DecisionName, {
          'className': 'decision-name editor',
          'value': name,
          'onChange': this.setDecisionName
        }), createComponentVNode(2, DecisionId, {
          'className': 'decision-id editor',
          'value': id,
          'validate': this.validateId,
          'onChange': this.setDecisionId
        })], 4);
      }
    }]);

    return DecisionPropertiesEditorComponent;
  }(Component);

  var DecisionName = function (_EditableComponent) {
    _inherits$69(DecisionName, _EditableComponent);

    function DecisionName() {
      _classCallCheck$136(this, DecisionName);

      return _possibleConstructorReturn$69(this, (DecisionName.__proto__ || Object.getPrototypeOf(DecisionName)).apply(this, arguments));
    }

    _createClass$110(DecisionName, [{
      key: 'render',
      value: function render$$1() {

        return createVNode(1, 'h3', this.getClassName(), this.getEditor(), 0);
      }
    }]);

    return DecisionName;
  }(EditableComponent);

  var DecisionId = function (_EditableComponent2) {
    _inherits$69(DecisionId, _EditableComponent2);

    function DecisionId() {
      _classCallCheck$136(this, DecisionId);

      return _possibleConstructorReturn$69(this, (DecisionId.__proto__ || Object.getPrototypeOf(DecisionId)).apply(this, arguments));
    }

    _createClass$110(DecisionId, [{
      key: 'render',
      value: function render$$1() {

        return createVNode(1, 'h5', this.getClassName(), this.getEditor(), 0);
      }
    }]);

    return DecisionId;
  }(EditableComponent);

  function _classCallCheck$137(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var HIGH_PRIORITY$5 = 2000;

  var DecisionPropertiesEditor = function DecisionPropertiesEditor(components) {
    _classCallCheck$137(this, DecisionPropertiesEditor);

    components.onGetComponent('viewer', HIGH_PRIORITY$5, function () {
      return DecisionPropertiesEditorComponent;
    });
  };

  DecisionPropertiesEditor.$inject = ['components'];

  var DecisionPropertiesEditorModule = {
    __depends__: [DebounceInput],
    __init__: ['decisionProperties'],
    decisionProperties: ['type', DecisionPropertiesEditor]
  };

  var _createClass$111 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$138(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var NOT_REGISTERED_ERROR$2 = 'is not a registered action',
      IS_REGISTERED_ERROR$2 = 'is already registered';

  /**
   * An interface that provides access to modeling actions by decoupling
   * the one who requests the action to be triggered and the trigger itself.
   *
   * It's possible to add new actions by registering them with ´registerAction´ and likewise
   * unregister existing ones with ´unregisterAction´.
   *
   */

  var EditorActions$4 = function () {
    function EditorActions(commandStack, eventBus) {
      _classCallCheck$138(this, EditorActions);

      this._actions = {
        undo: function undo() {
          commandStack.undo();
        },
        redo: function redo() {
          commandStack.redo();
        }
      };
    }

    /**
     * Triggers a registered action
     *
     * @param  {String} action
     * @param  {Object} opts
     *
     * @return {Unknown} Returns what the registered listener returns
     */

    _createClass$111(EditorActions, [{
      key: 'trigger',
      value: function trigger(action, opts) {
        if (!this._actions[action]) {
          throw error$4(action, NOT_REGISTERED_ERROR$2);
        }

        return this._actions[action](opts);
      }

      /**
       * Registers a collections of actions.
       * The key of the object will be the name of the action.
       *
       * @param  {Object} actions
       */

    }, {
      key: 'register',
      value: function register(actions, listener) {
        var _this = this;

        if (typeof actions === 'string') {
          return this._registerAction(actions, listener);
        }

        forEach(actions, function (listener, action) {
          _this._registerAction(action, listener);
        }, this);
      }

      /**
       * Registers a listener to an action key
       *
       * @param  {String} action
       * @param  {Function} listener
       */

    }, {
      key: '_registerAction',
      value: function _registerAction(action, listener) {
        if (this.isRegistered(action)) {
          throw error$4(action, IS_REGISTERED_ERROR$2);
        }

        this._actions[action] = listener;
      }

      /**
       * Unregister an existing action
       *
       * @param {String} action
       */

    }, {
      key: 'unregister',
      value: function unregister(action) {
        if (!this.isRegistered(action)) {
          throw error$4(action, NOT_REGISTERED_ERROR$2);
        }

        this._actions[action] = undefined;
      }

      /**
       * Checks wether the given action is registered
       *
       * @param {String} action
       *
       * @return {Boolean}
       */

    }, {
      key: 'isRegistered',
      value: function isRegistered(action) {
        return !!this._actions[action];
      }
    }]);

    return EditorActions;
  }();

  EditorActions$4.$inject = ['commandStack', 'eventBus'];

  // helpers /////////////

  function error$4(action, message) {
    return new Error(action + ' ' + message);
  }

  var EditorActions$5 = {
    __init__: ['editorActions'],
    editorActions: ['type', EditorActions$4]
  };

  function isCmd$4(modifiers) {
    // ensure we don't react to AltGr
    // (mapped to CTRL + ALT)
    if (modifiers.altKey) {
      return false;
    }

    return modifiers.ctrlKey || modifiers.metaKey;
  }

  function isShift$2(modifiers) {
    return modifiers.shiftKey;
  }

  var _createClass$112 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$139(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * A keyboard abstraction that may be activated and
   * deactivated by users at will, consuming key events
   * and triggering diagram actions.
   *
   * The implementation fires the following key events that allow
   * other components to hook into key handling:
   *
   *  - keyboard.bind
   *  - keyboard.unbind
   *  - keyboard.init
   *  - keyboard.destroy
   *
   * All events contain the fields (node, listeners).
   *
   * A default binding for the keyboard may be specified via the
   * `keyboard.bindTo` configuration option.
   *
   * @param {Config} config
   * @param {EventBus} eventBus
   * @param {EditorActions} editorActions
   */

  var Keyboard$3 = function () {
    function Keyboard(config, eventBus, editorActions) {
      var _this = this;

      _classCallCheck$139(this, Keyboard);

      this._init = function () {
        _this._registerDefaultBindings();

        _this._fire('init');
      };

      this._destroy = function () {
        _this._fire('destroy');

        _this.unbind();
        _this._listeners = null;
      };

      this._keyHandler = function (event$$1) {

        var i,
            l,
            listeners = _this._listeners,
            code = event$$1.keyCode || event$$1.charCode || -1;

        for (i = 0; l = listeners[i]; i++) {
          if (l(code, event$$1)) {
            event$$1.preventDefault();
            event$$1.stopPropagation();

            return;
          }
        }
      };

      this.unbind = function () {
        var node = _this._node;

        if (node) {
          _this._fire('unbind');

          // unbind key events
          componentEvent.unbind(node, 'keydown', _this._keyHandler, true);
        }

        _this._node = null;
      };

      this._config = config || {};
      this._eventBus = eventBus;
      this._editorActions = editorActions;

      this._listeners = [];

      eventBus.on('viewer.destroy', this._destroy);
      eventBus.on('viewer.init', this._init);

      eventBus.on('attach', function () {

        if (_this._config.bindTo) {
          _this.bind(config.bindTo);
        }
      });

      eventBus.on('detach', this.unbind);
    }

    // our key handler is a singleton that passes
    // (keycode, modifiers) to each listener.
    //
    // listeners must indicate that they handled a key event
    // by returning true. This stops the event propagation.
    //


    _createClass$112(Keyboard, [{
      key: 'bind',
      value: function bind(node) {
        // make sure that the keyboard is only bound once to the DOM
        this.unbind();

        this._node = node;

        // bind key events
        componentEvent.bind(node, 'keydown', this._keyHandler, true);

        this._fire('bind');
      }
    }, {
      key: 'getBinding',
      value: function getBinding() {
        return this._node;
      }
    }, {
      key: '_fire',
      value: function _fire(event$$1) {
        this._eventBus.fire('keyboard.' + event$$1, {
          node: this._node,
          listeners: this._listeners
        });
      }
    }, {
      key: '_registerDefaultBindings',
      value: function _registerDefaultBindings() {

        var listeners = this._listeners;

        var editorActions = this._editorActions;

        // init default listeners

        // undo
        // (CTRL|CMD) + Z
        function undo(key, modifiers) {

          if (isCmd$4(modifiers) && !isShift$2(modifiers) && key === 90) {
            editorActions.trigger('undo');

            return true;
          }
        }

        // redo
        // CTRL + Y
        // CMD + SHIFT + Z
        function redo(key, modifiers) {

          if (isCmd$4(modifiers) && (key === 89 || key === 90 && isShift$2(modifiers))) {
            editorActions.trigger('redo');

            return true;
          }
        }

        listeners.push(undo);
        listeners.push(redo);
      }

      /**
       * Add a listener function that is notified with (key, modifiers) whenever
       * the keyboard is bound and the user presses a key.
       *
       * @param {Function} listenerFn
       */

    }, {
      key: 'addListener',
      value: function addListener(listenerFn) {
        this._listeners.unshift(listenerFn);
      }
    }, {
      key: 'removeListener',
      value: function removeListener(listenerFn) {
        this._listeners = this._listeners.filter(function (l) {
          return l !== listenerFn;
        });
      }
    }]);

    return Keyboard;
  }();

  Keyboard$3.$inject = ['config.keyboard', 'eventBus', 'editorActions'];

  var Keyboard$4 = {
    __depends__: [EditorActions$5],
    __init__: ['keyboard'],
    keyboard: ['type', Keyboard$3]
  };

  var _typeof$81 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$113 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$140(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$70(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$81(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$70(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$81(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var EXPRESSION_LANGUAGE_OPTIONS = [{
    label: 'FEEL',
    value: 'feel'
  }, {
    label: 'JUEL',
    value: 'juel'
  }, {
    label: 'JavaScript',
    value: 'javascript'
  }, {
    label: 'Groovy',
    value: 'groovy'
  }, {
    label: 'Python',
    value: 'python'
  }, {
    label: 'JRuby',
    value: 'jruby'
  }];

  var TYPE_REF_OPTIONS = [{
    label: 'string',
    value: 'string'
  }, {
    label: 'boolean',
    value: 'boolean'
  }, {
    label: 'integer',
    value: 'integer'
  }, {
    label: 'long',
    value: 'long'
  }, {
    label: 'double',
    value: 'double'
  }, {
    label: 'date',
    value: 'date'
  }];

  var LiteralExpressionPropertiesComponent$1 = function (_Component) {
    _inherits$70(LiteralExpressionPropertiesComponent, _Component);

    function LiteralExpressionPropertiesComponent(props, context) {
      _classCallCheck$140(this, LiteralExpressionPropertiesComponent);

      var _this = _possibleConstructorReturn$70(this, (LiteralExpressionPropertiesComponent.__proto__ || Object.getPrototypeOf(LiteralExpressionPropertiesComponent)).call(this, props, context));

      _this._viewer = context.injector.get('viewer');
      _this._modeling = context.injector.get('modeling');

      var decision = _this._viewer.getDecision();

      _this.state = {
        name: decision.variable.name,
        typeRef: decision.variable.typeRef,
        expressionLanguage: getExpressionLanguage$1(decision.literalExpression)
      };

      _this.setVariableName = _this.setVariableName.bind(_this);
      _this.setVariableType = _this.setVariableType.bind(_this);
      _this.setExpressionLanguage = _this.setExpressionLanguage.bind(_this);
      return _this;
    }

    _createClass$113(LiteralExpressionPropertiesComponent, [{
      key: 'setVariableName',
      value: function setVariableName(name) {
        this._modeling.editVariableName(name);

        this.setState({
          name: name
        });
      }
    }, {
      key: 'setVariableType',
      value: function setVariableType(typeRef) {
        if (typeRef === '') {
          this._modeling.editVariableType(undefined);

          this.setState({
            typeRef: undefined
          });
        } else {
          this._modeling.editVariableType(typeRef);

          this.setState({
            typeRef: typeRef
          });
        }
      }
    }, {
      key: 'setExpressionLanguage',
      value: function setExpressionLanguage(expressionLanguage) {
        if (expressionLanguage === '') {
          this._modeling.editExpressionLanguage(undefined);

          this.setState({
            expressionLanguage: undefined
          });
        } else {
          this._modeling.editExpressionLanguage(expressionLanguage);

          this.setState({
            expressionLanguage: expressionLanguage
          });
        }
      }
    }, {
      key: 'render',
      value: function render$$1() {
        var _state = this.state,
            expressionLanguage = _state.expressionLanguage,
            name = _state.name,
            typeRef = _state.typeRef;

        return createVNode(1, 'div', 'literal-expression-properties', createVNode(1, 'table', null, [createVNode(1, 'tr', null, [createVNode(1, 'td', null, createTextVNode('Variable Name:'), 2), createVNode(1, 'td', null, createComponentVNode(2, Input, {
          'className': 'variable-name-input',
          'onInput': this.setVariableName,
          'placeholder': 'name',
          'value': name || ''
        }), 2)], 4), createVNode(1, 'tr', null, [createVNode(1, 'td', null, createTextVNode('Variable Type:'), 2), createVNode(1, 'td', null, createVNode(1, 'div', 'dms-fill-row', createComponentVNode(2, InputSelect, {
          'onChange': this.setVariableType,
          'options': TYPE_REF_OPTIONS,
          'value': typeRef,
          'className': 'variable-type-select dms-block'
        }), 2), 2)], 4), createVNode(1, 'tr', null, [createVNode(1, 'td', null, createTextVNode('Expression Language:'), 2), createVNode(1, 'td', null, createVNode(1, 'div', 'dms-fill-row', createComponentVNode(2, InputSelect, {
          'onChange': this.setExpressionLanguage,
          'options': EXPRESSION_LANGUAGE_OPTIONS,
          'value': expressionLanguage,
          'className': 'expression-language-select dms-block'
        }), 2), 2)], 4)], 4), 2);
      }
    }]);

    return LiteralExpressionPropertiesComponent;
  }(Component);
  function getExpressionLanguage$1(literalExpression) {
    return literalExpression && literalExpression.expressionLanguage ? literalExpression.expressionLanguage.toLowerCase() : undefined;
  }

  function _classCallCheck$141(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var LOW_PRIORITY$12 = 500;

  var LiteralExpressionPropertiesEditor = function LiteralExpressionPropertiesEditor(components) {
    _classCallCheck$141(this, LiteralExpressionPropertiesEditor);

    components.onGetComponent('viewer', LOW_PRIORITY$12, function () {
      return LiteralExpressionPropertiesComponent$1;
    });
  };

  LiteralExpressionPropertiesEditor.$inject = ['components'];

  var LiteralExpressionPropertiesEditorModule = {
    __depends__: [DebounceInput, Keyboard$4],
    __init__: ['literalExpressionProperties'],
    literalExpressionProperties: ['type', LiteralExpressionPropertiesEditor]
  };

  var _createClass$114 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$142(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Modeling$4 = function () {
    function Modeling(commandStack, viewer, eventBus) {
      var _this = this;

      _classCallCheck$142(this, Modeling);

      this._commandStack = commandStack;
      this._viewer = viewer;
      this._eventBus = eventBus;

      eventBus.on('viewer.init', function () {

        // register modeling handlers
        registerHandlers$1(_this.getHandlers(), commandStack);
      });
    }

    _createClass$114(Modeling, [{
      key: 'getHandlers',
      value: function getHandlers() {
        return Modeling._getHandlers();
      }
    }, {
      key: 'getDecision',
      value: function getDecision() {
        return this._viewer.getDecision();
      }
    }, {
      key: 'editDecisionName',
      value: function editDecisionName(name) {
        var decision = this.getDecision();

        var context = {
          element: decision,
          properties: {
            name: name
          }
        };

        this._commandStack.execute('updateProperties', context);
      }
    }, {
      key: 'editDecisionId',
      value: function editDecisionId(id) {
        var decision = this.getDecision();

        var context = {
          element: decision,
          properties: {
            id: id
          }
        };

        this._commandStack.execute('updateProperties', context);
      }
    }, {
      key: 'editLiteralExpressionText',
      value: function editLiteralExpressionText(text) {
        var decision = this.getDecision(),
            literalExpression = decision.literalExpression;

        var context = {
          element: literalExpression,
          properties: {
            text: text
          }
        };

        this._commandStack.execute('updateProperties', context);
      }
    }, {
      key: 'editExpressionLanguage',
      value: function editExpressionLanguage(expressionLanguage) {
        var decision = this.getDecision(),
            literalExpression = decision.literalExpression;

        var context = {
          element: literalExpression,
          properties: {
            expressionLanguage: expressionLanguage
          }
        };

        this._commandStack.execute('updateProperties', context);
      }
    }, {
      key: 'editVariableName',
      value: function editVariableName(name) {
        var decision = this.getDecision(),
            variable = decision.variable;

        var context = {
          element: variable,
          properties: {
            name: name
          }
        };

        this._commandStack.execute('updateProperties', context);
      }
    }, {
      key: 'editVariableType',
      value: function editVariableType(typeRef) {
        var decision = this.getDecision(),
            variable = decision.variable;

        var context = {
          element: variable,
          properties: {
            typeRef: typeRef
          }
        };

        this._commandStack.execute('updateProperties', context);
      }
    }], [{
      key: '_getHandlers',
      value: function _getHandlers() {
        return {
          'updateProperties': EditPropertiesHandler
        };
      }
    }]);

    return Modeling;
  }();

  Modeling$4.$inject = ['commandStack', 'viewer', 'eventBus'];

  // helpers //////////////////////

  /**
   * Register handlers with the command stack
   *
   * @param {Object} handlers { id -> Handler } map
   * @param {CommandStack} commandStack
   */
  function registerHandlers$1(handlers, commandStack) {
    forEach(handlers, function (handler, id) {
      commandStack.registerHandler(id, handler);
    });
  }

  var ModelingModule$1 = {
    __init__: ['idChangeBehavior', 'modeling'],
    commandStack: ['type', CommandStack],
    idChangeBehavior: ['type', IdChangeBehavior],
    modeling: ['type', Modeling$4]
  };

  var _typeof$82 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$115 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$143(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$71(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$82(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$71(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$82(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var TextareaEditorComponent = function (_Component) {
    _inherits$71(TextareaEditorComponent, _Component);

    function TextareaEditorComponent(props, context) {
      _classCallCheck$143(this, TextareaEditorComponent);

      var _this = _possibleConstructorReturn$71(this, (TextareaEditorComponent.__proto__ || Object.getPrototypeOf(TextareaEditorComponent)).call(this, props, context));

      _this._modeling = context.injector.get('modeling');

      _this._viewer = context.injector.get('viewer');

      _this.editLiteralExpressionText = _this.editLiteralExpressionText.bind(_this);
      _this.onElementsChanged = _this.onElementsChanged.bind(_this);

      // there is only one single element

      var _this$getLiteralExpre = _this.getLiteralExpression(),
          id = _this$getLiteralExpre.id;

      context.changeSupport.onElementsChanged(id, _this.onElementsChanged);
      return _this;
    }

    _createClass$115(TextareaEditorComponent, [{
      key: 'getLiteralExpression',
      value: function getLiteralExpression() {
        return this._viewer.getDecision().literalExpression;
      }
    }, {
      key: 'onElementsChanged',
      value: function onElementsChanged() {
        this.forceUpdate();
      }
    }, {
      key: 'editLiteralExpressionText',
      value: function editLiteralExpressionText(text) {
        this._modeling.editLiteralExpressionText(text);
      }
    }, {
      key: 'render',
      value: function render$$1() {

        // there is only one single element
        var _getLiteralExpression = this.getLiteralExpression(),
            text = _getLiteralExpression.text;

        return createComponentVNode(2, Editor$2, {
          'className': 'textarea editor',
          'value': text,
          'onChange': this.editLiteralExpressionText
        });
      }
    }]);

    return TextareaEditorComponent;
  }(Component);

  var Editor$2 = function (_EditableComponent) {
    _inherits$71(Editor, _EditableComponent);

    function Editor() {
      _classCallCheck$143(this, Editor);

      return _possibleConstructorReturn$71(this, (Editor.__proto__ || Object.getPrototypeOf(Editor)).apply(this, arguments));
    }

    _createClass$115(Editor, [{
      key: 'render',
      value: function render$$1() {

        return createVNode(1, 'div', this.getClassName(), this.getEditor(), 0);
      }
    }]);

    return Editor;
  }(EditableComponent);

  function _classCallCheck$144(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Textarea$1 = function Textarea(components) {
    _classCallCheck$144(this, Textarea);

    components.onGetComponent('viewer', function () {
      return TextareaEditorComponent;
    });
  };

  Textarea$1.$inject = ['components'];

  var TextareaEditorComponent$1 = {
    __depends__: [DebounceInput],
    __init__: ['textarea'],
    textarea: ['type', Textarea$1]
  };

  var _typeof$83 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$116 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _toConsumableArray$12(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function _classCallCheck$145(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn$72(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$83(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$72(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$83(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var Editor$3 = function (_Viewer) {
    _inherits$72(Editor, _Viewer);

    function Editor() {
      _classCallCheck$145(this, Editor);

      return _possibleConstructorReturn$72(this, (Editor.__proto__ || Object.getPrototypeOf(Editor)).apply(this, arguments));
    }

    _createClass$116(Editor, [{
      key: 'getModules',
      value: function getModules() {
        return [].concat(_toConsumableArray$12(Viewer$3._getModules()), _toConsumableArray$12(Editor._getModules()));
      }
    }], [{
      key: '_getModules',
      value: function _getModules() {
        return [DecisionPropertiesEditorModule, Keyboard$4, LiteralExpressionPropertiesEditorModule, ModelingModule$1, TextareaEditorComponent$1];
      }
    }]);

    return Editor;
  }(Viewer$3);

  var _createClass$117 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck$146(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn$73(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$73(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  /**
   * The dmn editor.
   */

  var Modeler$1 = function (_EditingManager) {
    _inherits$73(Modeler$$1, _EditingManager);

    function Modeler$$1() {
      _classCallCheck$146(this, Modeler$$1);

      return _possibleConstructorReturn$73(this, (Modeler$$1.__proto__ || Object.getPrototypeOf(Modeler$$1)).apply(this, arguments));
    }

    _createClass$117(Modeler$$1, [{
      key: '_getViewProviders',
      value: function _getViewProviders() {

        return [{
          id: 'drd',
          constructor: Modeler,
          opens: 'dmn:Definitions'
        }, {
          id: 'decisionTable',
          constructor: Editor$1,
          opens: function opens(element) {
            return is(element, 'dmn:Decision') && element.decisionTable;
          }
        }, {
          id: 'literalExpression',
          constructor: Editor$3,
          opens: function opens(element) {
            return is(element, 'dmn:Decision') && element.literalExpression;
          }
        }];
      }
    }, {
      key: '_getInitialView',
      value: function _getInitialView(views) {

        var definitionsView;

        for (var i = 0; i < views.length; i++) {

          var view = views[i];
          var el = view.element;

          if (is(el, 'dmn:Decision')) {
            return view;
          }

          if (is(el, 'dmn:Definitions')) {
            definitionsView = view;

            if (containsDi(el)) {
              return view;
            }
          }
        }

        return definitionsView || views[0];
      }
    }]);

    return Modeler$$1;
  }(EditingManager);

  return Modeler$1;

})));
